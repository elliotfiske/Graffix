# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 176 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 1 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/cdefs.h" 1 3 4
# 506 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 507 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/cdefs.h" 2 3 4
# 572 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 573 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/cdefs.h" 2 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/Availability.h" 1 3 4
# 151 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/Availability.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/AvailabilityInternal.h" 1 3 4
# 152 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/Availability.h" 2 3 4
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types.h" 1 3 4
# 27 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_types.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types.h" 2 3 4
# 55 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types.h" 2 3 4
# 28 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types.h" 2 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 68 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_va_list.h" 3 4
typedef __darwin_va_list va_list;
# 72 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_size_t.h" 3 4
typedef __darwin_size_t size_t;
# 73 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 74 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/stdio.h" 1 3 4
# 37 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/stdio.h" 3 4
extern "C" {

int renameat(int, const char *, int, const char *) __attribute__((availability(macosx,introduced=10.10)));

}
# 76 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;
# 88 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 122 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read) (void *, char *, int);
 fpos_t (*_seek) (void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;
}
# 230 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * , fpos_t *);
char *fgets(char * , int, FILE *);



FILE *fopen(const char * , const char * ) __asm("_" "fopen");

int fprintf(FILE * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * , FILE * ) __asm("_" "fputs") ;
size_t fread(void * , size_t, size_t, FILE * );
FILE *freopen(const char * , const char * ,
                 FILE * ) __asm("_" "freopen") ;
int fscanf(FILE * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * , size_t, size_t, FILE * ) __asm("_" "fwrite") ;
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *);
int printf(const char * , ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *, const char *);
void rewind(FILE *);
int scanf(const char * , ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * , char * );
int setvbuf(FILE * , char * , int, size_t);
int sprintf(char * , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
int sscanf(const char * , const char * , ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);


__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * , va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
}
# 292 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
extern "C" {



char *ctermid(char *);





FILE *fdopen(int, const char *) __asm("_" "fdopen");

int fileno(FILE *);
}
# 314 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
extern "C" {
int pclose(FILE *);



FILE *popen(const char *, const char *) __asm("_" "popen");

}
# 336 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
extern "C" {
int __srget(FILE *);
int __svfscanf(FILE *, const char *, va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);
}







inline __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 373 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
extern "C" {
void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);



__attribute__((deprecated("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *, const char *) __asm("_" "tempnam") ;
}
# 411 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_off_t.h" 3 4
typedef __darwin_off_t off_t;
# 412 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
int fseeko(FILE *, off_t, int);
off_t ftello(FILE *);
}



extern "C" {
int snprintf(char * , size_t, const char * , ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * , va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * , size_t, const char * , va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * , const char * , va_list) __attribute__((__format__ (__scanf__, 2, 0)));
}
# 436 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 437 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdio.h" 2 3 4

extern "C" {
int dprintf(int, const char * , ...) __attribute__((__format__ (__printf__, 2, 3))) __attribute__((availability(macosx,introduced=10.7)));
int vdprintf(int, const char * , va_list) __attribute__((__format__ (__printf__, 2, 0))) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getdelim(char ** , size_t * , int, FILE * ) __attribute__((availability(macosx,introduced=10.7)));
ssize_t getline(char ** , size_t * , FILE * ) __attribute__((availability(macosx,introduced=10.7)));
}







extern "C" {
extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** , const char * , ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** , const char * , va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (*)(void *, char *, int),
                 int (*)(void *, const char *, int),
                 fpos_t (*)(void *, fpos_t, int),
                 int (*)(void *));
}
# 2 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 1 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 1 3 4
# 79 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;






# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_pid_t.h" 3 4
typedef __darwin_pid_t pid_t;
# 90 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_id_t.h" 3 4
typedef __darwin_id_t id_t;
# 91 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 2 3 4
# 109 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 1 3 4
# 73 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 74 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/signal.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/signal.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/signal.h" 1 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/signal.h" 3 4
typedef int sig_atomic_t;
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/signal.h" 2 3 4
# 82 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4
# 145 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 89 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,





    __rc :2,






             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 147 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 191 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 210 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 232 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};


struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};
# 402 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 422 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};
# 454 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 509 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};


struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};
# 751 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 771 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/mach/i386/_structs.h" 3 4
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h" 2 3 4




struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};


struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};
# 76 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h" 3 4
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};


struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};
# 115 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h" 3 4
typedef struct __darwin_mcontext64 *mcontext_t;
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 146 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
typedef __darwin_pthread_attr_t pthread_attr_t;
# 148 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 36 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 150 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 151 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
typedef __darwin_sigset_t sigset_t;
# 154 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_uid_t.h" 3 4
typedef __darwin_uid_t uid_t;
# 156 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 2 3 4

union sigval {

 int sival_int;
 void *sival_ptr;
};





struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 268 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 3 4
union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
         void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};
# 330 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 3 4
typedef void (*sig_t)(int);
# 347 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 3 4
struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};
# 366 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 3 4
struct sigstack {
 char *ss_sp;
 int ss_onstack;
};
# 388 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/signal.h" 3 4
extern "C" {
void (*signal(int, void (*)(int)))(int);
}
# 110 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 1 3 4
# 72 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 1 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 1 3 4
# 18 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 19 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 22 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 25 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 26 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 27 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;






# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
typedef __darwin_intptr_t intptr_t;
# 54 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 55 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 59 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 60 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdint.h" 2 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h" 2 3 4
# 73 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 2 3 4







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_timeval.h" 3 4
struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 2 3 4








typedef __uint64_t rlim_t;
# 152 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 163 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 3 4
 long ru_maxrss;

 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;


};
# 192 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 3 4
typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};

typedef struct rusage_info_v3 rusage_info_current;
# 325 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 3 4
struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};
# 353 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 3 4
struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};
# 382 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/resource.h" 3 4
extern "C" {
int getpriority(int, id_t);

int getiopolicy_np(int, int) __attribute__((availability(macosx,introduced=10.5)));

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit") ;
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) __attribute__((availability(macosx,introduced=10.5)));

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit") ;
}
# 111 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 2 3 4
# 186 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/endian.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/endian.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/endian.h" 1 3 4
# 99 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/endian.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_endian.h" 1 3 4
# 130 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
    __uint16_t _data
)
{
    return ((__uint16_t)((_data << 8) | (_data >> 8)));
}

static inline
__uint32_t
_OSSwapInt32(
    __uint32_t _data
)
{

    return __builtin_bswap32(_data);




}


static inline
__uint64_t
_OSSwapInt64(
    __uint64_t _data
)
{
    return __builtin_bswap64(_data);
}
# 67 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4
# 131 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_endian.h" 2 3 4
# 100 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/endian.h" 2 3 4
# 36 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/endian.h" 2 3 4
# 187 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 2 3 4







union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
    w_Coredump:1,
    w_Retcode:8,
    w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
    w_Stopsig:8,
    w_Filler:16;






 } w_S;
};
# 247 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/wait.h" 3 4
extern "C" {
pid_t wait(int *) __asm("_" "wait") ;
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid") ;

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid") ;


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);

}
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/alloca.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/alloca.h" 3 4
extern "C" {
void *alloca(size_t);
}
# 68 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4








# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ct_rune_t.h" 3 4
typedef __darwin_ct_rune_t ct_rune_t;
# 77 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_rune_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_rune_t.h" 3 4
typedef __darwin_rune_t rune_t;
# 78 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;
# 117 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
# 127 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 3 4
extern "C" {
void abort(void) __attribute__((noreturn));
int abs(int) __attribute__((const));
int atexit(void (*)(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *, const void *, size_t,
     size_t, int (*)(const void *, const void *));
void *calloc(size_t, size_t);
div_t div(int, int) __attribute__((const));
void exit(int) __attribute__((noreturn));
void free(void *);
char *getenv(const char *);
long labs(long) __attribute__((const));
ldiv_t ldiv(long, long) __attribute__((const));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);

void *malloc(size_t);
int mblen(const char *, size_t);
size_t mbstowcs(wchar_t * , const char * , size_t);
int mbtowc(wchar_t * , const char * , size_t);
int posix_memalign(void **, size_t, size_t) __attribute__((availability(macosx,introduced=10.6)));
void qsort(void *, size_t, size_t,
     int (*)(const void *, const void *));
int rand(void);
void *realloc(void *, size_t);
void srand(unsigned);
double strtod(const char *, char **) __asm("_" "strtod") ;
float strtof(const char *, char **) __asm("_" "strtof") ;
long strtol(const char *, char **, int);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *, char **, int);

unsigned long
  strtoul(const char *, char **, int);

unsigned long long
  strtoull(const char *, char **, int);

int system(const char *) __asm("_" "system") __attribute__((availability(macosx,introduced=10.0)));
size_t wcstombs(char * , const wchar_t * , size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((noreturn));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *, int *);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *, int *);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]);
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void);
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void);
long nrand48(unsigned short[3]);
int posix_openpt(int);
char *ptsname(int);
int putenv(char *) __asm("_" "putenv") ;
long random(void);
int rand_r(unsigned *);

char *realpath(const char * , char * ) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char *, const char *, int) __asm("_" "setenv") ;

void setkey(const char *) __asm("_" "setkey") ;



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv") ;







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/types.h" 1 3 4
# 35 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/types.h" 1 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/types.h" 3 4
typedef unsigned char u_int8_t;
typedef unsigned short u_int16_t;
typedef unsigned int u_int32_t;
typedef unsigned long long u_int64_t;


typedef int64_t register_t;
# 97 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/types.h" 3 4
typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 36 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/types.h" 2 3 4
# 239 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_dev_t.h" 3 4
typedef __darwin_dev_t dev_t;
# 241 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_mode_t.h" 3 4
typedef __darwin_mode_t mode_t;
# 242 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/stdlib.h" 2 3 4

u_int32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int );
void arc4random_buf(void * , size_t ) __attribute__((availability(macosx,introduced=10.7)));
void arc4random_stir(void);
u_int32_t
  arc4random_uniform(u_int32_t ) __attribute__((availability(macosx,introduced=10.7)));

int atexit_b(void (^)(void)) __attribute__((availability(macosx,introduced=10.6)));
void *bsearch_b(const void *, const void *, size_t,
     size_t, int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));



char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") __attribute__((availability(macosx,introduced=10.0,deprecated=10.5)));
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);

int heapsort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int heapsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

int mergesort(void *, size_t, size_t,
     int (*)(const void *, const void *));

int mergesort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort(void *, size_t, size_t,
     int (*)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void psort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_b(void *, size_t, size_t,
     int (^)(const void *, const void *)) __attribute__((availability(macosx,introduced=10.6)));

void qsort_r(void *, size_t, size_t, void *,
     int (*)(void *, const void *, const void *));
int radixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void setprogname(const char *);
int sradixsort(const unsigned char **, int, const unsigned char *,
     unsigned);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *, size_t);

long long
  strtoq(const char *, char **, int);
unsigned long long
  strtouq(const char *, char **, int);

extern char *suboptarg;
void *valloc(size_t);






}
# 3 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/time.h" 1 3 4
# 67 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/time.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_clock_t.h" 3 4
typedef __darwin_clock_t clock_t;
# 68 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/time.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_time_t.h" 3 4
typedef __darwin_time_t time_t;
# 71 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/time.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_timespec.h" 3 4
struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 72 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/time.h" 2 3 4

struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};
# 96 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/time.h" 3 4
extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone") ;

extern int daylight;

extern "C" {
char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock") ;
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime") ;
size_t strftime(char * , size_t, const char * , const struct tm * ) __asm("_" "strftime") ;
char *strptime(const char * , const char * , struct tm * ) __asm("_" "strptime") ;
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * , char * );
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * , struct tm * );
struct tm *localtime_r(const time_t * , struct tm * );


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *, struct timespec *) __asm("_" "nanosleep") ;

}
# 4 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h" 1
# 208 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 34 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 53 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 3 4
typedef long unsigned int rsize_t;
# 208 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h" 2
# 254 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
extern "C" {







typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;
# 288 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef int64_t GLint64EXT;
typedef uint64_t GLuint64EXT;

typedef GLint64EXT GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;
# 832 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
extern void glAccum (GLenum op, GLfloat value);
extern void glAlphaFunc (GLenum func, GLclampf ref);
extern GLboolean glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
extern void glArrayElement (GLint i);
extern void glBegin (GLenum mode);
extern void glBindTexture (GLenum target, GLuint texture);
extern void glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
extern void glBlendFunc (GLenum sfactor, GLenum dfactor);
extern void glCallList (GLuint list);
extern void glCallLists (GLsizei n, GLenum type, const GLvoid *lists);
extern void glClear (GLbitfield mask);
extern void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
extern void glClearDepth (GLclampd depth);
extern void glClearIndex (GLfloat c);
extern void glClearStencil (GLint s);
extern void glClipPlane (GLenum plane, const GLdouble *equation);
extern void glColor3b (GLbyte red, GLbyte green, GLbyte blue);
extern void glColor3bv (const GLbyte *v);
extern void glColor3d (GLdouble red, GLdouble green, GLdouble blue);
extern void glColor3dv (const GLdouble *v);
extern void glColor3f (GLfloat red, GLfloat green, GLfloat blue);
extern void glColor3fv (const GLfloat *v);
extern void glColor3i (GLint red, GLint green, GLint blue);
extern void glColor3iv (const GLint *v);
extern void glColor3s (GLshort red, GLshort green, GLshort blue);
extern void glColor3sv (const GLshort *v);
extern void glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
extern void glColor3ubv (const GLubyte *v);
extern void glColor3ui (GLuint red, GLuint green, GLuint blue);
extern void glColor3uiv (const GLuint *v);
extern void glColor3us (GLushort red, GLushort green, GLushort blue);
extern void glColor3usv (const GLushort *v);
extern void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
extern void glColor4bv (const GLbyte *v);
extern void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
extern void glColor4dv (const GLdouble *v);
extern void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
extern void glColor4fv (const GLfloat *v);
extern void glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
extern void glColor4iv (const GLint *v);
extern void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
extern void glColor4sv (const GLshort *v);
extern void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
extern void glColor4ubv (const GLubyte *v);
extern void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
extern void glColor4uiv (const GLuint *v);
extern void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
extern void glColor4usv (const GLushort *v);
extern void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
extern void glColorMaterial (GLenum face, GLenum mode);
extern void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
extern void glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
extern void glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
extern void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
extern void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
extern void glCullFace (GLenum mode);
extern void glDeleteLists (GLuint list, GLsizei range);
extern void glDeleteTextures (GLsizei n, const GLuint *textures);
extern void glDepthFunc (GLenum func);
extern void glDepthMask (GLboolean flag);
extern void glDepthRange (GLclampd zNear, GLclampd zFar);
extern void glDisable (GLenum cap);
extern void glDisableClientState (GLenum array);
extern void glDrawArrays (GLenum mode, GLint first, GLsizei count);
extern void glDrawBuffer (GLenum mode);
extern void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
extern void glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glEdgeFlag (GLboolean flag);
extern void glEdgeFlagPointer (GLsizei stride, const GLvoid *pointer);
extern void glEdgeFlagv (const GLboolean *flag);
extern void glEnable (GLenum cap);
extern void glEnableClientState (GLenum array);
extern void glEnd (void);
extern void glEndList (void);
extern void glEvalCoord1d (GLdouble u);
extern void glEvalCoord1dv (const GLdouble *u);
extern void glEvalCoord1f (GLfloat u);
extern void glEvalCoord1fv (const GLfloat *u);
extern void glEvalCoord2d (GLdouble u, GLdouble v);
extern void glEvalCoord2dv (const GLdouble *u);
extern void glEvalCoord2f (GLfloat u, GLfloat v);
extern void glEvalCoord2fv (const GLfloat *u);
extern void glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
extern void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
extern void glEvalPoint1 (GLint i);
extern void glEvalPoint2 (GLint i, GLint j);
extern void glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
extern void glFinish (void);
extern void glFlush (void);
extern void glFogf (GLenum pname, GLfloat param);
extern void glFogfv (GLenum pname, const GLfloat *params);
extern void glFogi (GLenum pname, GLint param);
extern void glFogiv (GLenum pname, const GLint *params);
extern void glFrontFace (GLenum mode);
extern void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern GLuint glGenLists (GLsizei range);
extern void glGenTextures (GLsizei n, GLuint *textures);
extern void glGetBooleanv (GLenum pname, GLboolean *params);
extern void glGetClipPlane (GLenum plane, GLdouble *equation);
extern void glGetDoublev (GLenum pname, GLdouble *params);
extern GLenum glGetError (void);
extern void glGetFloatv (GLenum pname, GLfloat *params);
extern void glGetIntegerv (GLenum pname, GLint *params);
extern void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
extern void glGetLightiv (GLenum light, GLenum pname, GLint *params);
extern void glGetMapdv (GLenum target, GLenum query, GLdouble *v);
extern void glGetMapfv (GLenum target, GLenum query, GLfloat *v);
extern void glGetMapiv (GLenum target, GLenum query, GLint *v);
extern void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
extern void glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
extern void glGetPixelMapfv (GLenum map, GLfloat *values);
extern void glGetPixelMapuiv (GLenum map, GLuint *values);
extern void glGetPixelMapusv (GLenum map, GLushort *values);
extern void glGetPointerv (GLenum pname, GLvoid* *params);
extern void glGetPolygonStipple (GLubyte *mask);
extern const GLubyte * glGetString (GLenum name);
extern void glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
extern void glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
extern void glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
extern void glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
extern void glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, GLvoid *pixels);
extern void glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
extern void glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
extern void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
extern void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
extern void glHint (GLenum target, GLenum mode);
extern void glIndexMask (GLuint mask);
extern void glIndexPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glIndexd (GLdouble c);
extern void glIndexdv (const GLdouble *c);
extern void glIndexf (GLfloat c);
extern void glIndexfv (const GLfloat *c);
extern void glIndexi (GLint c);
extern void glIndexiv (const GLint *c);
extern void glIndexs (GLshort c);
extern void glIndexsv (const GLshort *c);
extern void glIndexub (GLubyte c);
extern void glIndexubv (const GLubyte *c);
extern void glInitNames (void);
extern void glInterleavedArrays (GLenum format, GLsizei stride, const GLvoid *pointer);
extern GLboolean glIsEnabled (GLenum cap);
extern GLboolean glIsList (GLuint list);
extern GLboolean glIsTexture (GLuint texture);
extern void glLightModelf (GLenum pname, GLfloat param);
extern void glLightModelfv (GLenum pname, const GLfloat *params);
extern void glLightModeli (GLenum pname, GLint param);
extern void glLightModeliv (GLenum pname, const GLint *params);
extern void glLightf (GLenum light, GLenum pname, GLfloat param);
extern void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
extern void glLighti (GLenum light, GLenum pname, GLint param);
extern void glLightiv (GLenum light, GLenum pname, const GLint *params);
extern void glLineStipple (GLint factor, GLushort pattern);
extern void glLineWidth (GLfloat width);
extern void glListBase (GLuint base);
extern void glLoadIdentity (void);
extern void glLoadMatrixd (const GLdouble *m);
extern void glLoadMatrixf (const GLfloat *m);
extern void glLoadName (GLuint name);
extern void glLogicOp (GLenum opcode);
extern void glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
extern void glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
extern void glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
extern void glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
extern void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
extern void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
extern void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
extern void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
extern void glMaterialf (GLenum face, GLenum pname, GLfloat param);
extern void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
extern void glMateriali (GLenum face, GLenum pname, GLint param);
extern void glMaterialiv (GLenum face, GLenum pname, const GLint *params);
extern void glMatrixMode (GLenum mode);
extern void glMultMatrixd (const GLdouble *m);
extern void glMultMatrixf (const GLfloat *m);
extern void glNewList (GLuint list, GLenum mode);
extern void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
extern void glNormal3bv (const GLbyte *v);
extern void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
extern void glNormal3dv (const GLdouble *v);
extern void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
extern void glNormal3fv (const GLfloat *v);
extern void glNormal3i (GLint nx, GLint ny, GLint nz);
extern void glNormal3iv (const GLint *v);
extern void glNormal3s (GLshort nx, GLshort ny, GLshort nz);
extern void glNormal3sv (const GLshort *v);
extern void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
extern void glPassThrough (GLfloat token);
extern void glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
extern void glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
extern void glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
extern void glPixelStoref (GLenum pname, GLfloat param);
extern void glPixelStorei (GLenum pname, GLint param);
extern void glPixelTransferf (GLenum pname, GLfloat param);
extern void glPixelTransferi (GLenum pname, GLint param);
extern void glPixelZoom (GLfloat xfactor, GLfloat yfactor);
extern void glPointSize (GLfloat size);
extern void glPolygonMode (GLenum face, GLenum mode);
extern void glPolygonOffset (GLfloat factor, GLfloat units);
extern void glPolygonStipple (const GLubyte *mask);
extern void glPopAttrib (void);
extern void glPopClientAttrib (void);
extern void glPopMatrix (void);
extern void glPopName (void);
extern void glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
extern void glPushAttrib (GLbitfield mask);
extern void glPushClientAttrib (GLbitfield mask);
extern void glPushMatrix (void);
extern void glPushName (GLuint name);
extern void glRasterPos2d (GLdouble x, GLdouble y);
extern void glRasterPos2dv (const GLdouble *v);
extern void glRasterPos2f (GLfloat x, GLfloat y);
extern void glRasterPos2fv (const GLfloat *v);
extern void glRasterPos2i (GLint x, GLint y);
extern void glRasterPos2iv (const GLint *v);
extern void glRasterPos2s (GLshort x, GLshort y);
extern void glRasterPos2sv (const GLshort *v);
extern void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
extern void glRasterPos3dv (const GLdouble *v);
extern void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
extern void glRasterPos3fv (const GLfloat *v);
extern void glRasterPos3i (GLint x, GLint y, GLint z);
extern void glRasterPos3iv (const GLint *v);
extern void glRasterPos3s (GLshort x, GLshort y, GLshort z);
extern void glRasterPos3sv (const GLshort *v);
extern void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glRasterPos4dv (const GLdouble *v);
extern void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glRasterPos4fv (const GLfloat *v);
extern void glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
extern void glRasterPos4iv (const GLint *v);
extern void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glRasterPos4sv (const GLshort *v);
extern void glReadBuffer (GLenum mode);
extern void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
extern void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
extern void glRectdv (const GLdouble *v1, const GLdouble *v2);
extern void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
extern void glRectfv (const GLfloat *v1, const GLfloat *v2);
extern void glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
extern void glRectiv (const GLint *v1, const GLint *v2);
extern void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
extern void glRectsv (const GLshort *v1, const GLshort *v2);
extern GLint glRenderMode (GLenum mode);
extern void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
extern void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
extern void glScaled (GLdouble x, GLdouble y, GLdouble z);
extern void glScalef (GLfloat x, GLfloat y, GLfloat z);
extern void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
extern void glSelectBuffer (GLsizei size, GLuint *buffer);
extern void glShadeModel (GLenum mode);
extern void glStencilFunc (GLenum func, GLint ref, GLuint mask);
extern void glStencilMask (GLuint mask);
extern void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
extern void glTexCoord1d (GLdouble s);
extern void glTexCoord1dv (const GLdouble *v);
extern void glTexCoord1f (GLfloat s);
extern void glTexCoord1fv (const GLfloat *v);
extern void glTexCoord1i (GLint s);
extern void glTexCoord1iv (const GLint *v);
extern void glTexCoord1s (GLshort s);
extern void glTexCoord1sv (const GLshort *v);
extern void glTexCoord2d (GLdouble s, GLdouble t);
extern void glTexCoord2dv (const GLdouble *v);
extern void glTexCoord2f (GLfloat s, GLfloat t);
extern void glTexCoord2fv (const GLfloat *v);
extern void glTexCoord2i (GLint s, GLint t);
extern void glTexCoord2iv (const GLint *v);
extern void glTexCoord2s (GLshort s, GLshort t);
extern void glTexCoord2sv (const GLshort *v);
extern void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
extern void glTexCoord3dv (const GLdouble *v);
extern void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
extern void glTexCoord3fv (const GLfloat *v);
extern void glTexCoord3i (GLint s, GLint t, GLint r);
extern void glTexCoord3iv (const GLint *v);
extern void glTexCoord3s (GLshort s, GLshort t, GLshort r);
extern void glTexCoord3sv (const GLshort *v);
extern void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
extern void glTexCoord4dv (const GLdouble *v);
extern void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
extern void glTexCoord4fv (const GLfloat *v);
extern void glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
extern void glTexCoord4iv (const GLint *v);
extern void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
extern void glTexCoord4sv (const GLshort *v);
extern void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
extern void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexEnvi (GLenum target, GLenum pname, GLint param);
extern void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
extern void glTexGend (GLenum coord, GLenum pname, GLdouble param);
extern void glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
extern void glTexGenf (GLenum coord, GLenum pname, GLfloat param);
extern void glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
extern void glTexGeni (GLenum coord, GLenum pname, GLint param);
extern void glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
extern void glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
extern void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
extern void glTexParameteri (GLenum target, GLenum pname, GLint param);
extern void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
extern void glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
extern void glTranslated (GLdouble x, GLdouble y, GLdouble z);
extern void glTranslatef (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex2d (GLdouble x, GLdouble y);
extern void glVertex2dv (const GLdouble *v);
extern void glVertex2f (GLfloat x, GLfloat y);
extern void glVertex2fv (const GLfloat *v);
extern void glVertex2i (GLint x, GLint y);
extern void glVertex2iv (const GLint *v);
extern void glVertex2s (GLshort x, GLshort y);
extern void glVertex2sv (const GLshort *v);
extern void glVertex3d (GLdouble x, GLdouble y, GLdouble z);
extern void glVertex3dv (const GLdouble *v);
extern void glVertex3f (GLfloat x, GLfloat y, GLfloat z);
extern void glVertex3fv (const GLfloat *v);
extern void glVertex3i (GLint x, GLint y, GLint z);
extern void glVertex3iv (const GLint *v);
extern void glVertex3s (GLshort x, GLshort y, GLshort z);
extern void glVertex3sv (const GLshort *v);
extern void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
extern void glVertex4dv (const GLdouble *v);
extern void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
extern void glVertex4fv (const GLfloat *v);
extern void glVertex4i (GLint x, GLint y, GLint z, GLint w);
extern void glVertex4iv (const GLint *v);
extern void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
extern void glVertex4sv (const GLshort *v);
extern void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
extern void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
# 1178 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 1 3







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/OpenGLAvailability.h" 1 3
# 9 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3
# 10 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 2 3


extern "C" {
# 219 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
class GLUnurbs;
class GLUquadric;
class GLUtesselator;

typedef class GLUnurbs GLUnurbsObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
typedef class GLUquadric GLUquadricObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
typedef class GLUtesselator GLUtesselatorObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
typedef class GLUtesselator GLUtriangulatorObj __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
# 240 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/glu.h" 3
extern void gluBeginCurve (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluBeginPolygon (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluBeginSurface (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluBeginTrim (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluBuild1DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild1DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLenum format, GLenum type, const void *data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild2DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmapLevels (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLint level, GLint base, GLint max, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLint gluBuild3DMipmaps (GLenum target, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use glGenerateMipmap\"" "")));
extern GLboolean gluCheckExtension (const GLubyte *extName, const GLubyte *extString) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9)));
extern void gluCylinder (GLUquadric* quad, GLdouble base, GLdouble top, GLdouble height, GLint slices, GLint stacks) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDeleteNurbsRenderer (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDeleteQuadric (GLUquadric* quad) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDeleteTess (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndCurve (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndPolygon (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndSurface (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluEndTrim (GLUnurbs* nurb) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern const GLubyte * gluErrorString (GLenum error) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluGetNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern const GLubyte * gluGetString (GLenum name) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluGetTessProperty (GLUtesselator* tess, GLenum which, GLdouble* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluLoadSamplingMatrices (GLUnurbs* nurb, const GLfloat *model, const GLfloat *perspective, const GLint *view) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluLookAt (GLdouble eyeX, GLdouble eyeY, GLdouble eyeZ, GLdouble centerX, GLdouble centerY, GLdouble centerZ, GLdouble upX, GLdouble upY, GLdouble upZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMatrix4MakeLookAt\"" "")));
extern GLUnurbs* gluNewNurbsRenderer (void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLUquadric* gluNewQuadric (void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLUtesselator* gluNewTess (void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNextContour (GLUtesselator* tess, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsCallback (GLUnurbs* nurb, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsCallbackData (GLUnurbs* nurb, GLvoid* userData) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9)));
extern void gluNurbsCallbackDataEXT (GLUnurbs* nurb, GLvoid* userData) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsCurve (GLUnurbs* nurb, GLint knotCount, GLfloat *knots, GLint stride, GLfloat *control, GLint order, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsProperty (GLUnurbs* nurb, GLenum property, GLfloat value) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluNurbsSurface (GLUnurbs* nurb, GLint sKnotCount, GLfloat* sKnots, GLint tKnotCount, GLfloat* tKnots, GLint sStride, GLint tStride, GLfloat* control, GLint sOrder, GLint tOrder, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluOrtho2D (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMatrix4MakeOrtho\"" "")));
extern void gluPartialDisk (GLUquadric* quad, GLdouble inner, GLdouble outer, GLint slices, GLint loops, GLdouble start, GLdouble sweep) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluPerspective (GLdouble fovy, GLdouble aspect, GLdouble zNear, GLdouble zFar) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMatrix4MakePerspective\"" "")));
extern void gluPickMatrix (GLdouble x, GLdouble y, GLdouble delX, GLdouble delY, GLint *viewport) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluProject (GLdouble objX, GLdouble objY, GLdouble objZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* winX, GLdouble* winY, GLdouble* winZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMathProject\"" "")));
extern void gluPwlCurve (GLUnurbs* nurb, GLint count, GLfloat* data, GLint stride, GLenum type) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricCallback (GLUquadric* quad, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricDrawStyle (GLUquadric* quad, GLenum draw) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricNormals (GLUquadric* quad, GLenum normal) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricOrientation (GLUquadric* quad, GLenum orientation) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluQuadricTexture (GLUquadric* quad, GLboolean texture) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluScaleImage (GLenum format, GLsizei wIn, GLsizei hIn, GLenum typeIn, const void *dataIn, GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluSphere (GLUquadric* quad, GLdouble radius, GLint slices, GLint stacks) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessBeginContour (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessBeginPolygon (GLUtesselator* tess, GLvoid* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessCallback (GLUtesselator* tess, GLenum which, GLvoid (*CallBackFunc)()) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessEndContour (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessEndPolygon (GLUtesselator* tess) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessNormal (GLUtesselator* tess, GLdouble valueX, GLdouble valueY, GLdouble valueZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessProperty (GLUtesselator* tess, GLenum which, GLdouble data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern void gluTessVertex (GLUtesselator* tess, GLdouble *location, GLvoid* data) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern GLint gluUnProject (GLdouble winX, GLdouble winY, GLdouble winZ, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble* objX, GLdouble* objY, GLdouble* objZ) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9,message="" "\"Use GLKMathUnproject\"" "")));
extern GLint gluUnProject4 (GLdouble winX, GLdouble winY, GLdouble winZ, GLdouble clipW, const GLdouble *model, const GLdouble *proj, const GLint *view, GLdouble nearPlane, GLdouble farPlane, GLdouble* objX, GLdouble* objY, GLdouble* objZ, GLdouble* objW) __attribute__((availability(macosx,introduced=10.2,deprecated=10.9,message="" "\"Use GLKMathUnproject\"" "")));


}
# 1178 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h" 2
# 1231 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
typedef void ( * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const GLvoid *pixels);
# 1356 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const GLvoid *data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, GLvoid *img);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void ( * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);
# 1499 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void ( * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void ( * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void ( * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const GLvoid **indices, GLsizei drawcount);
typedef void ( * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void ( * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void ( * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void ( * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void ( * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void ( * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void ( * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);
# 1655 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void ( * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const GLvoid* data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid* data);
typedef void ( * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYPROC) (GLenum target);
typedef void ( * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, GLvoid** params);
typedef void ( * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLvoid* data);
typedef void ( * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean ( * PFNGLISQUERYPROC) (GLuint id);
typedef GLvoid* ( * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERPROC) (GLenum target);
# 1792 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum, GLenum);
typedef void ( * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint ( * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint ( * PFNGLCREATESHADERPROC) (GLenum type);
typedef void ( * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void ( * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint);
typedef void ( * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint);
typedef void ( * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void ( * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint ( * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void ( * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void ( * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void ( * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint, GLenum, GLvoid**);
typedef void ( * PFNGLGETVERTEXATTRIBDVPROC) (GLuint, GLenum, GLdouble*);
typedef void ( * PFNGLGETVERTEXATTRIBFVPROC) (GLuint, GLenum, GLfloat*);
typedef void ( * PFNGLGETVERTEXATTRIBIVPROC) (GLuint, GLenum, GLint*);
typedef GLboolean ( * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean ( * PFNGLISSHADERPROC) (GLuint shader);
typedef void ( * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar** strings, const GLint* lengths);
typedef void ( * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILMASKSEPARATEPROC) (GLenum, GLuint);
typedef void ( * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void ( * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void ( * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer);
# 2013 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void ( * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
# 2144 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint, GLenum);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum);
typedef void ( * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint, GLuint, const GLchar*);
typedef void ( * PFNGLCLAMPCOLORPROC) (GLenum, GLenum);
typedef void ( * PFNGLCLEARBUFFERFIPROC) (GLenum, GLint, GLfloat, GLint);
typedef void ( * PFNGLCLEARBUFFERFVPROC) (GLenum, GLint, const GLfloat*);
typedef void ( * PFNGLCLEARBUFFERIVPROC) (GLenum, GLint, const GLint*);
typedef void ( * PFNGLCLEARBUFFERUIVPROC) (GLenum, GLint, const GLuint*);
typedef void ( * PFNGLCOLORMASKIPROC) (GLuint, GLboolean, GLboolean, GLboolean, GLboolean);
typedef void ( * PFNGLDISABLEIPROC) (GLenum, GLuint);
typedef void ( * PFNGLENABLEIPROC) (GLenum, GLuint);
typedef void ( * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLGETBOOLEANI_VPROC) (GLenum, GLuint, GLboolean*);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONPROC) (GLuint, const GLchar*);
typedef const GLubyte* ( * PFNGLGETSTRINGIPROC) (GLenum, GLuint);
typedef void ( * PFNGLGETTEXPARAMETERIIVPROC) (GLenum, GLenum, GLint*);
typedef void ( * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum, GLenum, GLuint*);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint, GLuint, GLsizei, GLsizei *, GLsizei *, GLenum *, GLchar *);
typedef void ( * PFNGLGETUNIFORMUIVPROC) (GLuint, GLint, GLuint*);
typedef void ( * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint, GLenum, GLint*);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint, GLenum, GLuint*);
typedef GLboolean ( * PFNGLISENABLEDIPROC) (GLenum, GLuint);
typedef void ( * PFNGLTEXPARAMETERIIVPROC) (GLenum, GLenum, const GLint*);
typedef void ( * PFNGLTEXPARAMETERIUIVPROC) (GLenum, GLenum, const GLuint*);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint, GLsizei, const GLchar **, GLenum);
typedef void ( * PFNGLUNIFORM1UIPROC) (GLint, GLuint);
typedef void ( * PFNGLUNIFORM1UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLUNIFORM2UIPROC) (GLint, GLuint, GLuint);
typedef void ( * PFNGLUNIFORM2UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLUNIFORM3UIPROC) (GLint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLUNIFORM3UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLUNIFORM4UIPROC) (GLint, GLuint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLUNIFORM4UIVPROC) (GLint, GLsizei, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI1IPROC) (GLuint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI1IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI1UIPROC) (GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI2IPROC) (GLuint, GLint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI2IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI2UIPROC) (GLuint, GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI3IPROC) (GLuint, GLint, GLint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI3IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI3UIPROC) (GLuint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI4BVPROC) (GLuint, const GLbyte*);
typedef void ( * PFNGLVERTEXATTRIBI4IPROC) (GLuint, GLint, GLint, GLint, GLint);
typedef void ( * PFNGLVERTEXATTRIBI4IVPROC) (GLuint, const GLint*);
typedef void ( * PFNGLVERTEXATTRIBI4SVPROC) (GLuint, const GLshort*);
typedef void ( * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint, const GLubyte*);
typedef void ( * PFNGLVERTEXATTRIBI4UIPROC) (GLuint, GLuint, GLuint, GLuint, GLuint);
typedef void ( * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint, const GLuint*);
typedef void ( * PFNGLVERTEXATTRIBI4USVPROC) (GLuint, const GLushort*);
typedef void ( * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint, GLint, GLenum, GLsizei, const GLvoid*);
# 2300 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum, GLint, GLsizei, GLsizei);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum, GLsizei, GLenum, const GLvoid*, GLsizei);
typedef void ( * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint);
typedef void ( * PFNGLTEXBUFFERPROC) (GLenum, GLenum, GLuint);
# 2342 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum, GLenum, GLuint, GLint);
typedef void ( * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum, GLenum, GLint64 *);
typedef void ( * PFNGLGETINTEGER64I_VPROC) (GLenum, GLuint, GLint64 *);
# 2367 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);
# 2398 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);
# 2468 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);
# 2529 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, void* userParam);
typedef void ( * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);
# 2562 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void ( * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
# 2581 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void* indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void* indirect, GLsizei primcount, GLsizei stride);
# 2602 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void ( * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean ( * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);
# 2627 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void ( * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void ( * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void ( * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void* data);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void ( * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void ( * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void ( * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void ( * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);
# 2686 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);
# 2724 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);
# 2772 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void ( * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);
# 2822 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void* pointer);
typedef void ( * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);
# 2846 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void ( * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean ( * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean ( * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);
# 2900 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);
# 2922 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum ( * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
# 2993 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, GLvoid **params);
typedef void ( * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, GLvoid *pointer);
# 3021 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);
# 3049 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void* pointer);
typedef void ( * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void* pointer);
# 3077 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean ( * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void ( * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void ( * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);
# 3130 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void ( * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void ( * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void ( * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const GLvoid*binary, GLsizei length);
# 3183 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLuint baseinstance);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);
# 3205 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint ( * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);
# 3223 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync ( * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);
# 3239 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const GLvoid* data);
typedef void ( * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid* data);
typedef void ( * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const GLvoid* data);
typedef void ( * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const GLvoid* data);
# 3264 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);
# 3323 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void ( * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);
# 3350 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);
# 3363 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);
# 3399 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, void* userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
# 3477 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);
# 3490 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void ( * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void ( * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void ( * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);
# 3509 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, void* indices, GLint basevertex);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount, GLint basevertex);
typedef void ( * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, void* indices, GLint basevertex);
typedef void ( * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei* count, GLenum type, GLvoid**indices, GLsizei primcount, GLint *basevertex);
# 3531 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void* indirect);
typedef void ( * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void* indirect);
# 3650 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);
# 3744 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void ( * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 3826 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);
# 3850 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, GLvoid*binary);
typedef void ( * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void* binary, GLsizei length);
typedef void ( * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);
# 3896 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void ( * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void ( * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
# 4043 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const GLvoid *data);
typedef void ( * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *table);
typedef void ( * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, GLvoid *table);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLvoid *values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, GLvoid *values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, GLvoid *row, GLvoid *column, GLvoid *span);
typedef void ( * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void ( * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *row, const GLvoid *column);
# 4120 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void ( * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);
# 4139 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);
# 4265 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);
# 4278 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void ( * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void ( * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void ( * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);
# 4319 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef GLvoid * ( * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);
# 4345 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void ( * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void ( * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void ( * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void ( * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);
# 4366 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void* indirect, GLsizei primcount, GLsizei stride);
typedef void ( * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void* indirect, GLsizei primcount, GLsizei stride);
# 4391 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);
# 4440 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void ( * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void ( * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void ( * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void ( * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void ( * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void ( * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void ( * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void ( * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void ( * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void ( * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void ( * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void ( * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void ( * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void ( * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void ( * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void ( * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void ( * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void ( * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void ( * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void ( * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void ( * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);
# 4525 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void ( * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISQUERYARBPROC) (GLuint id);
# 4582 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);
# 4657 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint ( * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint ( * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void ( * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);
# 4685 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);
# 4715 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLenum ( * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void ( * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void ( * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void ( * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void ( * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void ( * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void ( * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void ( * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void ( * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void ( * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void ( * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void ( * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, GLvoid*column, GLvoid*span);
typedef void ( * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void ( * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void ( * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void ( * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void ( * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void ( * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
# 4787 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);
# 4802 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void ( * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void ( * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void ( * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void ( * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void ( * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void ( * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void ( * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void ( * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
# 4862 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void ( * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar ** strings);
typedef void ( * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void ( * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void ( * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void ( * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void ( * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void ( * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void ( * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void ( * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void ( * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void ( * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void ( * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void ( * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
# 5023 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);
# 5110 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void ( * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);
# 5169 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void ( * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void ( * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB ( * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB ( * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void ( * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void ( * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void ( * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void ( * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB ( * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void ( * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void ( * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint ( * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void ( * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void ( * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void ( * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void ( * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void ( * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void ( * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void ( * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);
# 5296 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);
# 5319 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void ( * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void ( * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint ( * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint ( * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void ( * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void ( * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);
# 5379 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar ** path, const GLint *length);
typedef void ( * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void ( * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean ( * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void ( * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);
# 5462 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLenum ( * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void ( * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync ( * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void ( * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void ( * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean ( * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void ( * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
# 5520 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void ( * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);
# 5552 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 5578 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
# 5605 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, void* img);
# 5835 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 5944 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void ( * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void ( * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
# 5967 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void ( * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
# 6007 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);
# 6023 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void ( * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);
# 6045 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);
# 6073 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void ( * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
# 6092 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);
# 6112 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void ( * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
# 6165 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void ( * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void ( * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void ( * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void ( * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint ( * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void ( * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar** uniformNames, GLuint* uniformIndices);
typedef void ( * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);
# 6209 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void ( * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void ( * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean ( * PFNGLISVERTEXARRAYPROC) (GLuint array);
# 6235 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
# 6274 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void ( * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void ( * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
# 6340 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void ( * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, GLvoid *pointer);
typedef void ( * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void ( * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void ( * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void ( * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void ( * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void ( * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void ( * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void ( * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);
# 6403 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void ( * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void ( * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const GLvoid* data, GLenum usage);
typedef void ( * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const GLvoid* data);
typedef void ( * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void ( * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void ( * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, GLvoid** params);
typedef void ( * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, GLvoid* data);
typedef GLboolean ( * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef GLvoid * ( * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean ( * PFNGLUNMAPBUFFERARBPROC) (GLenum target);
# 6519 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void ( * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void ( * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void ( * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void* string);
typedef void ( * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, GLvoid** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void* string);
typedef void ( * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void ( * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void ( * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void ( * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);
# 6662 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void ( * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint ( * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
# 6682 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void ( * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void ( * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void ( * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void ( * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void ( * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void ( * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void ( * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void ( * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void ( * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void ( * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);
# 6783 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void ( * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void ( * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void ( * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void ( * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void ( * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void ( * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void ( * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void ( * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void ( * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);
# 6814 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);
# 6928 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);
# 6945 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void ( * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void ( * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void* pointer);
# 6971 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void ( * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void ( * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
# 7045 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void ( * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void ( * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void ( * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void ( * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint ( * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void ( * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void ( * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void ( * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);
# 7084 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLvoid * ( * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);
# 7122 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);
# 7142 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void ( * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
# 7244 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void ( * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void ( * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint ( * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void* pointer, GLenum usage);
typedef void ( * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void* pointer, GLenum preserve);
typedef void ( * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
# 7279 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);
# 7307 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void ( * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void ( * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void ( * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void ( * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void ( * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void ( * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void ( * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void ( * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void ( * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void ( * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void ( * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void ( * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);
# 7464 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLint ( * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr ( * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void ( * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);
# 7487 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
# 7503 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);
# 7521 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
# 7548 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);
# 7598 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void* data);
typedef void ( * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
# 7616 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void ( * PFNGLUNLOCKARRAYSEXTPROC) (void);
# 7652 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* image);
typedef void ( * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* image);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void* image);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void* row, void* column, void* span);
typedef void ( * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* row, const void* column);
# 7704 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, void* pointer);
typedef void ( * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, void* pointer);
# 7719 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
# 7744 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void ( * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);
# 7759 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void ( * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void ( * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);
# 7779 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);
# 7796 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum ( * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void ( * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data);
typedef void ( * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void ( * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void ( * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void ( * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void ( * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void ( * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void ( * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void ( * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void ( * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, void* img);
typedef void ( * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, void* img);
typedef void ( * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void ( * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void ( * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void* data);
typedef void ( * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void ( * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void ( * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void* string);
typedef void ( * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void ( * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, GLvoid** params);
typedef void ( * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, GLvoid** params);
typedef void ( * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void* pixels);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLvoid** param);
typedef void ( * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, GLvoid** param);
typedef GLvoid * ( * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef GLvoid * ( * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void ( * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void ( * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void ( * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void ( * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void ( * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void* pointer);
typedef void ( * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void ( * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void* data, GLenum usage);
typedef void ( * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void* data);
typedef void ( * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void ( * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void ( * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void ( * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void* string);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void ( * PFNGLPROGRAMUNIFORM1DEXTPROC) (GLuint program, GLint location, GLdouble x);
typedef void ( * PFNGLPROGRAMUNIFORM1DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void ( * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void ( * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void ( * PFNGLPROGRAMUNIFORM2DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void ( * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLPROGRAMUNIFORM3DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void ( * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4DEXTPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMUNIFORM4DVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void ( * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value);
typedef void ( * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void ( * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void ( * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void ( * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void ( * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void ( * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void ( * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void ( * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void ( * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void ( * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
typedef GLboolean ( * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void ( * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
# 8267 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void ( * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void ( * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void ( * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean ( * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);
# 8290 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void ( * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices, GLsizei primcount);
# 8308 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const GLvoid *indices);
# 8330 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const GLvoid *pointer);
typedef void ( * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void ( * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void ( * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void ( * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);
# 8366 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);
# 8418 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
# 8435 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
# 8512 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void ( * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum ( * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void ( * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void ( * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void ( * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void ( * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void ( * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void ( * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void ( * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void ( * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean ( * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void ( * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
# 8590 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void ( * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void ( * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);
# 8607 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
# 8649 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint ( * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void ( * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void ( * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void ( * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void ( * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void ( * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void ( * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void ( * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void ( * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void ( * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void ( * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void ( * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void ( * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void ( * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void ( * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void ( * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void ( * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void ( * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void ( * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 8742 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void* values);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void* values);
typedef void ( * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void ( * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void ( * PFNGLRESETMINMAXEXTPROC) (GLenum target);
# 8782 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);
# 8795 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);
# 8827 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void ( * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void ( * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);
# 8853 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void ( * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const GLvoid **indices, GLsizei primcount);
# 8886 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);
# 8965 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void* data);
typedef void ( * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void* data);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
# 9008 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
# 9045 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);
# 9064 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);
# 9082 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);
# 9106 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINSCENEEXTPROC) (void);
typedef void ( * PFNGLENDSCENEEXTPROC) (void);
# 9129 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void ( * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void ( * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void ( * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void ( * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void ( * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void ( * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void ( * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void ( * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void ( * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void ( * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void ( * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void ( * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void ( * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void ( * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
# 9176 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint ( * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void ( * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);
# 9262 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void ( * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);
# 9312 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);
# 9337 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels);
# 9416 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels);
# 9438 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
# 9457 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);
# 9687 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void ( * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void ( * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void ( * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void ( * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void ( * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);
# 9742 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLboolean ( * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void ( * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void ( * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void ( * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean ( * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void ( * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);
# 9768 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);
# 9899 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void ( * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);
# 9930 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar ** varyings, GLenum bufferMode);
# 9989 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void ( * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer);
typedef void ( * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void ( * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void ( * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void* pointer);
typedef void ( * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void* pointer);
typedef void ( * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer);
typedef void ( * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void* pointer);
# 10040 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void ( * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
# 10184 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint ( * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint ( * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint ( * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint ( * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint ( * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void ( * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void ( * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void ( * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void ( * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint ( * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint ( * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void ( * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void ( * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void ( * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void ( * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, GLvoid **data);
typedef void ( * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean ( * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void ( * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, GLvoid *addr);
typedef void ( * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, GLvoid *addr);
typedef void ( * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void ( * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void ( * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void ( * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void ( * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, GLvoid *addr);
typedef void ( * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void ( * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void ( * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void ( * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void ( * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void ( * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void ( * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void ( * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void ( * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
# 10293 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, void* pointer);
typedef void ( * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void ( * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);
# 10312 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLsync ( * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);
# 10325 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAMETERMINATORGREMEDYPROC) (void);
# 10338 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void* string);
# 10360 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void ( * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
# 10415 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void ( * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const GLvoid * const *indices, GLsizei primcount, GLint modestride);
# 10481 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void ( * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
typedef void ( * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const GLvoid ** pointer, GLint ptrstride);
# 10543 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void ( * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void ( * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
# 10562 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void ( * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);
# 10618 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, GLvoid* userParam);

typedef void ( * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, void* userParam);
typedef void ( * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void ( * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint ( * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufsize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void ( * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLGETOBJECTPTRLABELPROC) (void* ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void ( * PFNGLGETPOINTERVPROC) (GLenum pname, void** params);
typedef void ( * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void ( * PFNGLOBJECTPTRLABELPROC) (void* ptr, GLsizei length, const GLchar* label);
typedef void ( * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);
# 10694 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLuint ( * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void ( * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint ( * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void ( * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);
# 10742 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLRESIZEBUFFERSMESAPROC) (void);
# 10755 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void ( * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void ( * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void ( * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void ( * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void ( * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void ( * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void ( * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void ( * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void ( * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void ( * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);
# 10842 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLuint64 ( * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 ( * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 ( * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean ( * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean ( * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void ( * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void ( * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void ( * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void ( * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);
# 10893 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void ( * PFNGLENDCONDITIONALRENDERNVPROC) (void);
# 10920 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);
# 10938 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void ( * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void ( * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);
# 11006 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void ( * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void* points);
typedef void ( * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void* points);
typedef void ( * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);
# 11046 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void ( * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void ( * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);
# 11067 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void ( * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void ( * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISFENCENVPROC) (GLuint fence);
typedef void ( * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean ( * PFNGLTESTFENCENVPROC) (GLuint fence);
# 11137 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void ( * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);
# 11198 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
# 11215 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);
# 11246 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
# 11335 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void ( * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void ( * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void ( * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void ( * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void ( * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void ( * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 11416 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef unsigned short GLhalf;

typedef void ( * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void ( * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void ( * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void ( * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void ( * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void ( * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void ( * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void ( * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void ( * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void ( * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void ( * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void ( * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void ( * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void ( * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void ( * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void ( * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void ( * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void ( * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void ( * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);
# 11561 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void ( * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void ( * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean ( * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);
# 11604 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void ( * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);
# 11761 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void ( * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void ( * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLCOVERSTROKEPATHNVPROC) (GLuint name, GLenum coverMode);
typedef void ( * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint ( * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void ( * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void ( * PFNGLGETPATHCOMMANDSNVPROC) (GLuint name, GLubyte* commands);
typedef void ( * PFNGLGETPATHCOORDSNVPROC) (GLuint name, GLfloat* coords);
typedef void ( * PFNGLGETPATHDASHARRAYNVPROC) (GLuint name, GLfloat* dashArray);
typedef GLfloat ( * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void ( * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void ( * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void ( * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint name, GLenum param, GLfloat* value);
typedef void ( * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint name, GLenum param, GLint* value);
typedef void ( * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void ( * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void ( * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void ( * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean ( * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean ( * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean ( * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void ( * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void ( * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords);
typedef void ( * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void ( * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void ( * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void ( * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef void ( * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const GLvoid*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void ( * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void ( * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void ( * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void ( * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void ( * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void ( * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void ( * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void* pathString);
typedef void ( * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const GLvoid*coords);
typedef void ( * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void ( * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean ( * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void ( * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void ( * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void ( * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void ( * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void ( * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);
# 11877 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void ( * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, void* pointer);
# 11896 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
# 11918 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void ( * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void ( * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);
# 11944 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void ( * PFNGLPRIMITIVERESTARTNVPROC) (void);
# 12011 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void ( * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void ( * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);
# 12050 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);
# 12078 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void ( * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean ( * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean ( * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void ( * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void ( * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void ( * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void ( * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void ( * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void ( * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void ( * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
# 12155 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREBARRIERNVPROC) (void);
# 12206 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void ( * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
# 12417 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void ( * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void ( * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void ( * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void ( * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void ( * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint ( * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void ( * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void ( * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);
# 12455 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void ( * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean ( * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void ( * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void ( * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);
# 12485 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLintptr GLvdpauSurfaceNV;

typedef void ( * PFNGLVDPAUFININVPROC) (void);
typedef void ( * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void ( * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const GLvoid*getProcAddress);
typedef void ( * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void ( * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV ( * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void ( * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void ( * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void ( * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);
# 12524 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void ( * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, void* pointer);
# 12553 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void ( * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void ( * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void ( * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void ( * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void ( * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void ( * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void ( * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
# 12628 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void ( * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void ( * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void ( * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void ( * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void ( * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void ( * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
# 12747 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLboolean ( * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void ( * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void ( * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void ( * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void ( * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void ( * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void ( * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, GLvoid** pointer);
typedef void ( * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean ( * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void ( * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void ( * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void ( * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void ( * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void ( * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void ( * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void ( * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void ( * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void ( * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void ( * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void ( * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void ( * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void ( * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void ( * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void ( * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void ( * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void ( * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void ( * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);
typedef void ( * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void ( * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void ( * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void ( * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);
# 12968 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void ( * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void ( * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void ( * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum ( * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
# 13046 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCLEARDEPTHFOESPROC) (GLclampd depth);
typedef void ( * PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat* equation);
typedef void ( * PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
typedef void ( * PFNGLFRUSTUMFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void ( * PFNGLGETCLIPPLANEFOESPROC) (GLenum plane, GLfloat* equation);
typedef void ( * PFNGLORTHOFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
# 13171 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef const GLchar* ( * PFNGLERRORSTRINGREGALPROC) (GLenum error);
# 13184 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef GLboolean ( * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean ( * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);
# 13265 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
# 13280 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void ( * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);
# 13324 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void ( * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);
# 13366 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void ( * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
# 13381 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void* pixels);
typedef void ( * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void* pixels);
# 13418 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void ( * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);
# 13458 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void ( * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint ( * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint ( * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean ( * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint ( * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);
# 13554 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFLUSHRASTERSGIXPROC) (void);
# 13583 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);
# 13596 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void ( * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void ( * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void ( * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void ( * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void ( * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void ( * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void ( * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* data);
typedef void ( * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* data);
# 13641 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);
# 13683 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);
# 13705 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);
# 13758 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void ( * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void ( * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void ( * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);
# 13777 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);
# 13955 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void ( * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void ( * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void* table);
typedef void ( * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void ( * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void ( * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void* table);
# 13995 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLFINISHTEXTURESUNXPROC) (void);
# 14022 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void ( * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void ( * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void ( * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);
# 14061 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid* pixels);
# 14103 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void* pointer);
typedef void ( * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void ( * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void ( * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void ( * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void ( * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void ( * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);
# 14128 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void ( * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void ( * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void ( * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void ( * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
# 14242 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
typedef void ( * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);
# 14269 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
extern PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern PFNGLBLENDCOLORPROC __glewBlendColor;
extern PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern PFNGLFOGCOORDDPROC __glewFogCoordd;
extern PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern PFNGLFOGCOORDFPROC __glewFogCoordf;
extern PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern PFNGLBEGINQUERYPROC __glewBeginQuery;
extern PFNGLBINDBUFFERPROC __glewBindBuffer;
extern PFNGLBUFFERDATAPROC __glewBufferData;
extern PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern PFNGLENDQUERYPROC __glewEndQuery;
extern PFNGLGENBUFFERSPROC __glewGenBuffers;
extern PFNGLGENQUERIESPROC __glewGenQueries;
extern PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern PFNGLISBUFFERPROC __glewIsBuffer;
extern PFNGLISQUERYPROC __glewIsQuery;
extern PFNGLMAPBUFFERPROC __glewMapBuffer;
extern PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern PFNGLATTACHSHADERPROC __glewAttachShader;
extern PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern PFNGLCOMPILESHADERPROC __glewCompileShader;
extern PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern PFNGLCREATESHADERPROC __glewCreateShader;
extern PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern PFNGLDELETESHADERPROC __glewDeleteShader;
extern PFNGLDETACHSHADERPROC __glewDetachShader;
extern PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern PFNGLISPROGRAMPROC __glewIsProgram;
extern PFNGLISSHADERPROC __glewIsShader;
extern PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern PFNGLSHADERSOURCEPROC __glewShaderSource;
extern PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern PFNGLUNIFORM1FPROC __glewUniform1f;
extern PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern PFNGLUNIFORM1IPROC __glewUniform1i;
extern PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern PFNGLUNIFORM2FPROC __glewUniform2f;
extern PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern PFNGLUNIFORM2IPROC __glewUniform2i;
extern PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern PFNGLUNIFORM3FPROC __glewUniform3f;
extern PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern PFNGLUNIFORM3IPROC __glewUniform3i;
extern PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern PFNGLUNIFORM4FPROC __glewUniform4f;
extern PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern PFNGLUNIFORM4IPROC __glewUniform4i;
extern PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern PFNGLUSEPROGRAMPROC __glewUseProgram;
extern PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern PFNGLCLAMPCOLORPROC __glewClampColor;
extern PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern PFNGLCOLORMASKIPROC __glewColorMaski;
extern PFNGLDISABLEIPROC __glewDisablei;
extern PFNGLENABLEIPROC __glewEnablei;
extern PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern PFNGLGETSTRINGIPROC __glewGetStringi;
extern PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern PFNGLISENABLEDIPROC __glewIsEnabledi;
extern PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern PFNGLTEXBUFFERPROC __glewTexBuffer;

extern PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern PFNGLSHADERBINARYPROC __glewShaderBinary;

extern PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern PFNGLUNIFORM1DPROC __glewUniform1d;
extern PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern PFNGLUNIFORM2DPROC __glewUniform2d;
extern PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern PFNGLUNIFORM3DPROC __glewUniform3d;
extern PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern PFNGLUNIFORM4DPROC __glewUniform4d;
extern PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern PFNGLCOLORTABLEPROC __glewColorTable;
extern PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern PFNGLGETMINMAXPROC __glewGetMinmax;
extern PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern PFNGLHISTOGRAMPROC __glewHistogram;
extern PFNGLMINMAXPROC __glewMinmax;
extern PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern PFNGLRESETMINMAXPROC __glewResetMinmax;
extern PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern PFNGLISQUERYARBPROC __glewIsQueryARB;

extern PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern PFNGLBINDSAMPLERPROC __glewBindSampler;
extern PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern PFNGLISSAMPLERPROC __glewIsSampler;
extern PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern PFNGLDELETESYNCPROC __glewDeleteSync;
extern PFNGLFENCESYNCPROC __glewFenceSync;
extern PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern PFNGLGETSYNCIVPROC __glewGetSynciv;
extern PFNGLISSYNCPROC __glewIsSync;
extern PFNGLWAITSYNCPROC __glewWaitSync;

extern PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;
extern PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern PFNGLTEXTUREVIEWPROC __glewTextureView;

extern PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern PFNGLCOLORP3UIPROC __glewColorP3ui;
extern PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern PFNGLCOLORP4UIPROC __glewColorP4ui;
extern PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern PFNGLPROGRAMUNIFORM1DEXTPROC __glewProgramUniform1dEXT;
extern PFNGLPROGRAMUNIFORM1DVEXTPROC __glewProgramUniform1dvEXT;
extern PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern PFNGLPROGRAMUNIFORM2DEXTPROC __glewProgramUniform2dEXT;
extern PFNGLPROGRAMUNIFORM2DVEXTPROC __glewProgramUniform2dvEXT;
extern PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern PFNGLPROGRAMUNIFORM3DEXTPROC __glewProgramUniform3dEXT;
extern PFNGLPROGRAMUNIFORM3DVEXTPROC __glewProgramUniform3dvEXT;
extern PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern PFNGLPROGRAMUNIFORM4DEXTPROC __glewProgramUniform4dEXT;
extern PFNGLPROGRAMUNIFORM4DVEXTPROC __glewProgramUniform4dvEXT;
extern PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2DVEXTPROC __glewProgramUniformMatrix2dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X3DVEXTPROC __glewProgramUniformMatrix2x3dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X4DVEXTPROC __glewProgramUniformMatrix2x4dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3DVEXTPROC __glewProgramUniformMatrix3dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X2DVEXTPROC __glewProgramUniformMatrix3x2dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X4DVEXTPROC __glewProgramUniformMatrix3x4dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4DVEXTPROC __glewProgramUniformMatrix4dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X2DVEXTPROC __glewProgramUniformMatrix4x2dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X3DVEXTPROC __glewProgramUniformMatrix4x3dvEXT;
extern PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern PFNGLGETPOINTERVPROC __glewGetPointerv;
extern PFNGLOBJECTLABELPROC __glewObjectLabel;
extern PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern PFNGLISFENCENVPROC __glewIsFenceNV;
extern PFNGLSETFENCENVPROC __glewSetFenceNV;
extern PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern PFNGLISPATHNVPROC __glewIsPathNV;
extern PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
extern PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
extern PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
extern PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
extern PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
extern PFNGLORTHOFOESPROC __glewOrthofOES;

extern PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;






extern GLboolean __GLEW_VERSION_1_1;
extern GLboolean __GLEW_VERSION_1_2;
extern GLboolean __GLEW_VERSION_1_2_1;
extern GLboolean __GLEW_VERSION_1_3;
extern GLboolean __GLEW_VERSION_1_4;
extern GLboolean __GLEW_VERSION_1_5;
extern GLboolean __GLEW_VERSION_2_0;
extern GLboolean __GLEW_VERSION_2_1;
extern GLboolean __GLEW_VERSION_3_0;
extern GLboolean __GLEW_VERSION_3_1;
extern GLboolean __GLEW_VERSION_3_2;
extern GLboolean __GLEW_VERSION_3_3;
extern GLboolean __GLEW_VERSION_4_0;
extern GLboolean __GLEW_VERSION_4_1;
extern GLboolean __GLEW_VERSION_4_2;
extern GLboolean __GLEW_VERSION_4_3;
extern GLboolean __GLEW_3DFX_multisample;
extern GLboolean __GLEW_3DFX_tbuffer;
extern GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern GLboolean __GLEW_AMD_blend_minmax_factor;
extern GLboolean __GLEW_AMD_conservative_depth;
extern GLboolean __GLEW_AMD_debug_output;
extern GLboolean __GLEW_AMD_depth_clamp_separate;
extern GLboolean __GLEW_AMD_draw_buffers_blend;
extern GLboolean __GLEW_AMD_multi_draw_indirect;
extern GLboolean __GLEW_AMD_name_gen_delete;
extern GLboolean __GLEW_AMD_performance_monitor;
extern GLboolean __GLEW_AMD_pinned_memory;
extern GLboolean __GLEW_AMD_query_buffer_object;
extern GLboolean __GLEW_AMD_sample_positions;
extern GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern GLboolean __GLEW_AMD_shader_stencil_export;
extern GLboolean __GLEW_AMD_stencil_operation_extended;
extern GLboolean __GLEW_AMD_texture_texture4;
extern GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern GLboolean __GLEW_AMD_vertex_shader_layer;
extern GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern GLboolean __GLEW_APPLE_aux_depth_stencil;
extern GLboolean __GLEW_APPLE_client_storage;
extern GLboolean __GLEW_APPLE_element_array;
extern GLboolean __GLEW_APPLE_fence;
extern GLboolean __GLEW_APPLE_float_pixels;
extern GLboolean __GLEW_APPLE_flush_buffer_range;
extern GLboolean __GLEW_APPLE_object_purgeable;
extern GLboolean __GLEW_APPLE_pixel_buffer;
extern GLboolean __GLEW_APPLE_rgb_422;
extern GLboolean __GLEW_APPLE_row_bytes;
extern GLboolean __GLEW_APPLE_specular_vector;
extern GLboolean __GLEW_APPLE_texture_range;
extern GLboolean __GLEW_APPLE_transform_hint;
extern GLboolean __GLEW_APPLE_vertex_array_object;
extern GLboolean __GLEW_APPLE_vertex_array_range;
extern GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern GLboolean __GLEW_APPLE_ycbcr_422;
extern GLboolean __GLEW_ARB_ES2_compatibility;
extern GLboolean __GLEW_ARB_ES3_compatibility;
extern GLboolean __GLEW_ARB_arrays_of_arrays;
extern GLboolean __GLEW_ARB_base_instance;
extern GLboolean __GLEW_ARB_blend_func_extended;
extern GLboolean __GLEW_ARB_cl_event;
extern GLboolean __GLEW_ARB_clear_buffer_object;
extern GLboolean __GLEW_ARB_color_buffer_float;
extern GLboolean __GLEW_ARB_compatibility;
extern GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern GLboolean __GLEW_ARB_compute_shader;
extern GLboolean __GLEW_ARB_conservative_depth;
extern GLboolean __GLEW_ARB_copy_buffer;
extern GLboolean __GLEW_ARB_copy_image;
extern GLboolean __GLEW_ARB_debug_output;
extern GLboolean __GLEW_ARB_depth_buffer_float;
extern GLboolean __GLEW_ARB_depth_clamp;
extern GLboolean __GLEW_ARB_depth_texture;
extern GLboolean __GLEW_ARB_draw_buffers;
extern GLboolean __GLEW_ARB_draw_buffers_blend;
extern GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern GLboolean __GLEW_ARB_draw_indirect;
extern GLboolean __GLEW_ARB_draw_instanced;
extern GLboolean __GLEW_ARB_explicit_attrib_location;
extern GLboolean __GLEW_ARB_explicit_uniform_location;
extern GLboolean __GLEW_ARB_fragment_coord_conventions;
extern GLboolean __GLEW_ARB_fragment_layer_viewport;
extern GLboolean __GLEW_ARB_fragment_program;
extern GLboolean __GLEW_ARB_fragment_program_shadow;
extern GLboolean __GLEW_ARB_fragment_shader;
extern GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern GLboolean __GLEW_ARB_framebuffer_object;
extern GLboolean __GLEW_ARB_framebuffer_sRGB;
extern GLboolean __GLEW_ARB_geometry_shader4;
extern GLboolean __GLEW_ARB_get_program_binary;
extern GLboolean __GLEW_ARB_gpu_shader5;
extern GLboolean __GLEW_ARB_gpu_shader_fp64;
extern GLboolean __GLEW_ARB_half_float_pixel;
extern GLboolean __GLEW_ARB_half_float_vertex;
extern GLboolean __GLEW_ARB_imaging;
extern GLboolean __GLEW_ARB_instanced_arrays;
extern GLboolean __GLEW_ARB_internalformat_query;
extern GLboolean __GLEW_ARB_internalformat_query2;
extern GLboolean __GLEW_ARB_invalidate_subdata;
extern GLboolean __GLEW_ARB_map_buffer_alignment;
extern GLboolean __GLEW_ARB_map_buffer_range;
extern GLboolean __GLEW_ARB_matrix_palette;
extern GLboolean __GLEW_ARB_multi_draw_indirect;
extern GLboolean __GLEW_ARB_multisample;
extern GLboolean __GLEW_ARB_multitexture;
extern GLboolean __GLEW_ARB_occlusion_query;
extern GLboolean __GLEW_ARB_occlusion_query2;
extern GLboolean __GLEW_ARB_pixel_buffer_object;
extern GLboolean __GLEW_ARB_point_parameters;
extern GLboolean __GLEW_ARB_point_sprite;
extern GLboolean __GLEW_ARB_program_interface_query;
extern GLboolean __GLEW_ARB_provoking_vertex;
extern GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern GLboolean __GLEW_ARB_robustness;
extern GLboolean __GLEW_ARB_robustness_application_isolation;
extern GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern GLboolean __GLEW_ARB_sample_shading;
extern GLboolean __GLEW_ARB_sampler_objects;
extern GLboolean __GLEW_ARB_seamless_cube_map;
extern GLboolean __GLEW_ARB_separate_shader_objects;
extern GLboolean __GLEW_ARB_shader_atomic_counters;
extern GLboolean __GLEW_ARB_shader_bit_encoding;
extern GLboolean __GLEW_ARB_shader_image_load_store;
extern GLboolean __GLEW_ARB_shader_image_size;
extern GLboolean __GLEW_ARB_shader_objects;
extern GLboolean __GLEW_ARB_shader_precision;
extern GLboolean __GLEW_ARB_shader_stencil_export;
extern GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern GLboolean __GLEW_ARB_shader_subroutine;
extern GLboolean __GLEW_ARB_shader_texture_lod;
extern GLboolean __GLEW_ARB_shading_language_100;
extern GLboolean __GLEW_ARB_shading_language_420pack;
extern GLboolean __GLEW_ARB_shading_language_include;
extern GLboolean __GLEW_ARB_shading_language_packing;
extern GLboolean __GLEW_ARB_shadow;
extern GLboolean __GLEW_ARB_shadow_ambient;
extern GLboolean __GLEW_ARB_stencil_texturing;
extern GLboolean __GLEW_ARB_sync;
extern GLboolean __GLEW_ARB_tessellation_shader;
extern GLboolean __GLEW_ARB_texture_border_clamp;
extern GLboolean __GLEW_ARB_texture_buffer_object;
extern GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern GLboolean __GLEW_ARB_texture_buffer_range;
extern GLboolean __GLEW_ARB_texture_compression;
extern GLboolean __GLEW_ARB_texture_compression_bptc;
extern GLboolean __GLEW_ARB_texture_compression_rgtc;
extern GLboolean __GLEW_ARB_texture_cube_map;
extern GLboolean __GLEW_ARB_texture_cube_map_array;
extern GLboolean __GLEW_ARB_texture_env_add;
extern GLboolean __GLEW_ARB_texture_env_combine;
extern GLboolean __GLEW_ARB_texture_env_crossbar;
extern GLboolean __GLEW_ARB_texture_env_dot3;
extern GLboolean __GLEW_ARB_texture_float;
extern GLboolean __GLEW_ARB_texture_gather;
extern GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern GLboolean __GLEW_ARB_texture_multisample;
extern GLboolean __GLEW_ARB_texture_non_power_of_two;
extern GLboolean __GLEW_ARB_texture_query_levels;
extern GLboolean __GLEW_ARB_texture_query_lod;
extern GLboolean __GLEW_ARB_texture_rectangle;
extern GLboolean __GLEW_ARB_texture_rg;
extern GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern GLboolean __GLEW_ARB_texture_storage;
extern GLboolean __GLEW_ARB_texture_storage_multisample;
extern GLboolean __GLEW_ARB_texture_swizzle;
extern GLboolean __GLEW_ARB_texture_view;
extern GLboolean __GLEW_ARB_timer_query;
extern GLboolean __GLEW_ARB_transform_feedback2;
extern GLboolean __GLEW_ARB_transform_feedback3;
extern GLboolean __GLEW_ARB_transform_feedback_instanced;
extern GLboolean __GLEW_ARB_transpose_matrix;
extern GLboolean __GLEW_ARB_uniform_buffer_object;
extern GLboolean __GLEW_ARB_vertex_array_bgra;
extern GLboolean __GLEW_ARB_vertex_array_object;
extern GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern GLboolean __GLEW_ARB_vertex_attrib_binding;
extern GLboolean __GLEW_ARB_vertex_blend;
extern GLboolean __GLEW_ARB_vertex_buffer_object;
extern GLboolean __GLEW_ARB_vertex_program;
extern GLboolean __GLEW_ARB_vertex_shader;
extern GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern GLboolean __GLEW_ARB_viewport_array;
extern GLboolean __GLEW_ARB_window_pos;
extern GLboolean __GLEW_ATIX_point_sprites;
extern GLboolean __GLEW_ATIX_texture_env_combine3;
extern GLboolean __GLEW_ATIX_texture_env_route;
extern GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern GLboolean __GLEW_ATI_draw_buffers;
extern GLboolean __GLEW_ATI_element_array;
extern GLboolean __GLEW_ATI_envmap_bumpmap;
extern GLboolean __GLEW_ATI_fragment_shader;
extern GLboolean __GLEW_ATI_map_object_buffer;
extern GLboolean __GLEW_ATI_meminfo;
extern GLboolean __GLEW_ATI_pn_triangles;
extern GLboolean __GLEW_ATI_separate_stencil;
extern GLboolean __GLEW_ATI_shader_texture_lod;
extern GLboolean __GLEW_ATI_text_fragment_shader;
extern GLboolean __GLEW_ATI_texture_compression_3dc;
extern GLboolean __GLEW_ATI_texture_env_combine3;
extern GLboolean __GLEW_ATI_texture_float;
extern GLboolean __GLEW_ATI_texture_mirror_once;
extern GLboolean __GLEW_ATI_vertex_array_object;
extern GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern GLboolean __GLEW_ATI_vertex_streams;
extern GLboolean __GLEW_EXT_422_pixels;
extern GLboolean __GLEW_EXT_Cg_shader;
extern GLboolean __GLEW_EXT_abgr;
extern GLboolean __GLEW_EXT_bgra;
extern GLboolean __GLEW_EXT_bindable_uniform;
extern GLboolean __GLEW_EXT_blend_color;
extern GLboolean __GLEW_EXT_blend_equation_separate;
extern GLboolean __GLEW_EXT_blend_func_separate;
extern GLboolean __GLEW_EXT_blend_logic_op;
extern GLboolean __GLEW_EXT_blend_minmax;
extern GLboolean __GLEW_EXT_blend_subtract;
extern GLboolean __GLEW_EXT_clip_volume_hint;
extern GLboolean __GLEW_EXT_cmyka;
extern GLboolean __GLEW_EXT_color_subtable;
extern GLboolean __GLEW_EXT_compiled_vertex_array;
extern GLboolean __GLEW_EXT_convolution;
extern GLboolean __GLEW_EXT_coordinate_frame;
extern GLboolean __GLEW_EXT_copy_texture;
extern GLboolean __GLEW_EXT_cull_vertex;
extern GLboolean __GLEW_EXT_debug_marker;
extern GLboolean __GLEW_EXT_depth_bounds_test;
extern GLboolean __GLEW_EXT_direct_state_access;
extern GLboolean __GLEW_EXT_draw_buffers2;
extern GLboolean __GLEW_EXT_draw_instanced;
extern GLboolean __GLEW_EXT_draw_range_elements;
extern GLboolean __GLEW_EXT_fog_coord;
extern GLboolean __GLEW_EXT_fragment_lighting;
extern GLboolean __GLEW_EXT_framebuffer_blit;
extern GLboolean __GLEW_EXT_framebuffer_multisample;
extern GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern GLboolean __GLEW_EXT_framebuffer_object;
extern GLboolean __GLEW_EXT_framebuffer_sRGB;
extern GLboolean __GLEW_EXT_geometry_shader4;
extern GLboolean __GLEW_EXT_gpu_program_parameters;
extern GLboolean __GLEW_EXT_gpu_shader4;
extern GLboolean __GLEW_EXT_histogram;
extern GLboolean __GLEW_EXT_index_array_formats;
extern GLboolean __GLEW_EXT_index_func;
extern GLboolean __GLEW_EXT_index_material;
extern GLboolean __GLEW_EXT_index_texture;
extern GLboolean __GLEW_EXT_light_texture;
extern GLboolean __GLEW_EXT_misc_attribute;
extern GLboolean __GLEW_EXT_multi_draw_arrays;
extern GLboolean __GLEW_EXT_multisample;
extern GLboolean __GLEW_EXT_packed_depth_stencil;
extern GLboolean __GLEW_EXT_packed_float;
extern GLboolean __GLEW_EXT_packed_pixels;
extern GLboolean __GLEW_EXT_paletted_texture;
extern GLboolean __GLEW_EXT_pixel_buffer_object;
extern GLboolean __GLEW_EXT_pixel_transform;
extern GLboolean __GLEW_EXT_pixel_transform_color_table;
extern GLboolean __GLEW_EXT_point_parameters;
extern GLboolean __GLEW_EXT_polygon_offset;
extern GLboolean __GLEW_EXT_provoking_vertex;
extern GLboolean __GLEW_EXT_rescale_normal;
extern GLboolean __GLEW_EXT_scene_marker;
extern GLboolean __GLEW_EXT_secondary_color;
extern GLboolean __GLEW_EXT_separate_shader_objects;
extern GLboolean __GLEW_EXT_separate_specular_color;
extern GLboolean __GLEW_EXT_shader_image_load_store;
extern GLboolean __GLEW_EXT_shadow_funcs;
extern GLboolean __GLEW_EXT_shared_texture_palette;
extern GLboolean __GLEW_EXT_stencil_clear_tag;
extern GLboolean __GLEW_EXT_stencil_two_side;
extern GLboolean __GLEW_EXT_stencil_wrap;
extern GLboolean __GLEW_EXT_subtexture;
extern GLboolean __GLEW_EXT_texture;
extern GLboolean __GLEW_EXT_texture3D;
extern GLboolean __GLEW_EXT_texture_array;
extern GLboolean __GLEW_EXT_texture_buffer_object;
extern GLboolean __GLEW_EXT_texture_compression_dxt1;
extern GLboolean __GLEW_EXT_texture_compression_latc;
extern GLboolean __GLEW_EXT_texture_compression_rgtc;
extern GLboolean __GLEW_EXT_texture_compression_s3tc;
extern GLboolean __GLEW_EXT_texture_cube_map;
extern GLboolean __GLEW_EXT_texture_edge_clamp;
extern GLboolean __GLEW_EXT_texture_env;
extern GLboolean __GLEW_EXT_texture_env_add;
extern GLboolean __GLEW_EXT_texture_env_combine;
extern GLboolean __GLEW_EXT_texture_env_dot3;
extern GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern GLboolean __GLEW_EXT_texture_integer;
extern GLboolean __GLEW_EXT_texture_lod_bias;
extern GLboolean __GLEW_EXT_texture_mirror_clamp;
extern GLboolean __GLEW_EXT_texture_object;
extern GLboolean __GLEW_EXT_texture_perturb_normal;
extern GLboolean __GLEW_EXT_texture_rectangle;
extern GLboolean __GLEW_EXT_texture_sRGB;
extern GLboolean __GLEW_EXT_texture_sRGB_decode;
extern GLboolean __GLEW_EXT_texture_shared_exponent;
extern GLboolean __GLEW_EXT_texture_snorm;
extern GLboolean __GLEW_EXT_texture_swizzle;
extern GLboolean __GLEW_EXT_timer_query;
extern GLboolean __GLEW_EXT_transform_feedback;
extern GLboolean __GLEW_EXT_vertex_array;
extern GLboolean __GLEW_EXT_vertex_array_bgra;
extern GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern GLboolean __GLEW_EXT_vertex_shader;
extern GLboolean __GLEW_EXT_vertex_weighting;
extern GLboolean __GLEW_EXT_x11_sync_object;
extern GLboolean __GLEW_GREMEDY_frame_terminator;
extern GLboolean __GLEW_GREMEDY_string_marker;
extern GLboolean __GLEW_HP_convolution_border_modes;
extern GLboolean __GLEW_HP_image_transform;
extern GLboolean __GLEW_HP_occlusion_test;
extern GLboolean __GLEW_HP_texture_lighting;
extern GLboolean __GLEW_IBM_cull_vertex;
extern GLboolean __GLEW_IBM_multimode_draw_arrays;
extern GLboolean __GLEW_IBM_rasterpos_clip;
extern GLboolean __GLEW_IBM_static_data;
extern GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern GLboolean __GLEW_IBM_vertex_array_lists;
extern GLboolean __GLEW_INGR_color_clamp;
extern GLboolean __GLEW_INGR_interlace_read;
extern GLboolean __GLEW_INTEL_parallel_arrays;
extern GLboolean __GLEW_INTEL_texture_scissor;
extern GLboolean __GLEW_KHR_debug;
extern GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern GLboolean __GLEW_KTX_buffer_region;
extern GLboolean __GLEW_MESAX_texture_stack;
extern GLboolean __GLEW_MESA_pack_invert;
extern GLboolean __GLEW_MESA_resize_buffers;
extern GLboolean __GLEW_MESA_window_pos;
extern GLboolean __GLEW_MESA_ycbcr_texture;
extern GLboolean __GLEW_NVX_gpu_memory_info;
extern GLboolean __GLEW_NV_bindless_texture;
extern GLboolean __GLEW_NV_blend_square;
extern GLboolean __GLEW_NV_conditional_render;
extern GLboolean __GLEW_NV_copy_depth_to_color;
extern GLboolean __GLEW_NV_copy_image;
extern GLboolean __GLEW_NV_depth_buffer_float;
extern GLboolean __GLEW_NV_depth_clamp;
extern GLboolean __GLEW_NV_depth_range_unclamped;
extern GLboolean __GLEW_NV_evaluators;
extern GLboolean __GLEW_NV_explicit_multisample;
extern GLboolean __GLEW_NV_fence;
extern GLboolean __GLEW_NV_float_buffer;
extern GLboolean __GLEW_NV_fog_distance;
extern GLboolean __GLEW_NV_fragment_program;
extern GLboolean __GLEW_NV_fragment_program2;
extern GLboolean __GLEW_NV_fragment_program4;
extern GLboolean __GLEW_NV_fragment_program_option;
extern GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern GLboolean __GLEW_NV_geometry_program4;
extern GLboolean __GLEW_NV_geometry_shader4;
extern GLboolean __GLEW_NV_gpu_program4;
extern GLboolean __GLEW_NV_gpu_program5;
extern GLboolean __GLEW_NV_gpu_program_fp64;
extern GLboolean __GLEW_NV_gpu_shader5;
extern GLboolean __GLEW_NV_half_float;
extern GLboolean __GLEW_NV_light_max_exponent;
extern GLboolean __GLEW_NV_multisample_coverage;
extern GLboolean __GLEW_NV_multisample_filter_hint;
extern GLboolean __GLEW_NV_occlusion_query;
extern GLboolean __GLEW_NV_packed_depth_stencil;
extern GLboolean __GLEW_NV_parameter_buffer_object;
extern GLboolean __GLEW_NV_parameter_buffer_object2;
extern GLboolean __GLEW_NV_path_rendering;
extern GLboolean __GLEW_NV_pixel_data_range;
extern GLboolean __GLEW_NV_point_sprite;
extern GLboolean __GLEW_NV_present_video;
extern GLboolean __GLEW_NV_primitive_restart;
extern GLboolean __GLEW_NV_register_combiners;
extern GLboolean __GLEW_NV_register_combiners2;
extern GLboolean __GLEW_NV_shader_atomic_float;
extern GLboolean __GLEW_NV_shader_buffer_load;
extern GLboolean __GLEW_NV_tessellation_program5;
extern GLboolean __GLEW_NV_texgen_emboss;
extern GLboolean __GLEW_NV_texgen_reflection;
extern GLboolean __GLEW_NV_texture_barrier;
extern GLboolean __GLEW_NV_texture_compression_vtc;
extern GLboolean __GLEW_NV_texture_env_combine4;
extern GLboolean __GLEW_NV_texture_expand_normal;
extern GLboolean __GLEW_NV_texture_multisample;
extern GLboolean __GLEW_NV_texture_rectangle;
extern GLboolean __GLEW_NV_texture_shader;
extern GLboolean __GLEW_NV_texture_shader2;
extern GLboolean __GLEW_NV_texture_shader3;
extern GLboolean __GLEW_NV_transform_feedback;
extern GLboolean __GLEW_NV_transform_feedback2;
extern GLboolean __GLEW_NV_vdpau_interop;
extern GLboolean __GLEW_NV_vertex_array_range;
extern GLboolean __GLEW_NV_vertex_array_range2;
extern GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern GLboolean __GLEW_NV_vertex_program;
extern GLboolean __GLEW_NV_vertex_program1_1;
extern GLboolean __GLEW_NV_vertex_program2;
extern GLboolean __GLEW_NV_vertex_program2_option;
extern GLboolean __GLEW_NV_vertex_program3;
extern GLboolean __GLEW_NV_vertex_program4;
extern GLboolean __GLEW_NV_video_capture;
extern GLboolean __GLEW_OES_byte_coordinates;
extern GLboolean __GLEW_OES_compressed_paletted_texture;
extern GLboolean __GLEW_OES_read_format;
extern GLboolean __GLEW_OES_single_precision;
extern GLboolean __GLEW_OML_interlace;
extern GLboolean __GLEW_OML_resample;
extern GLboolean __GLEW_OML_subsample;
extern GLboolean __GLEW_PGI_misc_hints;
extern GLboolean __GLEW_PGI_vertex_hints;
extern GLboolean __GLEW_REGAL_error_string;
extern GLboolean __GLEW_REGAL_extension_query;
extern GLboolean __GLEW_REGAL_log;
extern GLboolean __GLEW_REND_screen_coordinates;
extern GLboolean __GLEW_S3_s3tc;
extern GLboolean __GLEW_SGIS_color_range;
extern GLboolean __GLEW_SGIS_detail_texture;
extern GLboolean __GLEW_SGIS_fog_function;
extern GLboolean __GLEW_SGIS_generate_mipmap;
extern GLboolean __GLEW_SGIS_multisample;
extern GLboolean __GLEW_SGIS_pixel_texture;
extern GLboolean __GLEW_SGIS_point_line_texgen;
extern GLboolean __GLEW_SGIS_sharpen_texture;
extern GLboolean __GLEW_SGIS_texture4D;
extern GLboolean __GLEW_SGIS_texture_border_clamp;
extern GLboolean __GLEW_SGIS_texture_edge_clamp;
extern GLboolean __GLEW_SGIS_texture_filter4;
extern GLboolean __GLEW_SGIS_texture_lod;
extern GLboolean __GLEW_SGIS_texture_select;
extern GLboolean __GLEW_SGIX_async;
extern GLboolean __GLEW_SGIX_async_histogram;
extern GLboolean __GLEW_SGIX_async_pixel;
extern GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern GLboolean __GLEW_SGIX_clipmap;
extern GLboolean __GLEW_SGIX_convolution_accuracy;
extern GLboolean __GLEW_SGIX_depth_texture;
extern GLboolean __GLEW_SGIX_flush_raster;
extern GLboolean __GLEW_SGIX_fog_offset;
extern GLboolean __GLEW_SGIX_fog_texture;
extern GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern GLboolean __GLEW_SGIX_framezoom;
extern GLboolean __GLEW_SGIX_interlace;
extern GLboolean __GLEW_SGIX_ir_instrument1;
extern GLboolean __GLEW_SGIX_list_priority;
extern GLboolean __GLEW_SGIX_pixel_texture;
extern GLboolean __GLEW_SGIX_pixel_texture_bits;
extern GLboolean __GLEW_SGIX_reference_plane;
extern GLboolean __GLEW_SGIX_resample;
extern GLboolean __GLEW_SGIX_shadow;
extern GLboolean __GLEW_SGIX_shadow_ambient;
extern GLboolean __GLEW_SGIX_sprite;
extern GLboolean __GLEW_SGIX_tag_sample_buffer;
extern GLboolean __GLEW_SGIX_texture_add_env;
extern GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern GLboolean __GLEW_SGIX_texture_lod_bias;
extern GLboolean __GLEW_SGIX_texture_multi_buffer;
extern GLboolean __GLEW_SGIX_texture_range;
extern GLboolean __GLEW_SGIX_texture_scale_bias;
extern GLboolean __GLEW_SGIX_vertex_preclip;
extern GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern GLboolean __GLEW_SGIX_ycrcb;
extern GLboolean __GLEW_SGI_color_matrix;
extern GLboolean __GLEW_SGI_color_table;
extern GLboolean __GLEW_SGI_texture_color_table;
extern GLboolean __GLEW_SUNX_constant_data;
extern GLboolean __GLEW_SUN_convolution_border_modes;
extern GLboolean __GLEW_SUN_global_alpha;
extern GLboolean __GLEW_SUN_mesh_array;
extern GLboolean __GLEW_SUN_read_video_pixels;
extern GLboolean __GLEW_SUN_slice_accum;
extern GLboolean __GLEW_SUN_triangle_list;
extern GLboolean __GLEW_SUN_vertex;
extern GLboolean __GLEW_WIN_phong_shading;
extern GLboolean __GLEW_WIN_specular_fog;
extern GLboolean __GLEW_WIN_swap_hint;
# 17094 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glew-1.9.0/include/GL/glew.h"
extern GLenum glewInit (void);
extern GLboolean glewIsSupported (const char *name);







extern GLboolean glewExperimental;
extern GLboolean glewGetExtension (const char *name);
extern const GLubyte * glewGetErrorString (GLenum error);
extern const GLubyte * glewGetString (GLenum name);


}
# 7 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h" 1
# 33 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
extern "C" {
# 137 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 138 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h" 2
# 147 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/System/Library/Frameworks/OpenGL.framework/Headers/gl.h" 1 3
# 148 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h" 2
# 558 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (*GLFWglproc)(void);







typedef struct GLFWmonitor GLFWmonitor;







typedef struct GLFWwindow GLFWwindow;
# 587 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWerrorfun)(int,const char*);
# 603 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWwindowposfun)(GLFWwindow*,int,int);
# 617 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWwindowsizefun)(GLFWwindow*,int,int);
# 629 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWwindowclosefun)(GLFWwindow*);
# 641 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWwindowrefreshfun)(GLFWwindow*);
# 655 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWwindowfocusfun)(GLFWwindow*,int);
# 670 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWwindowiconifyfun)(GLFWwindow*,int);
# 685 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWframebuffersizefun)(GLFWwindow*,int,int);
# 702 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWmousebuttonfun)(GLFWwindow*,int,int,int);
# 716 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWcursorposfun)(GLFWwindow*,double,double);
# 730 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWcursorenterfun)(GLFWwindow*,int);
# 744 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWscrollfun)(GLFWwindow*,double,double);
# 761 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWkeyfun)(GLFWwindow*,int,int,int,int);
# 774 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWcharfun)(GLFWwindow*,unsigned int);
# 787 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef void (* GLFWmonitorfun)(GLFWmonitor*,int);







typedef struct GLFWvidmode
{


    int width;


    int height;


    int redBits;


    int greenBits;


    int blueBits;


    int refreshRate;
} GLFWvidmode;
# 825 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
typedef struct GLFWgammaramp
{


    unsigned short* red;


    unsigned short* green;


    unsigned short* blue;


    unsigned int size;
} GLFWgammaramp;
# 877 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwInit(void);
# 901 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwTerminate(void);
# 921 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwGetVersion(int* major, int* minor, int* rev);
# 951 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const char* glfwGetVersionString(void);
# 976 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWerrorfun glfwSetErrorCallback(GLFWerrorfun cbfun);
# 998 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWmonitor** glfwGetMonitors(int* count);
# 1011 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWmonitor* glfwGetPrimaryMonitor(void);
# 1024 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwGetMonitorPos(GLFWmonitor* monitor, int* xpos, int* ypos);
# 1043 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwGetMonitorPhysicalSize(GLFWmonitor* monitor, int* width, int* height);
# 1059 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const char* glfwGetMonitorName(GLFWmonitor* monitor);
# 1077 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWmonitorfun glfwSetMonitorCallback(GLFWmonitorfun cbfun);
# 1101 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const GLFWvidmode* glfwGetVideoModes(GLFWmonitor* monitor, int* count);
# 1119 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const GLFWvidmode* glfwGetVideoMode(GLFWmonitor* monitor);
# 1131 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetGamma(GLFWmonitor* monitor, float gamma);
# 1145 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const GLFWgammaramp* glfwGetGammaRamp(GLFWmonitor* monitor);
# 1158 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetGammaRamp(GLFWmonitor* monitor, const GLFWgammaramp* ramp);
# 1171 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwDefaultWindowHints(void);
# 1193 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwWindowHint(int target, int hint);
# 1252 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindow* glfwCreateWindow(int width, int height, const char* title, GLFWmonitor* monitor, GLFWwindow* share);
# 1274 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwDestroyWindow(GLFWwindow* window);
# 1287 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwWindowShouldClose(GLFWwindow* window);
# 1302 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetWindowShouldClose(GLFWwindow* window, int value);
# 1316 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetWindowTitle(GLFWwindow* window, const char* title);
# 1333 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwGetWindowPos(GLFWwindow* window, int* xpos, int* ypos);
# 1365 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetWindowPos(GLFWwindow* window, int xpos, int ypos);
# 1382 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwGetWindowSize(GLFWwindow* window, int* width, int* height);
# 1406 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetWindowSize(GLFWwindow* window, int width, int height);
# 1423 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwGetFramebufferSize(GLFWwindow* window, int* width, int* height);
# 1440 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwIconifyWindow(GLFWwindow* window);
# 1457 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwRestoreWindow(GLFWwindow* window);
# 1473 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwShowWindow(GLFWwindow* window);
# 1489 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwHideWindow(GLFWwindow* window);
# 1501 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWmonitor* glfwGetWindowMonitor(GLFWwindow* window);
# 1515 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwGetWindowAttrib(GLFWwindow* window, int attrib);
# 1530 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetWindowUserPointer(GLFWwindow* window, void* pointer);
# 1543 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void* glfwGetWindowUserPointer(GLFWwindow* window);
# 1559 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindowposfun glfwSetWindowPosCallback(GLFWwindow* window, GLFWwindowposfun cbfun);
# 1575 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindowsizefun glfwSetWindowSizeCallback(GLFWwindow* window, GLFWwindowsizefun cbfun);
# 1599 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindowclosefun glfwSetWindowCloseCallback(GLFWwindow* window, GLFWwindowclosefun cbfun);
# 1623 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindowrefreshfun glfwSetWindowRefreshCallback(GLFWwindow* window, GLFWwindowrefreshfun cbfun);
# 1643 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindowfocusfun glfwSetWindowFocusCallback(GLFWwindow* window, GLFWwindowfocusfun cbfun);
# 1658 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindowiconifyfun glfwSetWindowIconifyCallback(GLFWwindow* window, GLFWwindowiconifyfun cbfun);
# 1673 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWframebuffersizefun glfwSetFramebufferSizeCallback(GLFWwindow* window, GLFWframebuffersizefun cbfun);
# 1698 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwPollEvents(void);
# 1725 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwWaitEvents(void);
# 1737 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwGetInputMode(GLFWwindow* window, int mode);
# 1772 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetInputMode(GLFWwindow* window, int mode, int value);
# 1798 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwGetKey(GLFWwindow* window, int key);
# 1816 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwGetMouseButton(GLFWwindow* window, int button);
# 1842 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwGetCursorPos(GLFWwindow* window, double* xpos, double* ypos);
# 1864 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetCursorPos(GLFWwindow* window, double xpos, double ypos);
# 1898 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWkeyfun glfwSetKeyCallback(GLFWwindow* window, GLFWkeyfun cbfun);
# 1917 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWcharfun glfwSetCharCallback(GLFWwindow* window, GLFWcharfun cbfun);
# 1938 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWmousebuttonfun glfwSetMouseButtonCallback(GLFWwindow* window, GLFWmousebuttonfun cbfun);
# 1954 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWcursorposfun glfwSetCursorPosCallback(GLFWwindow* window, GLFWcursorposfun cbfun);
# 1970 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWcursorenterfun glfwSetCursorEnterCallback(GLFWwindow* window, GLFWcursorenterfun cbfun);
# 1989 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWscrollfun glfwSetScrollCallback(GLFWwindow* window, GLFWscrollfun cbfun);
# 2000 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwJoystickPresent(int joy);
# 2019 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const float* glfwGetJoystickAxes(int joy, int* count);
# 2038 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const unsigned char* glfwGetJoystickButtons(int joy, int* count);
# 2056 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const char* glfwGetJoystickName(int joy);
# 2073 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetClipboardString(GLFWwindow* window, const char* string);
# 2096 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        const char* glfwGetClipboardString(GLFWwindow* window);
# 2114 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        double glfwGetTime(void);
# 2129 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSetTime(double time);
# 2147 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwMakeContextCurrent(GLFWwindow* window);
# 2163 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWwindow* glfwGetCurrentContext(void);
# 2183 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSwapBuffers(GLFWwindow* window);
# 2212 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        void glfwSwapInterval(int interval);
# 2233 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        int glfwExtensionSupported(const char* extension);
# 2254 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
        GLFWglproc glfwGetProcAddress(const char* procname);
# 2277 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glfw-3.0.3/include/GLFW/glfw3.h"
}
# 10 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2

GLFWwindow* window;



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 1
# 78 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp"
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_fixes.hpp" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_fixes.hpp"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 1 3
# 300 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 1 3
# 16 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
# 226 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
typedef __char16_t char16_t;
typedef __char32_t char32_t;
# 349 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
namespace std {
  inline namespace __1 {
  }
}
# 494 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__config" 3
template <bool> struct __static_assert_test;
template <> struct __static_assert_test<true> {};
template <unsigned> struct __static_assert_check {};
# 301 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 1 3 4
# 33 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern "C" {
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
    typedef float float_t;
    typedef double double_t;
# 111 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern int __math_errhandling(void);
# 144 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern int __fpclassifyf(float);
extern int __fpclassifyd(double);
extern int __fpclassifyl(long double);
# 188 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float);
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double);
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double);
inline __attribute__ ((__always_inline__)) int __inline_isinff(float);
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double);
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnand(double);
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double);
inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float);
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double);
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double);
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float);
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double);
inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double);

inline __attribute__ ((__always_inline__)) int __inline_isfinitef(float __x) {
    return __x == __x && __builtin_fabsf(__x) != __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinited(double __x) {
    return __x == __x && __builtin_fabs(__x) != __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isfinitel(long double __x) {
    return __x == __x && __builtin_fabsl(__x) != __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isinff(float __x) {
    return __builtin_fabsf(__x) == __builtin_inff();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfd(double __x) {
    return __builtin_fabs(__x) == __builtin_inf();
}
inline __attribute__ ((__always_inline__)) int __inline_isinfl(long double __x) {
    return __builtin_fabsl(__x) == __builtin_infl();
}
inline __attribute__ ((__always_inline__)) int __inline_isnanf(float __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnand(double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_isnanl(long double __x) {
    return __x != __x;
}
inline __attribute__ ((__always_inline__)) int __inline_signbitf(float __x) {
    union { float __f; unsigned int __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 31);
}
inline __attribute__ ((__always_inline__)) int __inline_signbitd(double __x) {
    union { double __f; unsigned long long __u; } __u;
    __u.__f = __x;
    return (int)(__u.__u >> 63);
}

inline __attribute__ ((__always_inline__)) int __inline_signbitl(long double __x) {
    union {
        long double __ld;
        struct{ unsigned long long __m; unsigned short __sexp; } __p;
    } __u;
    __u.__ld = __x;
    return (int)(__u.__p.__sexp >> 15);
}







inline __attribute__ ((__always_inline__)) int __inline_isnormalf(float __x) {
    return __inline_isfinitef(__x) && __builtin_fabsf(__x) >= 1.17549435e-38F;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormald(double __x) {
    return __inline_isfinited(__x) && __builtin_fabs(__x) >= 2.2250738585072014e-308;
}
inline __attribute__ ((__always_inline__)) int __inline_isnormall(long double __x) {
    return __inline_isfinitel(__x) && __builtin_fabsl(__x) >= 3.36210314311209350626e-4932L;
}
# 322 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern float acosf(float);
extern double acos(double);
extern long double acosl(long double);

extern float asinf(float);
extern double asin(double);
extern long double asinl(long double);

extern float atanf(float);
extern double atan(double);
extern long double atanl(long double);

extern float atan2f(float, float);
extern double atan2(double, double);
extern long double atan2l(long double, long double);

extern float cosf(float);
extern double cos(double);
extern long double cosl(long double);

extern float sinf(float);
extern double sin(double);
extern long double sinl(long double);

extern float tanf(float);
extern double tan(double);
extern long double tanl(long double);

extern float acoshf(float);
extern double acosh(double);
extern long double acoshl(long double);

extern float asinhf(float);
extern double asinh(double);
extern long double asinhl(long double);

extern float atanhf(float);
extern double atanh(double);
extern long double atanhl(long double);

extern float coshf(float);
extern double cosh(double);
extern long double coshl(long double);

extern float sinhf(float);
extern double sinh(double);
extern long double sinhl(long double);

extern float tanhf(float);
extern double tanh(double);
extern long double tanhl(long double);

extern float expf(float);
extern double exp(double);
extern long double expl(long double);

extern float exp2f(float);
extern double exp2(double);
extern long double exp2l(long double);

extern float expm1f(float);
extern double expm1(double);
extern long double expm1l(long double);

extern float logf(float);
extern double log(double);
extern long double logl(long double);

extern float log10f(float);
extern double log10(double);
extern long double log10l(long double);

extern float log2f(float);
extern double log2(double);
extern long double log2l(long double);

extern float log1pf(float);
extern double log1p(double);
extern long double log1pl(long double);

extern float logbf(float);
extern double logb(double);
extern long double logbl(long double);

extern float modff(float, float *);
extern double modf(double, double *);
extern long double modfl(long double, long double *);

extern float ldexpf(float, int);
extern double ldexp(double, int);
extern long double ldexpl(long double, int);

extern float frexpf(float, int *);
extern double frexp(double, int *);
extern long double frexpl(long double, int *);

extern int ilogbf(float);
extern int ilogb(double);
extern int ilogbl(long double);

extern float scalbnf(float, int);
extern double scalbn(double, int);
extern long double scalbnl(long double, int);

extern float scalblnf(float, long int);
extern double scalbln(double, long int);
extern long double scalblnl(long double, long int);

extern float fabsf(float);
extern double fabs(double);
extern long double fabsl(long double);

extern float cbrtf(float);
extern double cbrt(double);
extern long double cbrtl(long double);

extern float hypotf(float, float);
extern double hypot(double, double);
extern long double hypotl(long double, long double);

extern float powf(float, float);
extern double pow(double, double);
extern long double powl(long double, long double);

extern float sqrtf(float);
extern double sqrt(double);
extern long double sqrtl(long double);

extern float erff(float);
extern double erf(double);
extern long double erfl(long double);

extern float erfcf(float);
extern double erfc(double);
extern long double erfcl(long double);




extern float lgammaf(float);
extern double lgamma(double);
extern long double lgammal(long double);

extern float tgammaf(float);
extern double tgamma(double);
extern long double tgammal(long double);

extern float ceilf(float);
extern double ceil(double);
extern long double ceill(long double);

extern float floorf(float);
extern double floor(double);
extern long double floorl(long double);

extern float nearbyintf(float);
extern double nearbyint(double);
extern long double nearbyintl(long double);

extern float rintf(float);
extern double rint(double);
extern long double rintl(long double);

extern long int lrintf(float);
extern long int lrint(double);
extern long int lrintl(long double);

extern float roundf(float);
extern double round(double);
extern long double roundl(long double);

extern long int lroundf(float);
extern long int lround(double);
extern long int lroundl(long double);




extern long long int llrintf(float);
extern long long int llrint(double);
extern long long int llrintl(long double);

extern long long int llroundf(float);
extern long long int llround(double);
extern long long int llroundl(long double);


extern float truncf(float);
extern double trunc(double);
extern long double truncl(long double);

extern float fmodf(float, float);
extern double fmod(double, double);
extern long double fmodl(long double, long double);

extern float remainderf(float, float);
extern double remainder(double, double);
extern long double remainderl(long double, long double);

extern float remquof(float, float, int *);
extern double remquo(double, double, int *);
extern long double remquol(long double, long double, int *);

extern float copysignf(float, float);
extern double copysign(double, double);
extern long double copysignl(long double, long double);

extern float nanf(const char *);
extern double nan(const char *);
extern long double nanl(const char *);

extern float nextafterf(float, float);
extern double nextafter(double, double);
extern long double nextafterl(long double, long double);

extern double nexttoward(double, long double);
extern float nexttowardf(float, long double);
extern long double nexttowardl(long double, long double);

extern float fdimf(float, float);
extern double fdim(double, double);
extern long double fdiml(long double, long double);

extern float fmaxf(float, float);
extern double fmax(double, double);
extern long double fmaxl(long double, long double);

extern float fminf(float, float);
extern double fmin(double, double);
extern long double fminl(long double, long double);

extern float fmaf(float, float, float);
extern double fma(double, double, double);
extern long double fmal(long double, long double, long double);
# 565 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern float __inff(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern double __inf(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
extern long double __infl(void) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern float __nan(void) __attribute__((availability(macosx,introduced=10.0)));
# 597 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern float __exp10f(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __exp10(double) __attribute__((availability(macosx,introduced=10.9)));





inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) __attribute__((availability(macosx,introduced=10.9)));
inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) __attribute__((availability(macosx,introduced=10.9)));
# 614 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern float __cospif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __cospi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __sinpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __sinpi(double) __attribute__((availability(macosx,introduced=10.9)));
extern float __tanpif(float) __attribute__((availability(macosx,introduced=10.9)));
extern double __tanpi(double) __attribute__((availability(macosx,introduced=10.9)));






inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) __attribute__((availability(macosx,introduced=10.9)));
inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) __attribute__((availability(macosx,introduced=10.9)));






struct __float2 { float __sinval; float __cosval; };
struct __double2 { double __sinval; double __cosval; };

extern struct __float2 __sincosf_stret(float);
extern struct __double2 __sincos_stret(double);
extern struct __float2 __sincospif_stret(float);
extern struct __double2 __sincospi_stret(double);

inline __attribute__ ((__always_inline__)) void __sincosf(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincosf_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincos(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincos_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospif(float __x, float *__sinp, float *__cosp) {
    const struct __float2 __stret = __sincospif_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}

inline __attribute__ ((__always_inline__)) void __sincospi(double __x, double *__sinp, double *__cosp) {
    const struct __double2 __stret = __sincospi_stret(__x);
    *__sinp = __stret.__sinval; *__cosp = __stret.__cosval;
}






extern double j0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double j1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double jn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double y0(double) __attribute__((availability(macosx,introduced=10.0)));
extern double y1(double) __attribute__((availability(macosx,introduced=10.0)));
extern double yn(int, double) __attribute__((availability(macosx,introduced=10.0)));
extern double scalb(double, double);
extern int signgam;
# 712 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
extern long int rinttol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern long int roundtol(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double drem(double, double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern int finite(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double gamma(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));

extern double significand(double) __attribute__((availability(macosx,introduced=10.0,deprecated=10.9)));
# 737 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/math.h" 3 4
}
# 302 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 1 3
# 203 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 1 3
# 44 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 2 3
# 48 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstddef" 3


namespace std {inline namespace __1 {

using ::ptrdiff_t;
using ::size_t;

typedef long double max_align_t;



struct __attribute__ ((__type_visibility__("default"))) nullptr_t
{
    void* __lx;

    struct __nat {int __for_bool_;};

    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t() : __lx(0) {}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t(int __nat::*) : __lx(0) {}

    __attribute__ ((__visibility__("hidden"), __always_inline__)) operator int __nat::*() const {return 0;}

    template <class _Tp>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp* () const {return 0;}

    template <class _Tp, class _Up>
        __attribute__ ((__visibility__("hidden"), __always_inline__))
        operator _Tp _Up::* () const {return 0;}

    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator==(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator!=(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator<=(nullptr_t, nullptr_t) {return true;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>(nullptr_t, nullptr_t) {return false;}
    friend __attribute__ ((__visibility__("hidden"), __always_inline__)) bool operator>=(nullptr_t, nullptr_t) {return true;}
};

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) nullptr_t __get_nullptr_t() {return nullptr_t(0);}





} }
# 204 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 2 3
# 207 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3


namespace std {inline namespace __1 {

template <bool _Bp, class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional {typedef _If type;};
template <class _If, class _Then>
    struct __attribute__ ((__type_visibility__("default"))) conditional<false, _If, _Then> {typedef _Then type;};





template <bool, class _Tp = void> struct __attribute__ ((__type_visibility__("default"))) enable_if {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) enable_if<true, _Tp> {typedef _Tp type;};






struct __two {char __lx[2];};



template <class _Tp, _Tp __v>
struct __attribute__ ((__type_visibility__("default"))) integral_constant
{
    static const _Tp value = __v;
    typedef _Tp value_type;
    typedef integral_constant type;
    __attribute__ ((__visibility__("hidden"), __always_inline__))
                          operator value_type() const {return value;}




};

template <class _Tp, _Tp __v>
                  const _Tp integral_constant<_Tp, __v>::value;

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_const<_Tp const> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_volatile<_Tp volatile> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_const<const _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_volatile<volatile _Tp> {typedef _Tp type;};






template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_cv
{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};






template <class _Tp> struct __libcpp_is_void : public false_type {};
template <> struct __libcpp_is_void<void> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_void
    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __is_nullptr_t_impl : public false_type {};
template <> struct __is_nullptr_t_impl<nullptr_t> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) __is_nullptr_t
    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};
# 309 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_is_integral : public false_type {};
template <> struct __libcpp_is_integral<bool> : public true_type {};
template <> struct __libcpp_is_integral<char> : public true_type {};
template <> struct __libcpp_is_integral<signed char> : public true_type {};
template <> struct __libcpp_is_integral<unsigned char> : public true_type {};
template <> struct __libcpp_is_integral<wchar_t> : public true_type {};

template <> struct __libcpp_is_integral<char16_t> : public true_type {};
template <> struct __libcpp_is_integral<char32_t> : public true_type {};

template <> struct __libcpp_is_integral<short> : public true_type {};
template <> struct __libcpp_is_integral<unsigned short> : public true_type {};
template <> struct __libcpp_is_integral<int> : public true_type {};
template <> struct __libcpp_is_integral<unsigned int> : public true_type {};
template <> struct __libcpp_is_integral<long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long> : public true_type {};
template <> struct __libcpp_is_integral<long long> : public true_type {};
template <> struct __libcpp_is_integral<unsigned long long> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_integral
    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_floating_point : public false_type {};
template <> struct __libcpp_is_floating_point<float> : public true_type {};
template <> struct __libcpp_is_floating_point<double> : public true_type {};
template <> struct __libcpp_is_floating_point<long double> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_floating_point
    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array
    : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[]>
    : public true_type {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) is_array<_Tp[_Np]>
    : public true_type {};



template <class _Tp> struct __libcpp_is_pointer : public false_type {};
template <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pointer
    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_lvalue_reference<_Tp&> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_rvalue_reference : public false_type {};




template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_reference<_Tp&> : public true_type {};
# 382 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_union
    : public integral_constant<bool, __is_union(_Tp)> {};
# 397 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_class
    : public integral_constant<bool, __is_class(_Tp)> {};
# 415 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Up> struct __attribute__ ((__type_visibility__("default"))) is_same : public false_type {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_same<_Tp, _Tp> : public true_type {};



namespace __libcpp_is_function_imp
{
template <class _Tp> char __test(_Tp*);
template <class _Tp> __two __test(...);
template <class _Tp> _Tp& __source();
}

template <class _Tp, bool = is_class<_Tp>::value ||
                            is_union<_Tp>::value ||
                            is_void<_Tp>::value ||
                            is_reference<_Tp>::value ||
                            __is_nullptr_t<_Tp>::value >
struct __libcpp_is_function
    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>())) == 1>
    {};
template <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_function
    : public __libcpp_is_function<_Tp> {};



template <class _Tp> struct __libcpp_is_member_function_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_function_pointer
    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __libcpp_is_member_pointer : public false_type {};
template <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_pointer
    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_member_object_pointer
    : public integral_constant<bool, is_member_pointer<_Tp>::value &&
                                    !is_member_function_pointer<_Tp>::value> {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_enum
    : public integral_constant<bool, __is_enum(_Tp)> {};
# 487 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_arithmetic
    : public integral_constant<bool, is_integral<_Tp>::value ||
                                     is_floating_point<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_fundamental
    : public integral_constant<bool, is_void<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_arithmetic<_Tp>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_scalar
    : public integral_constant<bool, is_arithmetic<_Tp>::value ||
                                     is_member_pointer<_Tp>::value ||
                                     is_pointer<_Tp>::value ||
                                     __is_nullptr_t<_Tp>::value ||
                                     is_enum<_Tp>::value > {};

template <> struct __attribute__ ((__type_visibility__("default"))) is_scalar<nullptr_t> : public true_type {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_object
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_array<_Tp>::value ||
                                     is_union<_Tp>::value ||
                                     is_class<_Tp>::value > {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};



template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_const<_Tp>::value >
struct __add_const {typedef _Tp type;};

template <class _Tp>
struct __add_const<_Tp, false> {typedef const _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_const
    {typedef typename __add_const<_Tp>::type type;};







template <class _Tp, bool = is_reference<_Tp>::value ||
                            is_function<_Tp>::value ||
                            is_volatile<_Tp>::value >
struct __add_volatile {typedef _Tp type;};

template <class _Tp>
struct __add_volatile<_Tp, false> {typedef volatile _Tp type;};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_volatile
    {typedef typename __add_volatile<_Tp>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_cv
    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_reference<_Tp&> {typedef _Tp type;};
# 579 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference {typedef _Tp& type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<_Tp&> {typedef _Tp& type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<void> {typedef void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const void> {typedef const void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<volatile void> {typedef volatile void type;};
template <> struct __attribute__ ((__type_visibility__("default"))) add_lvalue_reference<const volatile void> {typedef const volatile void type;};
# 612 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
typename add_lvalue_reference<_Tp>::type
declval();



struct __any
{
    __any(...);
};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp*> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* volatile> {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_pointer<_Tp* const volatile> {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) add_pointer
    {typedef typename remove_reference<_Tp>::type* type;};







template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

template <class _Tp>
struct __libcpp_is_signed_impl<_Tp, false> : public true_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_signed : public __libcpp_is_signed<_Tp> {};



template <class _Tp, bool = is_integral<_Tp>::value>
struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

template <class _Tp>
struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_unsigned : public __libcpp_is_unsigned<_Tp> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) rank<_Tp[_Np]>
    : public integral_constant<size_t, rank<_Tp>::value + 1> {};



template <class _Tp, unsigned _Ip = 0> struct __attribute__ ((__type_visibility__("default"))) extent
    : public integral_constant<size_t, 0> {};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], 0>
    : public integral_constant<size_t, 0> {};
template <class _Tp, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], 0>
    : public integral_constant<size_t, _Np> {};
template <class _Tp, size_t _Np, unsigned _Ip> struct __attribute__ ((__type_visibility__("default"))) extent<_Tp[_Np], _Ip>
    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[]>
    {typedef _Tp type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_extent<_Tp[_Np]>
    {typedef _Tp type;};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents
    {typedef _Tp type;};
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[]>
    {typedef typename remove_all_extents<_Tp>::type type;};
template <class _Tp, size_t _Np> struct __attribute__ ((__type_visibility__("default"))) remove_all_extents<_Tp[_Np]>
    {typedef typename remove_all_extents<_Tp>::type type;};







template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) decay
{
private:
    typedef typename remove_reference<_Tp>::type _Up;
public:
    typedef typename conditional
                     <
                         is_array<_Up>::value,
                         typename remove_extent<_Up>::type*,
                         typename conditional
                         <
                              is_function<_Up>::value,
                              typename add_pointer<_Up>::type,
                              typename remove_cv<_Up>::type
                         >::type
                     >::type type;
};







namespace __is_abstract_imp
{
template <class _Tp> char __test(_Tp (*)[1]);
template <class _Tp> __two __test(...);
}

template <class _Tp, bool = is_class<_Tp>::value>
struct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};

template <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_abstract : public __libcpp_abstract<_Tp> {};





template <class _Bp, class _Dp>
struct __attribute__ ((__type_visibility__("default"))) is_base_of
    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};
# 801 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _T1, class _T2> struct __attribute__ ((__type_visibility__("default"))) is_convertible
    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&
                                     !is_abstract<_T2>::value> {};
# 920 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_empty
    : public integral_constant<bool, __is_empty(_Tp)> {};
# 951 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)> {};
# 971 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};
# 983 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) alignment_of
    : public integral_constant<size_t, __alignof__(_Tp)> {};



template <class _Hp, class _Tp>
struct __type_list
{
    typedef _Hp _Head;
    typedef _Tp _Tail;
};

struct __nat
{






};

template <class _Tp>
struct __align_type
{
    static const size_t value = alignment_of<_Tp>::value;
    typedef _Tp type;
};

struct __struct_double {long double __lx;};
struct __struct_double4 {double __lx[4];};

typedef
    __type_list<__align_type<unsigned char>,
    __type_list<__align_type<unsigned short>,
    __type_list<__align_type<unsigned int>,
    __type_list<__align_type<unsigned long>,
    __type_list<__align_type<unsigned long long>,
    __type_list<__align_type<double>,
    __type_list<__align_type<long double>,
    __type_list<__align_type<__struct_double>,
    __type_list<__align_type<__struct_double4>,
    __type_list<__align_type<int*>,
    __nat
    > > > > > > > > > > __all_types;

template <class _TL, size_t _Align> struct __find_pod;

template <class _Hp, size_t _Align>
struct __find_pod<__type_list<_Hp, __nat>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             void
                         >::type type;
};

template <class _Hp, class _Tp, size_t _Align>
struct __find_pod<__type_list<_Hp, _Tp>, _Align>
{
    typedef typename conditional<
                             _Align == _Hp::value,
                             typename _Hp::type,
                             typename __find_pod<_Tp, _Align>::type
                         >::type type;
};

template <class _TL, size_t _Len> struct __find_max_align;

template <class _Hp, size_t _Len>
struct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};

template <size_t _Len, size_t _A1, size_t _A2>
struct __select_align
{
private:
    static const size_t __min = _A2 < _A1 ? _A2 : _A1;
    static const size_t __max = _A1 < _A2 ? _A2 : _A1;
public:
    static const size_t value = _Len < __max ? __min : __max;
};

template <class _Hp, class _Tp, size_t _Len>
struct __find_max_align<__type_list<_Hp, _Tp>, _Len>
    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};

template <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>
struct __attribute__ ((__type_visibility__("default"))) aligned_storage
{
    typedef typename __find_pod<__all_types, _Align>::type _Aligner;
    typedef __static_assert_check<sizeof(__static_assert_test<(!is_void<_Aligner>::value)>)> __t1074;
    union type
    {
        _Aligner __align;
        unsigned char __data[_Len];
    };
};
# 1097 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1>{ struct __attribute__((__aligned__(0x1))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2>{ struct __attribute__((__aligned__(0x2))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4>{ struct __attribute__((__aligned__(0x4))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x8>{ struct __attribute__((__aligned__(0x8))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x10>{ struct __attribute__((__aligned__(0x10))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x20>{ struct __attribute__((__aligned__(0x20))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x40>{ struct __attribute__((__aligned__(0x40))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x80>{ struct __attribute__((__aligned__(0x80))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x100>{ struct __attribute__((__aligned__(0x100))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x200>{ struct __attribute__((__aligned__(0x200))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x400>{ struct __attribute__((__aligned__(0x400))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x800>{ struct __attribute__((__aligned__(0x800))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x1000>{ struct __attribute__((__aligned__(0x1000))) type { unsigned char __lx[_Len]; };};
template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x2000>{ struct __attribute__((__aligned__(0x2000))) type { unsigned char __lx[_Len]; };};


template <size_t _Len>struct __attribute__ ((__type_visibility__("default"))) aligned_storage<_Len, 0x4000>{ struct __attribute__((__aligned__(0x4000))) type { unsigned char __lx[_Len]; };};
# 1154 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __numeric_type
{
   static void __test(...);
   static float __test(float);
   static double __test(char);
   static double __test(int);
   static double __test(unsigned);
   static double __test(long);
   static double __test(unsigned long);
   static double __test(long long);
   static double __test(unsigned long long);
   static double __test(double);
   static long double __test(long double);

   typedef __typeof__(__test(declval<_Tp>())) type;
   static const bool value = !is_same<type, void>::value;
};

template <>
struct __numeric_type<void>
{
   static const bool value = true;
};



template <class _A1, class _A2 = void, class _A3 = void,
          bool = __numeric_type<_A1>::value &&
                 __numeric_type<_A2>::value &&
                 __numeric_type<_A3>::value>
class __promote
{
    static const bool value = false;
};

template <class _A1, class _A2, class _A3>
class __promote<_A1, _A2, _A3, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
    typedef typename __promote<_A3>::type __type3;
public:
    typedef __typeof__(__type1() + __type2() + __type3()) type;
    static const bool value = true;
};

template <class _A1, class _A2>
class __promote<_A1, _A2, void, true>
{
private:
    typedef typename __promote<_A1>::type __type1;
    typedef typename __promote<_A2>::type __type2;
public:
    typedef __typeof__(__type1() + __type2()) type;
    static const bool value = true;
};

template <class _A1>
class __promote<_A1, void, void, true>
{
public:
    typedef typename __numeric_type<_A1>::type type;
    static const bool value = true;
    static const bool __does_not_throw = false;
};
# 1236 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
typedef
    __type_list<signed char,
    __type_list<signed short,
    __type_list<signed int,
    __type_list<signed long,
    __type_list<signed long long,
    __nat
    > > > > > __signed_types;

typedef
    __type_list<unsigned char,
    __type_list<unsigned short,
    __type_list<unsigned int,
    __type_list<unsigned long,
    __type_list<unsigned long long,
    __nat
    > > > > > __unsigned_types;

template <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, true>
{
    typedef _Hp type;
};

template <class _Hp, class _Tp, size_t _Size>
struct __find_first<__type_list<_Hp, _Tp>, _Size, false>
{
    typedef typename __find_first<_Tp, _Size>::type type;
};

template <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,
                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>
struct __apply_cv
{
    typedef _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, false>
{
    typedef const _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, false, true>
{
    typedef volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp, _Up, true, true>
{
    typedef const volatile _Up type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, false>
{
    typedef _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, false>
{
    typedef const _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, false, true>
{
    typedef volatile _Up& type;
};

template <class _Tp, class _Up>
struct __apply_cv<_Tp&, _Up, true, true>
{
    typedef const volatile _Up& type;
};

template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_signed {};

template <class _Tp>
struct __make_signed<_Tp, true>
{
    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;
};

template <> struct __make_signed<bool, true> {};
template <> struct __make_signed< signed short, true> {typedef short type;};
template <> struct __make_signed<unsigned short, true> {typedef short type;};
template <> struct __make_signed< signed int, true> {typedef int type;};
template <> struct __make_signed<unsigned int, true> {typedef int type;};
template <> struct __make_signed< signed long, true> {typedef long type;};
template <> struct __make_signed<unsigned long, true> {typedef long type;};
template <> struct __make_signed< signed long long, true> {typedef long long type;};
template <> struct __make_signed<unsigned long long, true> {typedef long long type;};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_signed
{
    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;
};





template <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>
struct __make_unsigned {};

template <class _Tp>
struct __make_unsigned<_Tp, true>
{
    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;
};

template <> struct __make_unsigned<bool, true> {};
template <> struct __make_unsigned< signed short, true> {typedef unsigned short type;};
template <> struct __make_unsigned<unsigned short, true> {typedef unsigned short type;};
template <> struct __make_unsigned< signed int, true> {typedef unsigned int type;};
template <> struct __make_unsigned<unsigned int, true> {typedef unsigned int type;};
template <> struct __make_unsigned< signed long, true> {typedef unsigned long type;};
template <> struct __make_unsigned<unsigned long, true> {typedef unsigned long type;};
template <> struct __make_unsigned< signed long long, true> {typedef unsigned long long type;};
template <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) make_unsigned
{
    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;
};







template <class _Tp, class _Up = void, class V = void>
struct __attribute__ ((__type_visibility__("default"))) common_type
{
public:
    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, void, void>
{
public:
    typedef _Tp type;
};

template <class _Tp, class _Up>
struct __attribute__ ((__type_visibility__("default"))) common_type<_Tp, _Up, void>
{
private:




    static _Tp __t();
    static _Up __u();

public:
    typedef typename remove_reference<__typeof__(true ? __t() : __u())>::type type;
};
# 1441 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };

template <class _Tp, class _Arg>
typename __select_2nd<__typeof__((std::__1::declval<_Tp>() = std::__1::declval<_Arg>())), true_type>::type



__is_assignable_test(_Tp, _Arg&);


template <class _Arg>
false_type



__is_assignable_test(__any, _Arg&);


template <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>
struct __is_assignable_imp
    : public common_type
        <
            __typeof__(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))
        >::type {};

template <class _Tp, class _Arg>
struct __is_assignable_imp<_Tp, _Arg, true>
    : public false_type
{
};

template <class _Tp, class _Arg>
struct is_assignable
    : public __is_assignable_imp<_Tp, _Arg> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_copy_assignable
    : public is_assignable<typename add_lvalue_reference<_Tp>::type,
                     const typename add_lvalue_reference<_Tp>::type> {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_move_assignable




    : public is_copy_assignable<_Tp> {};




template <class _Tp>
struct __destructible_test
{
    _Tp __t;
};

template <class _Tp>
__typeof__((std::__1::declval<__destructible_test<_Tp> >().~__destructible_test<_Tp>(), true_type()))



__is_destructible_test(_Tp&);


false_type
__is_destructible_test(__any);

template <class _Tp, bool = is_void<_Tp>::value || is_abstract<_Tp>::value
                                                || is_function<_Tp>::value>
struct __destructible_imp
    : public common_type
        <
            __typeof__(__is_destructible_test(declval<_Tp>()))
        >::type {};

template <class _Tp>
struct __destructible_imp<_Tp, true>
    : public false_type {};

template <class _Tp>
struct is_destructible
    : public __destructible_imp<_Tp> {};

template <class _Tp>
struct is_destructible<_Tp[]>
    : public false_type {};
# 1564 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
move(_Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
const _Tp&
move(const _Tp& __t)
{
    return __t;
}

template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
_Tp&
forward(typename std::remove_reference<_Tp>::type& __t) throw()
{
    return __t;
}


template <class _Tp>
class __rv
{
    typedef typename remove_reference<_Tp>::type _Trr;
    _Trr& t_;
public:
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    _Trr* operator->() {return &t_;}
    __attribute__ ((__visibility__("hidden"), __always_inline__))
    explicit __rv(_Trr& __t) : t_(__t) {}
};
# 1615 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename decay<_Tp>::type
__decay_copy(const _Tp& __t)
{
    return std::__1::forward<_Tp>(__t);
}



template <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>
struct __member_pointer_traits_imp
{
};
# 1722 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>
{
    typedef _Class const _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>
{
    typedef _Class volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};

template <class _Rp, class _Class, class _P0, class _P1, class _P2>
struct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>
{
    typedef _Class const volatile _ClassType;
    typedef _Rp _ReturnType;
};



template <class _Rp, class _Class>
struct __member_pointer_traits_imp<_Rp _Class::*, false, true>
{
    typedef _Class _ClassType;
    typedef _Rp _ReturnType;
};

template <class _MP>
struct __member_pointer_traits
    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,
                    is_member_function_pointer<_MP>::value,
                    is_member_object_pointer<_MP>::value>
{


};



template <class _Callable> class result_of;



template <class _Fn, bool, bool>
class __result_of
{
};

template <class _Fn>
class __result_of<_Fn(), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()()) type;
};

template <class _Fn, class _A0>
class __result_of<_Fn(_A0), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>())) type;
};

template <class _Fn, class _A0, class _A1>
class __result_of<_Fn(_A0, _A1), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;
};

template <class _Fn, class _A0, class _A1, class _A2>
class __result_of<_Fn(_A0, _A1, _A2), true, false>
{
public:
    typedef __typeof__(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;
};

template <class _MP, class _Tp, bool _IsMemberFunctionPtr>
struct __result_of_mp;



template <class _MP, class _Tp>
struct __result_of_mp<_MP, _Tp, true>
    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>
{
};



template <class _MP, class _Tp, bool>
struct __result_of_mdp;

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, false>
{
    typedef typename __apply_cv<__typeof__(*std::__1::declval<_Tp>()), _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mdp<_Rp _Class::*, _Tp, true>
{
    typedef typename __apply_cv<_Tp, _Rp>::type& type;
};

template <class _Rp, class _Class, class _Tp>
struct __result_of_mp<_Rp _Class::*, _Tp, false>
    : public __result_of_mdp<_Rp _Class::*, _Tp,
            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>
{
};



template <class _Fn, class _Tp>
class __result_of<_Fn(_Tp), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0>
class __result_of<_Fn(_Tp, _A0), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1>
class __result_of<_Fn(_Tp, _A0, _A1), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};

template <class _Fn, class _Tp, class _A0, class _A1, class _A2>
class __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>
    : public __result_of_mp<typename remove_reference<_Fn>::type,
                            _Tp,
                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>
{
};



template <class _Fn>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn()>
    : public __result_of<_Fn(),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0)>
    : public __result_of<_Fn(_A0),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1)>
    : public __result_of<_Fn(_A0, _A1),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};

template <class _Fn, class _A0, class _A1, class _A2>
class __attribute__ ((__type_visibility__("default"))) result_of<_Fn(_A0, _A1, _A2)>
    : public __result_of<_Fn(_A0, _A1, _A2),
                         is_class<typename remove_reference<_Fn>::type>::value ||
                         is_function<typename remove_reference<_Fn>::type>::value,
                         is_member_pointer<typename remove_reference<_Fn>::type>::value
                        >
{
};
# 2131 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
__typeof__((_Tp(), true_type()))
__is_constructible0_test(_Tp&);

false_type
__is_constructible0_test(__any);

template <class _Tp, class _A0>
__typeof__((_Tp(std::__1::declval<_A0>()), true_type()))
__is_constructible1_test(_Tp&, _A0&);

template <class _A0>
false_type
__is_constructible1_test(__any, _A0&);

template <class _Tp, class _A0, class _A1>
__typeof__((_Tp(std::__1::declval<_A0>(), std::__1::declval<_A1>()), true_type()))
__is_constructible2_test(_Tp&, _A0&, _A1&);

template <class _A0, class _A1>
false_type
__is_constructible2_test(__any, _A0&, _A1&);

template <bool, class _Tp>
struct __is_constructible0_imp
    : public common_type
             <
                 __typeof__(__is_constructible0_test(declval<_Tp&>()))
             >::type
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_imp
    : public common_type
             <
                 __typeof__(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))
             >::type
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_imp
    : public common_type
             <
                 __typeof__(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))
             >::type
    {};





template <class _Tp>
struct __is_constructible0_imp<true, _Tp>
    : public is_scalar<_Tp>
    {};

template <class _Tp, class _A0>
struct __is_constructible1_imp<true, _Tp, _A0>
    : public is_convertible<_A0, _Tp>
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_imp<true, _Tp, _A0, _A1>
    : public false_type
    {};



template <bool, class _Tp>
struct __is_constructible0_void_check
    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp>
    {};

template <bool, class _Tp, class _A0>
struct __is_constructible1_void_check
    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0>
    {};

template <bool, class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check
    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,
                                _Tp, _A0, _A1>
    {};



template <class _Tp>
struct __is_constructible0_void_check<true, _Tp>
    : public false_type
    {};

template <class _Tp, class _A0>
struct __is_constructible1_void_check<true, _Tp, _A0>
    : public false_type
    {};

template <class _Tp, class _A0, class _A1>
struct __is_constructible2_void_check<true, _Tp, _A0, _A1>
    : public false_type
    {};



namespace __is_construct
{

struct __nat {};

}

template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_constructible
    : public __is_constructible2_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value
                                        || is_void<_A1>::value,
                                           _Tp, _A0, _A1>
    {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>
    : public __is_constructible0_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value,
                                           _Tp>
    {};

template <class _Tp, class _A0>
struct __attribute__ ((__type_visibility__("default"))) is_constructible<_Tp, _A0, __is_construct::__nat>
    : public __is_constructible1_void_check<is_void<_Tp>::value
                                        || is_abstract<_Tp>::value
                                        || is_function<_Tp>::value
                                        || is_void<_A0>::value,
                                           _Tp, _A0>
    {};




template <class _Ap, size_t _Np>
struct __is_constructible0_imp<false, _Ap[_Np]>
    : public is_constructible<typename remove_all_extents<_Ap>::type>
    {};

template <class _Ap, size_t _Np, class _A0>
struct __is_constructible1_imp<false, _Ap[_Np], _A0>
    : public false_type
    {};

template <class _Ap, size_t _Np, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>
    : public false_type
    {};



template <class _Ap>
struct __is_constructible0_imp<false, _Ap[]>
    : public false_type
    {};

template <class _Ap, class _A0>
struct __is_constructible1_imp<false, _Ap[], _A0>
    : public false_type
    {};

template <class _Ap, class _A0, class _A1>
struct __is_constructible2_imp<false, _Ap[], _A0, _A1>
    : public false_type
    {};





template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_default_constructible
    : public is_constructible<_Tp>
    {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_copy_constructible
    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_move_constructible



    : public is_copy_constructible<_Tp>

    {};
# 2389 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible
    : false_type
{
};



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_trivially_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>
    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>
{
};
# 2462 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_default_constructible
    : public is_trivially_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_constructible
    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_constructible



    : public is_trivially_copy_constructible<_Tp>

    {};





template <class _Tp, class _Arg>
struct is_trivially_assignable
    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>
{
};
# 2522 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copy_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_move_assignable
    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_destructible
    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};
# 2644 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _A0 = __is_construct::__nat,
                     class _A1 = __is_construct::__nat>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible
    : false_type
{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, __is_construct::__nat,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_constructor(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, const _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_constructible<_Tp, _Tp&,
                                                       __is_construct::__nat>

    : integral_constant<bool, __has_nothrow_copy(_Tp)>



{
};





template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_default_constructible
    : public is_nothrow_constructible<_Tp>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_constructible
    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_constructible



    : public is_nothrow_copy_constructible<_Tp>

    {};
# 2745 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp, class _Arg>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable
    : public false_type {};

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_nothrow_assignable<_Tp&, const _Tp&>

    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};
# 2789 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_copy_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,
                               const typename add_lvalue_reference<_Tp>::type>
    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_move_assignable
    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,



                                     typename add_lvalue_reference<_Tp>::type>

    {};
# 2853 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __libcpp_nothrow_destructor
    : public integral_constant<bool, is_scalar<_Tp>::value ||
                                     is_reference<_Tp>::value> {};

template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_nothrow_destructible
    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};







template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_pod
    : public integral_constant<bool, __is_pod(_Tp)> {};
# 2881 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_literal_type

    : public integral_constant<bool, __is_literal(_Tp)>




    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_standard_layout

    : public integral_constant<bool, __is_standard_layout(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivially_copyable

    : public integral_constant<bool, __is_trivially_copyable(_Tp)>



    {};



template <class _Tp> struct __attribute__ ((__type_visibility__("default"))) is_trivial

    : public integral_constant<bool, __is_trivial(_Tp)>




    {};
# 3190 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))







void

swap(_Tp& __x, _Tp& __y)

{
    _Tp __t(std::__1::move(__x));
    __x = std::__1::move(__y);
    __y = std::__1::move(__t);
}

template <class _ForwardIterator1, class _ForwardIterator2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
void
iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)



{
    swap(*__a, *__b);
}



namespace __detail
{

using std::__1::swap;
__nat swap(__any, __any);

template <class _Tp>
struct __swappable
{
    typedef __typeof__(swap(std::__1::declval<_Tp&>(), std::__1::declval<_Tp&>())) type;
    static const bool value = !is_same<type, __nat>::value;
};

}

template <class _Tp>
struct __is_swappable
    : public integral_constant<bool, __detail::__swappable<_Tp>::value>
{
};
# 3266 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
template <class _Tp>
struct __is_nothrow_swappable
    : public false_type
{
};





template <class _Tp>
struct underlying_type
{
    typedef __underlying_type(_Tp) type;
};
# 3319 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/type_traits" 3
} }
# 303 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 2 3
# 310 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cmath" 3






template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_signbit(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_signbitf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_signbitd((double)(__x)) : __inline_signbitl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
signbit(_A1 __x) throw()
{
    return __libcpp_signbit((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
int
__libcpp_fpclassify(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __fpclassifyf((float)(__x)) : sizeof(__x) == sizeof(double) ? __fpclassifyd((double)(__x)) : __fpclassifyl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, int>::type
fpclassify(_A1 __x) throw()
{
    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isfinite(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isfinitef((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isfinited((double)(__x)) : __inline_isfinitel((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isfinite(_A1 __x) throw()
{
    return __libcpp_isfinite((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isinf(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isinff((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isinfd((double)(__x)) : __inline_isinfl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isinf(_A1 __x) throw()
{
    return __libcpp_isinf((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnan(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isnanf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isnand((double)(__x)) : __inline_isnanl((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnan(_A1 __x) throw()
{
    return __libcpp_isnan((typename std::__promote<_A1>::type)__x);
}







template <class _A1>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isnormal(_A1 __x) throw()
{
    return ( sizeof(__x) == sizeof(float) ? __inline_isnormalf((float)(__x)) : sizeof(__x) == sizeof(double) ? __inline_isnormald((double)(__x)) : __inline_isnormall((long double)(__x)));
}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type
isnormal(_A1 __x) throw()
{
    return __libcpp_isnormal((typename std::__promote<_A1>::type)__x);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreater((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isgreaterequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_isgreaterequal((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isgreaterequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isgreaterequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isless(_A1 __x, _A2 __y) throw()
{
    return __builtin_isless((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isless(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isless((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessequal(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessequal((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessequal(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessequal((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_islessgreater(_A1 __x, _A2 __y) throw()
{
    return __builtin_islessgreater((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
islessgreater(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_islessgreater((type)__x, (type)__y);
}







template <class _A1, class _A2>
__attribute__ ((__visibility__("hidden"), __always_inline__))
bool
__libcpp_isunordered(_A1 __x, _A2 __y) throw()
{
    return __builtin_isunordered((__x),(__y));
}



template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename std::enable_if
<
    std::is_arithmetic<_A1>::value &&
    std::is_arithmetic<_A2>::value,
    bool
>::type
isunordered(_A1 __x, _A2 __y) throw()
{
    typedef typename std::__promote<_A1, _A2>::type type;
    return __libcpp_isunordered((type)__x, (type)__y);
}



namespace std {inline namespace __1 {

using ::signbit;
using ::fpclassify;
using ::isfinite;
using ::isinf;
using ::isnan;
using ::isnormal;
using ::isgreater;
using ::isgreaterequal;
using ::isless;
using ::islessequal;
using ::islessgreater;
using ::isunordered;
using ::isunordered;

using ::float_t;
using ::double_t;




inline __attribute__ ((__visibility__("hidden"), __always_inline__))
float
abs(float __x) throw() {return fabsf(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
double
abs(double __x) throw() {return fabs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__))
long double
abs(long double __x) throw() {return fabsl(__x);}






using ::acos;
using ::acosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acos(float __x) throw() {return acosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acos(long double __x) throw() {return acosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acos(_A1 __x) throw() {return acos((double)__x);}



using ::asin;
using ::asinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asin(float __x) throw() {return asinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asin(long double __x) throw() {return asinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asin(_A1 __x) throw() {return asin((double)__x);}



using ::atan;
using ::atanf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan(float __x) throw() {return atanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan(long double __x) throw() {return atanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atan(_A1 __x) throw() {return atan((double)__x);}



using ::atan2;
using ::atan2f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atan2(float __y, float __x) throw() {return atan2f(__y, __x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atan2(long double __y, long double __x) throw() {return atan2l(__y, __x);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
atan2(_A1 __y, _A2 __x) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t740;

    return atan2((__result_type)__y, (__result_type)__x);
}



using ::ceil;
using ::ceilf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ceil(float __x) throw() {return ceilf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ceil(long double __x) throw() {return ceill(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ceil(_A1 __x) throw() {return ceil((double)__x);}



using ::cos;
using ::cosf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cos(float __x) throw() {return cosf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cos(long double __x) throw() {return cosl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cos(_A1 __x) throw() {return cos((double)__x);}



using ::cosh;
using ::coshf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cosh(float __x) throw() {return coshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cosh(long double __x) throw() {return coshl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cosh(_A1 __x) throw() {return cosh((double)__x);}




using ::exp;
using ::expf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp(float __x) throw() {return expf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp(long double __x) throw() {return expl(__x);}



template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp(_A1 __x) throw() {return exp((double)__x);}



using ::fabs;
using ::fabsf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fabs(float __x) throw() {return fabsf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fabs(long double __x) throw() {return fabsl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
fabs(_A1 __x) throw() {return fabs((double)__x);}



using ::floor;
using ::floorf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float floor(float __x) throw() {return floorf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double floor(long double __x) throw() {return floorl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
floor(_A1 __x) throw() {return floor((double)__x);}




using ::fmod;
using ::fmodf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmod(float __x, float __y) throw() {return fmodf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmod(long double __x, long double __y) throw() {return fmodl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmod(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t862;

    return fmod((__result_type)__x, (__result_type)__y);
}




using ::frexp;
using ::frexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float frexp(float __x, int* __e) throw() {return frexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double frexp(long double __x, int* __e) throw() {return frexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
frexp(_A1 __x, int* __e) throw() {return frexp((double)__x, __e);}



using ::ldexp;
using ::ldexpf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float ldexp(float __x, int __e) throw() {return ldexpf(__x, __e);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double ldexp(long double __x, int __e) throw() {return ldexpl(__x, __e);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
ldexp(_A1 __x, int __e) throw() {return ldexp((double)__x, __e);}




using ::log;
using ::logf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log(float __x) throw() {return logf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log(long double __x) throw() {return logl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log(_A1 __x) throw() {return log((double)__x);}




using ::log10;
using ::log10f;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log10(float __x) throw() {return log10f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log10(long double __x) throw() {return log10l(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log10(_A1 __x) throw() {return log10((double)__x);}



using ::modf;
using ::modff;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float modf(float __x, float* __y) throw() {return modff(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double modf(long double __x, long double* __y) throw() {return modfl(__x, __y);}





using ::pow;
using ::powf;




inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float pow(float __x, float __y) throw() {return powf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double pow(long double __x, long double __y) throw() {return powl(__x, __y);}


template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
pow(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t965;

    return pow((__result_type)__x, (__result_type)__y);
}



using ::sin;
using ::sinf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sin(float __x) throw() {return sinf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sin(long double __x) throw() {return sinl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sin(_A1 __x) throw() {return sin((double)__x);}



using ::sinh;
using ::sinhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sinh(float __x) throw() {return sinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sinh(long double __x) throw() {return sinhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sinh(_A1 __x) throw() {return sinh((double)__x);}




using ::sqrt;
using ::sqrtf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float sqrt(float __x) throw() {return sqrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double sqrt(long double __x) throw() {return sqrtl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
sqrt(_A1 __x) throw() {return sqrt((double)__x);}



using ::tan;
using ::tanf;



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tan(float __x) throw() {return tanf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tan(long double __x) throw() {return tanl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tan(_A1 __x) throw() {return tan((double)__x);}



using ::tanh;
using ::tanhf;


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tanh(float __x) throw() {return tanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tanh(long double __x) throw() {return tanhl(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tanh(_A1 __x) throw() {return tanh((double)__x);}




using ::acosh;
using ::acoshf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float acosh(float __x) throw() {return acoshf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double acosh(long double __x) throw() {return acoshl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
acosh(_A1 __x) throw() {return acosh((double)__x);}





using ::asinh;
using ::asinhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float asinh(float __x) throw() {return asinhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double asinh(long double __x) throw() {return asinhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
asinh(_A1 __x) throw() {return asinh((double)__x);}





using ::atanh;
using ::atanhf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float atanh(float __x) throw() {return atanhf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double atanh(long double __x) throw() {return atanhl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
atanh(_A1 __x) throw() {return atanh((double)__x);}





using ::cbrt;
using ::cbrtf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float cbrt(float __x) throw() {return cbrtf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double cbrt(long double __x) throw() {return cbrtl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
cbrt(_A1 __x) throw() {return cbrt((double)__x);}




using ::copysign;
using ::copysignf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float copysign(float __x, float __y) throw() {return copysignf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double copysign(long double __x, long double __y) throw() {return copysignl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
copysign(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1127;

    return copysign((__result_type)__x, (__result_type)__y);
}





using ::erf;
using ::erff;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erf(float __x) throw() {return erff(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erf(long double __x) throw() {return erfl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erf(_A1 __x) throw() {return erf((double)__x);}



using ::erfc;
using ::erfcf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float erfc(float __x) throw() {return erfcf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double erfc(long double __x) throw() {return erfcl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
erfc(_A1 __x) throw() {return erfc((double)__x);}



using ::exp2;
using ::exp2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float exp2(float __x) throw() {return exp2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double exp2(long double __x) throw() {return exp2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
exp2(_A1 __x) throw() {return exp2((double)__x);}



using ::expm1;
using ::expm1f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float expm1(float __x) throw() {return expm1f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double expm1(long double __x) throw() {return expm1l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
expm1(_A1 __x) throw() {return expm1((double)__x);}



using ::fdim;
using ::fdimf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fdim(float __x, float __y) throw() {return fdimf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fdim(long double __x, long double __y) throw() {return fdiml(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fdim(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1205;

    return fdim((__result_type)__x, (__result_type)__y);
}



inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmaf(float __x, float __y, float __z) throw() {return (float)((double)__x*__y + __z);}




using ::fma;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fma(float __x, float __y, float __z) throw() {return fmaf(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fma(long double __x, long double __y, long double __z) throw() {return fmal(__x, __y, __z);}

template <class _A1, class _A2, class _A3>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value &&
    is_arithmetic<_A3>::value,
    typename __promote<_A1, _A2, _A3>::type
>::type
fma(_A1 __x, _A2 __y, _A3 __z) throw()
{
    typedef typename __promote<_A1, _A2, _A3>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value && is_same<_A3, __result_type>::value)))>)> __t1235;


    return fma((__result_type)__x, (__result_type)__y, (__result_type)__z);
}



using ::fmax;
using ::fmaxf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmax(float __x, float __y) throw() {return fmaxf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmax(long double __x, long double __y) throw() {return fmaxl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmax(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1259;

    return fmax((__result_type)__x, (__result_type)__y);
}



using ::fmin;
using ::fminf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float fmin(float __x, float __y) throw() {return fminf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double fmin(long double __x, long double __y) throw() {return fminl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
fmin(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1283;

    return fmin((__result_type)__x, (__result_type)__y);
}



using ::hypot;
using ::hypotf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float hypot(float __x, float __y) throw() {return hypotf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double hypot(long double __x, long double __y) throw() {return hypotl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
hypot(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1307;

    return hypot((__result_type)__x, (__result_type)__y);
}



using ::ilogb;
using ::ilogbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(float __x) throw() {return ilogbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) int ilogb(long double __x) throw() {return ilogbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, int>::type
ilogb(_A1 __x) throw() {return ilogb((double)__x);}



using ::lgamma;
using ::lgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float lgamma(float __x) throw() {return lgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double lgamma(long double __x) throw() {return lgammal(__x);}


template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
lgamma(_A1 __x) throw() {return lgamma((double)__x);}




using ::llrint;
using ::llrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(float __x) throw() {return llrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llrint(long double __x) throw() {return llrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llrint(_A1 __x) throw() {return llrint((double)__x);}



using ::llround;
using ::llroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(float __x) throw() {return llroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long llround(long double __x) throw() {return llroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long long>::type
llround(_A1 __x) throw() {return llround((double)__x);}



using ::log1p;
using ::log1pf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log1p(float __x) throw() {return log1pf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log1p(long double __x) throw() {return log1pl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log1p(_A1 __x) throw() {return log1p((double)__x);}



using ::log2;
using ::log2f;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float log2(float __x) throw() {return log2f(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double log2(long double __x) throw() {return log2l(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
log2(_A1 __x) throw() {return log2((double)__x);}



using ::logb;
using ::logbf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float logb(float __x) throw() {return logbf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double logb(long double __x) throw() {return logbl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
logb(_A1 __x) throw() {return logb((double)__x);}



using ::lrint;
using ::lrintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(float __x) throw() {return lrintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lrint(long double __x) throw() {return lrintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lrint(_A1 __x) throw() {return lrint((double)__x);}



using ::lround;
using ::lroundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(float __x) throw() {return lroundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long lround(long double __x) throw() {return lroundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, long>::type
lround(_A1 __x) throw() {return lround((double)__x);}







using ::nan;
using ::nanf;







using ::nearbyint;
using ::nearbyintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nearbyint(float __x) throw() {return nearbyintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nearbyint(long double __x) throw() {return nearbyintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nearbyint(_A1 __x) throw() {return nearbyint((double)__x);}



using ::nextafter;
using ::nextafterf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nextafter(float __x, float __y) throw() {return nextafterf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nextafter(long double __x, long double __y) throw() {return nextafterl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
nextafter(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1476;

    return nextafter((__result_type)__x, (__result_type)__y);
}



using ::nexttoward;
using ::nexttowardf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float nexttoward(float __x, long double __y) throw() {return nexttowardf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double nexttoward(long double __x, long double __y) throw() {return nexttowardl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
nexttoward(_A1 __x, long double __y) throw() {return nexttoward((double)__x, __y);}



using ::remainder;
using ::remainderf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remainder(float __x, float __y) throw() {return remainderf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remainder(long double __x, long double __y) throw() {return remainderl(__x, __y);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remainder(_A1 __x, _A2 __y) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1513;

    return remainder((__result_type)__x, (__result_type)__y);
}



using ::remquo;
using ::remquof;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float remquo(float __x, float __y, int* __z) throw() {return remquof(__x, __y, __z);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double remquo(long double __x, long double __y, int* __z) throw() {return remquol(__x, __y, __z);}

template <class _A1, class _A2>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if
<
    is_arithmetic<_A1>::value &&
    is_arithmetic<_A2>::value,
    typename __promote<_A1, _A2>::type
>::type
remquo(_A1 __x, _A2 __y, int* __z) throw()
{
    typedef typename __promote<_A1, _A2>::type __result_type;
    typedef __static_assert_check<sizeof(__static_assert_test<((!(is_same<_A1, __result_type>::value && is_same<_A2, __result_type>::value)))>)> __t1537;

    return remquo((__result_type)__x, (__result_type)__y, __z);
}



using ::rint;
using ::rintf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float rint(float __x) throw() {return rintf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double rint(long double __x) throw() {return rintl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
rint(_A1 __x) throw() {return rint((double)__x);}



using ::round;
using ::roundf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float round(float __x) throw() {return roundf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double round(long double __x) throw() {return roundl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
round(_A1 __x) throw() {return round((double)__x);}



using ::scalbln;
using ::scalblnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbln(float __x, long __y) throw() {return scalblnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbln(long double __x, long __y) throw() {return scalblnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbln(_A1 __x, long __y) throw() {return scalbln((double)__x, __y);}



using ::scalbn;
using ::scalbnf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float scalbn(float __x, int __y) throw() {return scalbnf(__x, __y);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double scalbn(long double __x, int __y) throw() {return scalbnl(__x, __y);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
scalbn(_A1 __x, int __y) throw() {return scalbn((double)__x, __y);}



using ::tgamma;
using ::tgammaf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float tgamma(float __x) throw() {return tgammaf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double tgamma(long double __x) throw() {return tgammal(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
tgamma(_A1 __x) throw() {return tgamma((double)__x);}



using ::trunc;
using ::truncf;

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) float trunc(float __x) throw() {return truncf(__x);}
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long double trunc(long double __x) throw() {return truncl(__x);}

template <class _A1>
inline __attribute__ ((__visibility__("hidden"), __always_inline__))
typename enable_if<is_integral<_A1>::value, double>::type
trunc(_A1 __x) throw() {return trunc((double)__x);}



using ::acosl;
using ::asinl;
using ::atanl;
using ::atan2l;
using ::ceill;
using ::cosl;
using ::coshl;
using ::expl;
using ::fabsl;
using ::floorl;
using ::fmodl;
using ::frexpl;
using ::ldexpl;
using ::logl;
using ::log10l;
using ::modfl;
using ::powl;
using ::sinl;
using ::sinhl;
using ::sqrtl;
using ::tanl;

using ::tanhl;
using ::acoshl;
using ::asinhl;
using ::atanhl;
using ::cbrtl;

using ::copysignl;

using ::erfl;
using ::erfcl;
using ::exp2l;
using ::expm1l;
using ::fdiml;
using ::fmal;
using ::fmaxl;
using ::fminl;
using ::hypotl;
using ::ilogbl;
using ::lgammal;
using ::llrintl;
using ::llroundl;
using ::log1pl;
using ::log2l;
using ::logbl;
using ::lrintl;
using ::lroundl;
using ::nanl;
using ::nearbyintl;
using ::nextafterl;
using ::nexttowardl;
using ::remainderl;
using ::remquol;
using ::rintl;
using ::roundl;
using ::scalblnl;
using ::scalbnl;
using ::tgammal;
using ::truncl;






} }
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_fixes.hpp" 2
# 78 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2






# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 1 3
# 42 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 1 3 4
# 38 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/limits.h" 1 3 4
# 64 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/limits.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/limits.h" 1 3 4





# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/limits.h" 1 3 4
# 40 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/limits.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_limits.h" 1 3 4
# 41 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/limits.h" 2 3 4
# 7 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/limits.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/limits.h" 2 3 4
# 39 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h" 2 3 4
# 43 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 2 3
# 46 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/climits" 3
# 84 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 1 3
# 64 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/float.h" 1 3 4
# 65 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 2 3
# 68 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cfloat" 3
# 85 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 1 3
# 107 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3





# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__undef_min_max" 1 3
# 113 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 2 3
# 122 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/limits" 3
namespace std {inline namespace __1 {

enum float_round_style
{
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
};

enum float_denorm_style
{
    denorm_indeterminate = -1,
    denorm_absent = 0,
    denorm_present = 1
};

template <class _Tp, bool = is_arithmetic<_Tp>::value>
class __libcpp_numeric_limits
{
protected:
    typedef _Tp type;

    static const bool is_specialized = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return type();}

    static const int digits = 0;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const bool is_signed = false;
    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 0;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type();}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type();}

    static const bool is_iec559 = false;
    static const bool is_bounded = false;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <class _Tp, int digits, bool is_signed>
struct __libcpp_compute_min
{
    static const _Tp value = _Tp(_Tp(1) << digits);
};

template <class _Tp, int digits>
struct __libcpp_compute_min<_Tp, digits, false>
{
    static const _Tp value = _Tp(0);
};

template <class _Tp>
class __libcpp_numeric_limits<_Tp, true>
{
protected:
    typedef _Tp type;

    static const bool is_specialized = true;

    static const bool is_signed = type(-1) < type(0);
    static const int digits = static_cast<int>(sizeof(type) * 8 - is_signed);
    static const int digits10 = digits * 3 / 10;
    static const int max_digits10 = 0;
    static const type __min = __libcpp_compute_min<type, digits, is_signed>::value;
    static const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = true;


    static const bool traps = true;



    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<bool, true>
{
protected:
    typedef bool type;

    static const bool is_specialized = true;

    static const bool is_signed = false;
    static const int digits = 1;
    static const int digits10 = 0;
    static const int max_digits10 = 0;
    static const type __min = false;
    static const type __max = true;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __min;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __max;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return min();}

    static const bool is_integer = true;
    static const bool is_exact = true;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return type(0);}

    static const int min_exponent = 0;
    static const int min_exponent10 = 0;
    static const int max_exponent = 0;
    static const int max_exponent10 = 0;

    static const bool has_infinity = false;
    static const bool has_quiet_NaN = false;
    static const bool has_signaling_NaN = false;
    static const float_denorm_style has_denorm = denorm_absent;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return type(0);}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return type(0);}

    static const bool is_iec559 = false;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_toward_zero;
};

template <>
class __libcpp_numeric_limits<float, true>
{
protected:
    typedef float type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 24;
    static const int digits10 = 6;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 1.17549435e-38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 3.40282347e+38F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.19209290e-7F;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5F;}

    static const int min_exponent = (-125);
    static const int min_exponent10 = (-37);
    static const int max_exponent = 128;
    static const int max_exponent10 = 38;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_valf();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansf("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 1.40129846e-45F;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<double, true>
{
protected:
    typedef double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 53;
    static const int digits10 = 15;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 2.2250738585072014e-308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.7976931348623157e+308;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 2.2204460492503131e-16;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-1021);
    static const int min_exponent10 = (-307);
    static const int max_exponent = 1024;
    static const int max_exponent10 = 308;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_val();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nan("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nans("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 4.9406564584124654e-324;}

    static const bool is_iec559 = true;
    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <>
class __libcpp_numeric_limits<long double, true>
{
protected:
    typedef long double type;

    static const bool is_specialized = true;

    static const bool is_signed = true;
    static const int digits = 64;
    static const int digits10 = 18;
    static const int max_digits10 = 2+(digits * 30103)/100000;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return 3.36210314311209350626e-4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return 1.18973149535723176502e+4932L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return -max();}

    static const bool is_integer = false;
    static const bool is_exact = false;
    static const int radix = 2;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return 1.08420217248550443401e-19L;}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return 0.5;}

    static const int min_exponent = (-16381);
    static const int min_exponent10 = (-4931);
    static const int max_exponent = 16384;
    static const int max_exponent10 = 4932;

    static const bool has_infinity = true;
    static const bool has_quiet_NaN = true;
    static const bool has_signaling_NaN = true;
    static const float_denorm_style has_denorm = denorm_present;
    static const bool has_denorm_loss = false;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __builtin_huge_vall();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __builtin_nanl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __builtin_nansl("");}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return 3.64519953188247460253e-4951L;}




    static const bool is_iec559 = true;

    static const bool is_bounded = true;
    static const bool is_modulo = false;

    static const bool traps = false;
    static const bool tinyness_before = false;
    static const float_round_style round_style = round_to_nearest;
};

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits
    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>
{
    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;
    typedef typename __base::type type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<_Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits;
template <class _Tp>
                      const int numeric_limits<_Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<_Tp>::radix;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<_Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<_Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<_Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<_Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<_Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<_Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<_Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::digits10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<volatile _Tp>::round_style;

template <class _Tp>
class __attribute__ ((__type_visibility__("default"))) numeric_limits<const volatile _Tp>
    : private numeric_limits<_Tp>
{
    typedef numeric_limits<_Tp> __base;
    typedef _Tp type;
public:
    static const bool is_specialized = __base::is_specialized;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type min() throw() {return __base::min();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type max() throw() {return __base::max();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type lowest() throw() {return __base::lowest();}

    static const int digits = __base::digits;
    static const int digits10 = __base::digits10;
    static const int max_digits10 = __base::max_digits10;
    static const bool is_signed = __base::is_signed;
    static const bool is_integer = __base::is_integer;
    static const bool is_exact = __base::is_exact;
    static const int radix = __base::radix;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type epsilon() throw() {return __base::epsilon();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type round_error() throw() {return __base::round_error();}

    static const int min_exponent = __base::min_exponent;
    static const int min_exponent10 = __base::min_exponent10;
    static const int max_exponent = __base::max_exponent;
    static const int max_exponent10 = __base::max_exponent10;

    static const bool has_infinity = __base::has_infinity;
    static const bool has_quiet_NaN = __base::has_quiet_NaN;
    static const bool has_signaling_NaN = __base::has_signaling_NaN;
    static const float_denorm_style has_denorm = __base::has_denorm;
    static const bool has_denorm_loss = __base::has_denorm_loss;
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type infinity() throw() {return __base::infinity();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type quiet_NaN() throw() {return __base::quiet_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type signaling_NaN() throw() {return __base::signaling_NaN();}
    __attribute__ ((__visibility__("hidden"), __always_inline__)) static type denorm_min() throw() {return __base::denorm_min();}

    static const bool is_iec559 = __base::is_iec559;
    static const bool is_bounded = __base::is_bounded;
    static const bool is_modulo = __base::is_modulo;

    static const bool traps = __base::traps;
    static const bool tinyness_before = __base::tinyness_before;
    static const float_round_style round_style = __base::round_style;
};

template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_specialized;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::digits10;
template <class _Tp>
    const int numeric_limits<const volatile _Tp>::max_digits10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_signed;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_integer;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_exact;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::radix;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::min_exponent10;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent;
template <class _Tp>
                      const int numeric_limits<const volatile _Tp>::max_exponent10;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_infinity;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;
template <class _Tp>
                      const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::has_denorm_loss;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_iec559;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_bounded;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::is_modulo;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::traps;
template <class _Tp>
                      const bool numeric_limits<const volatile _Tp>::tinyness_before;
template <class _Tp>
                      const float_round_style numeric_limits<const volatile _Tp>::round_style;

} }
# 86 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 1 3
# 104 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
# 123 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdio" 3
namespace std {inline namespace __1 {

using ::FILE;
using ::fpos_t;
using ::size_t;

using ::remove;
using ::rename;
using ::tmpfile;
using ::tmpnam;
using ::fclose;
using ::fflush;
using ::fopen;
using ::freopen;
using ::setbuf;
using ::setvbuf;
using ::fprintf;
using ::fscanf;
using ::printf;
using ::scanf;
using ::snprintf;
using ::sprintf;
using ::sscanf;

using ::vfprintf;
using ::vfscanf;
using ::vscanf;
using ::vsscanf;

using ::vprintf;
using ::vsnprintf;
using ::vsprintf;
using ::fgetc;
using ::fgets;
using ::fputc;
using ::fputs;
using ::getc;
using ::getchar;

using ::gets;

using ::putc;
using ::putchar;
using ::puts;
using ::ungetc;
using ::fread;
using ::fwrite;
using ::fgetpos;
using ::fseek;
using ::fsetpos;
using ::ftell;
using ::rewind;
using ::clearerr;
using ::feof;
using ::ferror;
using ::perror;

} }
# 87 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/setup.hpp" 1
# 89 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2







# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp" 1
# 33 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/assert.h" 1 3 4
# 75 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((noreturn));



}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 2 3
# 25 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cassert" 3
# 33 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp" 2





namespace glm{
namespace detail
{
 class half;
# 50 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 __extension__ typedef signed long long sint64;
 __extension__ typedef unsigned long long uint64;
# 60 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 template<bool C>
 struct If
 {
  template<typename F, typename T>
  static inline T apply(F functor, const T& val)
  {
   return functor(val);
  }
 };

 template<>
 struct If<false>
 {
  template<typename F, typename T>
  static inline T apply(F, const T& val)
  {
   return val;
  }
 };
# 133 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 union uif32
 { inline
                     uif32() :
   i(0)
  {} inline

                     uif32(float f) :
   f(f)
  {} inline

                     uif32(unsigned int i) :
   i(i)
  {}

  float f;
  unsigned int i;
 };

 union uif64
 { inline
                     uif64() :
   i(0)
  {} inline

                     uif64(double f) :
   f(f)
  {} inline

                     uif64(uint64 i) :
   i(i)
  {}

  double f;
  uint64 i;
 };

 typedef uif32 uif;




 template <typename T>
 struct is_int
 {
  enum is_int_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 198 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 template <typename T>
 struct is_uint
 {
  enum is_uint_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 224 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 template <typename T>
 struct is_float
 {
  enum is_float_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 245 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 template <> struct is_float<detail::half> { enum is_float_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_float<float> { enum is_float_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_float<double> { enum is_float_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_float<long double> { enum is_float_enum { _YES = 1, _NO = 0 }; };




 template <typename T>
 struct is_bool
 {
  enum is_bool_enum
  {
   _YES = 0,
   _NO = 1
  };
 };

 template <>
 struct is_bool<bool>
 {
  enum is_bool_enum
  {
   _YES = 1,
   _NO = 0
  };
 };




 template <typename T>
 struct is_vector
 {
  enum is_vector_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 300 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 template <typename T>
 struct is_matrix
 {
  enum is_matrix_enum
  {
   _YES = 0,
   _NO = 1
  };
 };
# 324 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_detail.hpp"
 template <typename T>
 struct type
 {
  enum type_enum
  {
   is_float = is_float<T>::_YES,
   is_int = is_int<T>::_YES,
   is_uint = is_uint<T>::_YES,
   is_bool = is_bool<T>::_YES
  };
 };




 typedef signed char int8;
 typedef signed short int16;
 typedef signed int int32;
 typedef detail::sint64 int64;

 typedef unsigned char uint8;
 typedef unsigned short uint16;
 typedef unsigned int uint32;
 typedef detail::uint64 uint64;

 typedef detail::half float16;
 typedef float float32;
 typedef double float64;




 struct float_or_int_value
 {
  enum
  {
   GLM_ERROR,
   GLM_FLOAT,
   GLM_INT
  };
 };

 template <typename T>
 struct float_or_int_trait
 {
  enum{ID = float_or_int_value::GLM_ERROR};
 };

 template <>
 struct float_or_int_trait<int8>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<int16>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<int32>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<int64>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint8>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint16>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint32>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<uint64>
 {
  enum{ID = float_or_int_value::GLM_INT};
 };

 template <>
 struct float_or_int_trait<float16>
 {
  enum{ID = float_or_int_value::GLM_FLOAT};
 };

 template <>
 struct float_or_int_trait<float32>
 {
  enum{ID = float_or_int_value::GLM_FLOAT};
 };

 template <>
 struct float_or_int_trait<float64>
 {
  enum{ID = float_or_int_value::GLM_FLOAT};
 };

}
}
# 96 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/_vectorize.hpp" 1
# 97 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 1
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp"
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.hpp" 1
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.hpp"
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 1 3
# 93 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3


namespace std {inline namespace __1 {

using ::size_t;
using ::div_t;
using ::ldiv_t;

using ::lldiv_t;

using ::atof;
using ::atoi;
using ::atol;

using ::atoll;

using ::strtod;
using ::strtof;
using ::strtold;
using ::strtol;

using ::strtoll;

using ::strtoul;

using ::strtoull;

using ::rand;
using ::srand;
using ::calloc;
using ::free;
using ::malloc;
using ::realloc;
using ::abort;
using ::atexit;
using ::exit;
using ::_Exit;
using ::getenv;
using ::system;
using ::bsearch;
using ::qsort;
using ::abs;
using ::labs;

using ::llabs;

using ::div;
using ::ldiv;

using ::lldiv;

using ::mblen;
using ::mbtowc;
using ::wctomb;
using ::mbstowcs;
using ::wcstombs;
# 159 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/cstdlib" 3
inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long abs( long __x) throw() {return labs(__x);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) long long abs(long long __x) throw() {return llabs(__x);}


inline __attribute__ ((__visibility__("hidden"), __always_inline__)) ldiv_t div( long __x, long __y) throw() {return ldiv(__x, __y);}

inline __attribute__ ((__visibility__("hidden"), __always_inline__)) lldiv_t div(long long __x, long long __y) throw() {return lldiv(__x, __y);}



} }
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.hpp" 2


namespace glm{
namespace detail
{
 typedef short hdata;

 float toFloat32(hdata value);
 hdata toFloat16(float const & value);

 class half
 {
 public:

                half();
                half(half const & s);

  template <typename U>
                explicit half(U const & s);


  template <typename U>
                operator U() const;


                half& operator= (half const & s);
                half& operator+=(half const & s);
                half& operator-=(half const & s);
                half& operator*=(half const & s);
                half& operator/=(half const & s);
                half& operator++();
                half& operator--();

                float toFloat() const{return toFloat32(data);}

                hdata _data() const{return data;}

 private:
  hdata data;
 };

 half operator+ (half const & s1, half const & s2);

 half operator- (half const & s1, half const & s2);

 half operator* (half const & s1, half const & s2);

 half operator/ (half const & s1, half const & s2);


 half operator- (half const & s);

 half operator-- (half const & s, int);

 half operator++ (half const & s, int);

 bool operator==(
  detail::half const & x,
  detail::half const & y);

 bool operator!=(
  detail::half const & x,
  detail::half const & y);

 bool operator<(
  detail::half const & x,
  detail::half const & y);

 bool operator<=(
  detail::half const & x,
  detail::half const & y);

 bool operator>(
  detail::half const & x,
  detail::half const & y);

 bool operator>=(
  detail::half const & x,
  detail::half const & y);

}
}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl" 1
# 35 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl"
namespace glm{
namespace detail
{ inline
                    float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f *= f;

  return f;
 } inline

                    float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif result;
    result.i = (unsigned int)(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif result;
    result.i = (unsigned int)((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif result;
    result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif Result;
  Result.i = (unsigned int)((s << 31) | (e << 23) | m);
  return Result.f;
 } inline

                    hdata toFloat16(float const & f)
 {
  uif Entry;
  Entry.f = f;
  int i = (int)Entry.i;
# 138 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl"
  register int s = (i >> 16) & 0x00008000;
  register int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  register int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 158 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl"
    return 0;
   }
# 168 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl"
   m = (m | 0x00800000) >> (1 - e);
# 179 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl"
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 210 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl"
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 226 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.inl"
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 } inline

                    half::half() :
  data(0)
 {} inline

                    half::half(half const & s) :
  data(s.data)
 {}

 template <typename U> inline
                    half::half(U const & s) :
  data(toFloat16(float(s)))
 {}

 template <typename U> inline
                    half::operator U() const
 {
  return static_cast<U>(toFloat32(this->data));
 } inline


                    half& half::operator= (half const & s)
 {
  data = s.data;
  return *this;
 } inline

                    half& half::operator+=(half const & s)
 {
  data = toFloat16(toFloat32(data) + toFloat32(s.data));
  return *this;
 } inline

                    half& half::operator-=(half const & s)
 {
  data = toFloat16(toFloat32(data) - toFloat32(s.data));
  return *this;
 } inline

                    half& half::operator*=(half const & s)
 {
  data = toFloat16(toFloat32(data) * toFloat32(s.data));
  return *this;
 } inline

                    half& half::operator/=(half const & s)
 {
  data = toFloat16(toFloat32(data) / toFloat32(s.data));
  return *this;
 } inline

                    half& half::operator++()
 {
  float Casted = toFloat32(data);
  this->data = toFloat16(++Casted);
  return *this;
 } inline

                    half& half::operator--()
 {
  float Casted = toFloat32(data);
  this->data = toFloat16(--Casted);
  return *this;
 } inline




                    detail::half operator+ (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) + float(s2));
 } inline

                    detail::half operator- (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) - float(s2));
 } inline

                    detail::half operator* (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) * float(s2));
 } inline

                    detail::half operator/ (detail::half const & s1, detail::half const & s2)
 {
  return detail::half(float(s1) / float(s2));
 } inline


                    detail::half operator- (detail::half const & s)
 {
  return detail::half(-float(s));
 } inline

                    detail::half operator-- (detail::half const & s, int)
 {
  return detail::half(float(s) - 1.0f);
 } inline

                    detail::half operator++ (detail::half const & s, int)
 {
  return detail::half(float(s) + 1.0f);
 } inline

                    bool operator==
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return x._data() == y._data();
 } inline

                    bool operator!=
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return x._data() != y._data();
 } inline

                    bool operator<
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) < float(y);
 } inline

                    bool operator<=
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) <= float(y);
 } inline

                    bool operator>
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) > float(y);
 } inline

                    bool operator>=
 (
  detail::half const & x,
  detail::half const & y
 )
 {
  return float(x) >= float(y);
 }

}
}
# 115 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_half.hpp" 2
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_float.hpp" 1
# 35 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_float.hpp"
namespace glm
{



 typedef float lowp_float_t;

 typedef float mediump_float_t;
 typedef double highp_float_t;
# 53 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_float.hpp"
 typedef lowp_float_t lowp_float;






 typedef mediump_float_t mediump_float;






 typedef highp_float_t highp_float;


 typedef mediump_float float_t;
# 82 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_float.hpp"
}
# 33 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_int.hpp" 1
# 35 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_int.hpp"
namespace glm{
namespace detail
{
 typedef signed short lowp_int_t;
 typedef signed int mediump_int_t;
 typedef sint64 highp_int_t;

 typedef unsigned short lowp_uint_t;
 typedef unsigned int mediump_uint_t;
 typedef uint64 highp_uint_t;

 template <> struct is_int<signed char> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<signed short> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<signed int> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<signed long> { enum is_int_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_int<highp_int_t> { enum is_int_enum { _YES = 1, _NO = 0 }; };

 template <> struct is_uint<unsigned char> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<unsigned short> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<unsigned int> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<unsigned long> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
 template <> struct is_uint<highp_uint_t> { enum is_uint_enum { _YES = 1, _NO = 0 }; };
}
# 67 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_int.hpp"
 typedef detail::lowp_int_t lowp_int;






 typedef detail::mediump_int_t mediump_int;






 typedef detail::highp_int_t highp_int;






 typedef detail::lowp_uint_t lowp_uint;






 typedef detail::mediump_uint_t mediump_uint;






 typedef detail::highp_uint_t highp_uint;


 typedef mediump_int int_t;
# 117 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_int.hpp"
 typedef mediump_uint uint_t;
# 131 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_int.hpp"
 typedef uint_t uint;


}
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_gentype.hpp" 1
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_gentype.hpp"
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_size.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_size.hpp"
namespace glm{
namespace detail
{

 typedef int sizeType;

}
}
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_gentype.hpp" 2


namespace glm
{
 enum profile
 {
  nice,
  fast,
  simd
 };

namespace detail
{
 template
 <
  typename VALTYPE,
  template <typename> class TYPE
 >
 struct genType
 {
 public:
  enum ctor{null};

  typedef VALTYPE value_type;
  typedef VALTYPE & value_reference;
  typedef VALTYPE * value_pointer;
  typedef VALTYPE const * value_const_pointer;
  typedef TYPE<bool> bool_type;

  typedef sizeType size_type;
  static bool is_vector();
  static bool is_matrix();

  typedef TYPE<VALTYPE> type;
  typedef TYPE<VALTYPE> * pointer;
  typedef TYPE<VALTYPE> const * const_pointer;
  typedef TYPE<VALTYPE> const * const const_pointer_const;
  typedef TYPE<VALTYPE> * const pointer_const;
  typedef TYPE<VALTYPE> & reference;
  typedef TYPE<VALTYPE> const & const_reference;
  typedef TYPE<VALTYPE> const & param_type;




  value_const_pointer value_address() const{return value_pointer(this);}
  value_pointer value_address(){return value_pointer(this);}
# 89 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_gentype.hpp"
 };

 template
 <
  typename VALTYPE,
  template <typename> class TYPE
 >
 bool genType<VALTYPE, TYPE>::is_vector()
 {
  return true;
 }
# 164 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_gentype.hpp"
 }
}
# 36 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.hpp" 1
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.hpp"
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec.hpp"
namespace glm{
namespace detail
{

}
}
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.hpp" 2




# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_swizzle.hpp" 1
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_swizzle.hpp"
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_swizzle_func.hpp" 1
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_swizzle.hpp" 2


namespace glm
{
 enum comp
 {
  X = 0,
  R = 0,
  S = 0,
  Y = 1,
  G = 1,
  T = 1,
  Z = 2,
  B = 2,
  P = 2,
  W = 3,
  A = 3,
  Q = 3
 };
}

namespace glm{
namespace detail
{

 template <typename T, int N>
 struct _swizzle_base0
 {
  typedef T value_type;

 protected:
  value_type& elem (size_t i) { return (reinterpret_cast<value_type*>(_buffer))[i]; }
  const value_type& elem (size_t i) const { return (reinterpret_cast<const value_type*>(_buffer))[i]; }




  char _buffer[1];
 };

 template <typename T, typename V, int E0, int E1, int E2, int E3, int N>
 struct _swizzle_base1 : public _swizzle_base0<T,N>
 {
 };

 template <typename T, typename V, int E0, int E1>
 struct _swizzle_base1<T,V,E0,E1,-1,-2,2> : public _swizzle_base0<T,2>
 {
  V operator ()() const { return V(this->elem(E0), this->elem(E1)); }
 };

 template <typename T, typename V, int E0, int E1, int E2>
 struct _swizzle_base1<T,V,E0,E1,E2,-1,3> : public _swizzle_base0<T,3>
 {
  V operator ()() const { return V(this->elem(E0), this->elem(E1), this->elem(E2)); }
 };

 template <typename T, typename V, int E0, int E1, int E2, int E3>
 struct _swizzle_base1<T,V,E0,E1,E2,E3,4> : public _swizzle_base0<T,4>
 {
  V operator ()() const { return V(this->elem(E0), this->elem(E1), this->elem(E2), this->elem(E3)); }
 };
# 107 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_swizzle.hpp"
 template <typename ValueType, typename VecType, int N, int E0, int E1, int E2, int E3, int DUPLICATE_ELEMENTS>
 struct _swizzle_base2 : public _swizzle_base1<ValueType,VecType,E0,E1,E2,E3,N>
 {
  typedef VecType vec_type;
  typedef ValueType value_type;

  _swizzle_base2& operator= (const ValueType& t)
  {
   for (int i = 0; i < N; ++i)
    (*this)[i] = t;
   return *this;
  }

  _swizzle_base2& operator= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e = t; }
   };
   _apply_op(that, op());
   return *this;
  }

  void operator -= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e -= t; }
   };
   _apply_op(that, op());
  }

  void operator += (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e += t; }
   };
   _apply_op(that, op());
  }

  void operator *= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e *= t; }
   };
   _apply_op(that, op());
  }

  void operator /= (const VecType& that)
  {
   struct op {
    void operator() (value_type& e, value_type& t) { e /= t; }
   };
   _apply_op(that, op());
  }

  value_type& operator[] (size_t i)
  {
   static const int offset_dst[4] = { E0, E1, E2, E3 };
   return this->elem(offset_dst[i]);
  }
  value_type operator[] (size_t i) const
  {
   static const int offset_dst[4] = { E0, E1, E2, E3 };
   return this->elem(offset_dst[i]);
  }
 protected:
  template <typename T>
  void _apply_op(const VecType& that, T op)
  {



   ValueType t[N];
   for (int i = 0; i < N; ++i)
    t[i] = that[i];
   for (int i = 0; i < N; ++i)
    op( (*this)[i], t[i] );
  }
 };


 template <typename ValueType, typename VecType, int N, int E0, int E1, int E2, int E3>
 struct _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,1> : public _swizzle_base1<ValueType,VecType,E0,E1,E2,E3,N>
 {
  typedef VecType vec_type;
  typedef ValueType value_type;

  struct Stub {};
  _swizzle_base2& operator= (Stub const &) {}

  value_type operator[] (size_t i) const
  {
   static const int offset_dst[4] = { E0, E1, E2, E3 };
   return this->elem(offset_dst[i]);
  }
 };

 template <int N,typename ValueType, typename VecType, int E0,int E1,int E2,int E3>
 struct swizzle : public _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,(E0==E1||E0==E2||E0==E3||E1==E2||E1==E3||E2==E3)>
 {
  typedef _swizzle_base2<ValueType,VecType,N,E0,E1,E2,E3,(E0==E1||E0==E2||E0==E3||E1==E2||E1==E3||E2==E3)> base_type;

  using base_type::operator=;

  operator VecType () const { return (*this)(); }
 };
# 316 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_swizzle.hpp"
}
}

namespace glm
{
 namespace detail
 {
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const T& b) { return a() - b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const T& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a - b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const T& b) { return a() * b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const T& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a * b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator + ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() + b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator + ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() + b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator + ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a + b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() - b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() - b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator - ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a - b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() * b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() * b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator * ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a * b(); }
  template <int N, typename T, typename V, int E0, int E1, int E2, int E3, int F0, int F1, int F2, int F3> V operator / ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const glm::detail::swizzle<N,T,V,F0,F1,F2,F3>& b) { return a() / b(); } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator / ( const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& a, const V& b) { return a() / b; } template <int N, typename T, typename V, int E0, int E1, int E2, int E3> V operator / ( const V& a, const glm::detail::swizzle<N,T,V,E0,E1,E2,E3>& b) { return a / b(); }
 }
# 351 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_swizzle.hpp"
}
# 36 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.hpp" 2


namespace glm{
namespace detail
{
 template <typename T> struct tref1;
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;

 template <typename T>
 struct tvec1
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec1<T> type;
  typedef tvec1<bool> bool_type;

                              size_type length() const;







   union {value_type x, r, s;};





                value_type & operator[](size_type i);
                value_type const & operator[](size_type i) const;




                tvec1();
                tvec1(tvec1<T> const & v);




                explicit tvec1(
   ctor);
                explicit tvec1(
   value_type const & s);




                tvec1(tref1<T> const & r);





  template <typename U>
                explicit tvec1(U const & s);





  template <typename U>
                explicit tvec1(tvec2<U> const & v);

  template <typename U>
                explicit tvec1(tvec3<U> const & v);

  template <typename U>
                explicit tvec1(tvec4<U> const & v);




                tvec1<T> & operator= (tvec1<T> const & v);
  template <typename U>
                tvec1<T> & operator= (tvec1<U> const & v);

  template <typename U>
                tvec1<T> & operator+=(U const & s);
  template <typename U>
                tvec1<T> & operator+=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator-=(U const & s);
  template <typename U>
                tvec1<T> & operator-=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator*=(U const & s);
  template <typename U>
                tvec1<T> & operator*=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator/=(U const & s);
  template <typename U>
                tvec1<T> & operator/=(tvec1<U> const & v);
                tvec1<T> & operator++();
                tvec1<T> & operator--();




  template <typename U>
                tvec1<T> & operator%=(U const & s);
  template <typename U>
                tvec1<T> & operator%=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator&=(U const & s);
  template <typename U>
                tvec1<T> & operator&=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator|=(U const & s);
  template <typename U>
                tvec1<T> & operator|=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator^=(U const & s);
  template <typename U>
                tvec1<T> & operator^=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator<<=(U const & s);
  template <typename U>
                tvec1<T> & operator<<=(tvec1<U> const & v);
  template <typename U>
                tvec1<T> & operator>>=(U const & s);
  template <typename U>
                tvec1<T> & operator>>=(tvec1<U> const & v);




                value_type swizzle(comp X) const;
                tvec2<T> swizzle(comp X, comp Y) const;
                tvec3<T> swizzle(comp X, comp Y, comp Z) const;
                tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
                tref1<T> swizzle(comp X);
 };

 template <typename T>
 struct tref1
 {
                tref1(T & x);
                tref1(tref1<T> const & r);
                tref1(tvec1<T> const & v);

                tref1<T> & operator= (tref1<T> const & r);
                tref1<T> & operator= (tvec1<T> const & v);

  T& x;
 };

 template <typename T> struct is_vector<tvec1<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };

 typedef detail::tvec1<highp_float> highp_vec1_t;
 typedef detail::tvec1<mediump_float> mediump_vec1_t;
 typedef detail::tvec1<lowp_float> lowp_vec1_t;
 typedef detail::tvec1<highp_int> highp_ivec1_t;
 typedef detail::tvec1<mediump_int> mediump_ivec1_t;
 typedef detail::tvec1<lowp_int> lowp_ivec1_t;
 typedef detail::tvec1<highp_uint> highp_uvec1_t;
 typedef detail::tvec1<mediump_uint> mediump_uvec1_t;
 typedef detail::tvec1<lowp_uint> lowp_uvec1_t;

}
}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tvec1<T>::size_type tvec1<T>::length() const
 {
  return 1;
 }




 template <typename T> inline
                    typename tvec1<T>::value_type & tvec1<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.inl", 47, "i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T> inline
                    typename tvec1<T>::value_type const & tvec1<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.inl", 57, "i < this->length()") : (void)0);
  return (&x)[i];
 }




 template <typename T> inline
                    tvec1<T>::tvec1() :
  x(value_type(0))
 {}

 template <typename T> inline
                    tvec1<T>::tvec1
 (
  ctor
 )
 {}

 template <typename T> inline
                    tvec1<T>::tvec1
 (
  tvec1<T> const & v
 ) :
  x(v.x)
 {}




 template <typename T> inline
                    tvec1<T>::tvec1
 (
  value_type const & s
 ) :
  x(s)
 {}




 template <typename T> inline
                    tvec1<T>::tvec1
 (
  tref1<T> const & r
 ) :
  x(r.x)
 {}




 template <typename T>
 template <typename U> inline
                    tvec1<T>::tvec1
 (
  U const & s
 ) :
  x(value_type(s))
 {}




 template <typename T>
 template <typename U> inline
                    tvec1<T>::tvec1
 (
  tvec2<U> const & v
 ) :
  x(value_type(v.x))
 {}

 template <typename T>
 template <typename U> inline
                    tvec1<T>::tvec1
 (
  tvec3<U> const & v
 ) :
  x(value_type(v.x))
 {}

 template <typename T>
 template <typename U> inline
                    tvec1<T>::tvec1
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x))
 {}




 template <typename T> inline
                    tvec1<T> & tvec1<T>::operator=
 (
  tvec1<T> const & v
 )
 {
  this->x = v.x;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator=
 (
  tvec1<U> const & v
 )
 {
  this->x = T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator+=
 (
  tvec1<U> const & v
 )
 {
  this->x += T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator-=
 (
  tvec1<U> const & v
 )
 {
  this->x -= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator*=
 (
  tvec1<U> const & v
 )
 {
  this->x *= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator/=
 (
  tvec1<U> const & v
 )
 {
  this->x /= T(v.x);
  return *this;
 }

 template <typename T> inline
                    tvec1<T> & tvec1<T>::operator++()
 {
  ++this->x;
  return *this;
 }

 template <typename T> inline
                    tvec1<T> & tvec1<T>::operator--()
 {
  --this->x;
  return *this;
 }




 template <typename T> inline
                    bool operator==
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return (v1.x == v2.x);
 }

 template <typename T> inline
                    bool operator!=
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return (v1.x != v2.x);
 }




 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator%=
 (
  tvec1<U> const & v
 )
 {
  this->x %= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator&=
 (
  tvec1<U> const & v
 )
 {
  this->x &= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator|=
 (
  tvec1<U> const & v
 )
 {
  this->x |= U(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator^=
 (
  tvec1<U> const & v
 )
 {
  this->x ^= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator<<=
 (
  tvec1<U> const & v
 )
 {
  this->x <<= T(v.x);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec1<T> & tvec1<T>::operator>>=
 (
  tvec1<U> const & v
 )
 {
  this->x >>= T(v.x);
  return *this;
 }




 template <typename T> inline
                    T
 tvec1<T>::swizzle(comp x) const
 {
  return (*this)[x];
 }

 template <typename T> inline
                    tvec2<T>
 tvec1<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T> inline
                    tvec3<T>
 tvec1<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T> inline
                    tvec4<T>
 tvec1<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T> inline
                    tref1<T>
 tvec1<T>::swizzle
 (
  comp x
 )
 {
  return tref1<T>(
   (*this)[x]);
 }




 template <typename T> inline
                    tvec1<T> operator+
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x + s);
 }

 template <typename T> inline
                    tvec1<T> operator+
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s + v.x);
 }

 template <typename T> inline
                    tvec1<T> operator+
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x + v2.x);
 }


 template <typename T> inline
                    tvec1<T> operator-
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x - s);
 }

 template <typename T> inline
                    tvec1<T> operator-
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s - v.x);
 }

 template <typename T> inline
                    tvec1<T> operator-
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x - v2.x);
 }


 template <typename T> inline
                    tvec1<T> operator*
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x * s);
 }

 template <typename T> inline
                    tvec1<T> operator*
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s * v.x);
 }

 template <typename T> inline
                    tvec1<T> operator*
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x * v2.x);
 }


 template <typename T> inline
                    tvec1<T> operator/
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x / s);
 }

 template <typename T> inline
                    tvec1<T> operator/
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s / v.x);
 }

 template <typename T> inline
                    tvec1<T> operator/
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x / v2.x);
 }


 template <typename T> inline
                    tvec1<T> operator-
 (
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   -v.x);
 }

 template <typename T> inline
                    tvec1<T> operator++
 (
  tvec1<T> const & v,
  int
 )
 {
  return tvec1<T>(
   v.x + T(1));
 }

 template <typename T> inline
                    tvec1<T> operator--
 (
  tvec1<T> const & v,
  int
 )
 {
  return tvec1<T>(
   v.x - T(1));
 }




 template <typename T> inline
                    tvec1<T> operator%
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x % s);
 }

 template <typename T> inline
                    tvec1<T> operator%
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s % v.x);
 }

 template <typename T> inline
                    tvec1<T> operator%
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x % v2.x);
 }

 template <typename T> inline
                    tvec1<T> operator&
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x & s);
 }

 template <typename T> inline
                    tvec1<T> operator&
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s & v.x);
 }

 template <typename T> inline
                    tvec1<T> operator&
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x & v2.x);
 }

 template <typename T> inline
                    tvec1<T> operator|
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x | s);
 }

 template <typename T> inline
                    tvec1<T> operator|
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s | v.x);
 }

 template <typename T> inline
                    tvec1<T> operator|
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x | v2.x);
 }

 template <typename T> inline
                    tvec1<T> operator^
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x ^ s);
 }

 template <typename T> inline
                    tvec1<T> operator^
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s ^ v.x);
 }

 template <typename T> inline
                    tvec1<T> operator^
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x ^ v2.x);
 }

 template <typename T> inline
                    tvec1<T> operator<<
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x << s);
 }

 template <typename T> inline
                    tvec1<T> operator<<
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s << v.x);
 }

 template <typename T> inline
                    tvec1<T> operator<<
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x << v2.x);
 }

 template <typename T> inline
                    tvec1<T> operator>>
 (
  tvec1<T> const & v,
  typename tvec1<T>::value_type const & s
 )
 {
  return tvec1<T>(
   v.x >> s);
 }

 template <typename T> inline
                    tvec1<T> operator>>
 (
  typename tvec1<T>::value_type const & s,
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   s >> v.x);
 }

 template <typename T> inline
                    tvec1<T> operator>>
 (
  tvec1<T> const & v1,
  tvec1<T> const & v2
 )
 {
  return tvec1<T>(
   v1.x >> v2.x);
 }

 template <typename T> inline
                    tvec1<T> operator~
 (
  tvec1<T> const & v
 )
 {
  return tvec1<T>(
   ~v.x);
 }




 template <typename T> inline
                    tref1<T>::tref1
 (
  T & x
 ) :
  x(x)
 {}

 template <typename T> inline
                    tref1<T>::tref1
 (
  tref1<T> const & r
 ) :
  x(r.x)
 {}

 template <typename T> inline
                    tref1<T>::tref1
 (
  tvec1<T> const & v
 ) :
  x(v.x)
 {}

 template <typename T> inline
                    tref1<T> & tref1<T>::operator=
 (
  tref1<T> const & r
 )
 {
  x = r.x;
  return *this;
 }

 template <typename T> inline
                    tref1<T> & tref1<T>::operator=
 (
  tvec1<T> const & v
 )
 {
  x = v.x;
  return *this;
 }

}
}
# 209 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec1.hpp" 2
# 38 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.hpp" 1
# 38 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;

 template <typename T>
 struct tvec2
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T> type;
  typedef tvec2<bool> bool_type;

                              size_type length() const;
# 82 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.hpp"
  union {value_type x, r, s;};
  union {value_type y, g, t;};
# 103 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.hpp"
                value_type & operator[](size_type i);
                value_type const & operator[](size_type i) const;




                tvec2();
                tvec2(tvec2<T> const & v);




                explicit tvec2(
   ctor);
                explicit tvec2(
   value_type const & s);
                explicit tvec2(
   value_type const & s1,
   value_type const & s2);




  tvec2(tref2<T> const & r);

  template <int E0, int E1>
                tvec2(const glm::detail::swizzle<2,T,tvec2<T>,E0,E1,-1,-2>& that)
  {
   *this = that();
  }





  template <typename U>
                explicit tvec2(
   U const & x);

  template <typename U, typename V>
                explicit tvec2(
   U const & x,
   V const & y);





  template <typename U>
                explicit tvec2(tvec2<U> const & v);

  template <typename U>
                explicit tvec2(tvec3<U> const & v);

  template <typename U>
                explicit tvec2(tvec4<U> const & v);




                tvec2<T> & operator= (tvec2<T> const & v);
  template <typename U>
                tvec2<T> & operator= (tvec2<U> const & v);

  template <typename U>
                tvec2<T> & operator+=(U const & s);
  template <typename U>
                tvec2<T> & operator+=(tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator-=(U const & s);
  template <typename U>
                tvec2<T> & operator-=(tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator*=(U const & s);
  template <typename U>
                tvec2<T> & operator*=(tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator/=(U const & s);
  template <typename U>
                tvec2<T> & operator/=(tvec2<U> const & v);
                tvec2<T> & operator++();
                tvec2<T> & operator--();




  template <typename U>
                tvec2<T> & operator%= (U const & s);
  template <typename U>
                tvec2<T> & operator%= (tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator&= (U const & s);
  template <typename U>
                tvec2<T> & operator&= (tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator|= (U const & s);
  template <typename U>
                tvec2<T> & operator|= (tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator^= (U const & s);
  template <typename U>
                tvec2<T> & operator^= (tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator<<=(U const & s);
  template <typename U>
                tvec2<T> & operator<<=(tvec2<U> const & v);
  template <typename U>
                tvec2<T> & operator>>=(U const & s);
  template <typename U>
                tvec2<T> & operator>>=(tvec2<U> const & v);




                value_type swizzle(comp X) const;
                tvec2<T> swizzle(comp X, comp Y) const;
                tvec3<T> swizzle(comp X, comp Y, comp Z) const;
                tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
                tref2<T> swizzle(comp X, comp Y);
 };

 template <typename T>
 struct tref2
 {
                tref2(T & x, T & y);
                tref2(tref2<T> const & r);
                explicit tref2(tvec2<T> const & v);

                tref2<T> & operator= (tref2<T> const & r);
                tref2<T> & operator= (tvec2<T> const & v);

                tvec2<T> operator() ();

  T & x;
  T & y;
 };

 template <typename T> struct is_vector<tvec2<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };

}
# 252 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.hpp"
 typedef detail::tvec2<highp_float> highp_vec2;






 typedef detail::tvec2<mediump_float> mediump_vec2;






 typedef detail::tvec2<lowp_float> lowp_vec2;






 typedef detail::tvec2<highp_int> highp_ivec2;






 typedef detail::tvec2<mediump_int> mediump_ivec2;






 typedef detail::tvec2<lowp_int> lowp_ivec2;






 typedef detail::tvec2<highp_uint> highp_uvec2;






 typedef detail::tvec2<mediump_uint> mediump_uvec2;






 typedef detail::tvec2<lowp_uint> lowp_uvec2;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tvec2<T>::size_type tvec2<T>::length() const
 {
  return 2;
 }




 template <typename T> inline
                    typename tvec2<T>::value_type &
 tvec2<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.inl", 48, "i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T> inline
                    typename tvec2<T>::value_type const &
 tvec2<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.inl", 59, "i < this->length()") : (void)0);
  return (&x)[i];
 }




 template <typename T> inline
                    tvec2<T>::tvec2() :
  x(value_type(0)),
  y(value_type(0))
 {}

 template <typename T> inline
                    tvec2<T>::tvec2
 (
  ctor
 )
 {}

 template <typename T> inline
                    tvec2<T>::tvec2
 (
  tvec2<T> const & v
 ) :
  x(v.x),
  y(v.y)
 {}




 template <typename T> inline
                    tvec2<T>::tvec2
 (
  value_type const & s
 ) :
  x(s),
  y(s)
 {}

 template <typename T> inline
                    tvec2<T>::tvec2
 (
  value_type const & s1,
  value_type const & s2
 ) :
  x(s1),
  y(s2)
 {}




 template <typename T> inline
                    tvec2<T>::tvec2
 (
  tref2<T> const & r
 ) :
  x(r.x),
  y(r.y)
 {}




 template <typename T>
 template <typename U> inline
                    tvec2<T>::tvec2
 (
  U const & x
 ) :
  x(value_type(x)),
  y(value_type(x))
 {}

 template <typename T>
 template <typename U, typename V> inline
                    tvec2<T>::tvec2
 (
  U const & a,
  V const & b
 ) :
  x(value_type(a)),
  y(value_type(b))
 {}




 template <typename T>
 template <typename U> inline
                    tvec2<T>::tvec2
 (
  tvec2<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y))
 {}

 template <typename T>
 template <typename U> inline
                    tvec2<T>::tvec2
 (
  tvec3<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y))
 {}

 template <typename T>
 template <typename U> inline
                    tvec2<T>::tvec2
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y))
 {}




 template <typename T> inline
                    tvec2<T> & tvec2<T>::operator=
 (
  tvec2<T> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator=
 (
  tvec2<U> const & v
 )
 {
  this->x = T(v.x);
  this->y = T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  this->y += T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator+=
 (
  tvec2<U> const & v
 )
 {
  this->x += T(v.x);
  this->y += T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  this->y -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator-=
 (
  tvec2<U> const & v
 )
 {
  this->x -= T(v.x);
  this->y -= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  this->y *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator*=
 (
  tvec2<U> const & v
 )
 {
  this->x *= T(v.x);
  this->y *= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  this->y /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator/=
 (
  tvec2<U> const & v
 )
 {
  this->x /= T(v.x);
  this->y /= T(v.y);
  return *this;
 }

 template <typename T> inline
                    tvec2<T> & tvec2<T>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template <typename T> inline
                    tvec2<T> & tvec2<T>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }




 template <typename T> inline
                    bool operator==
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y);
 }

 template <typename T> inline
                    bool operator!=
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y);
 }




 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= T(s);
  this->y %= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator%=
 (
  tvec2<U> const & v
 )
 {
  this->x %= T(v.x);
  this->y %= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= T(s);
  this->y &= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator&=
 (
  tvec2<U> const & v
 )
 {
  this->x &= T(v.x);
  this->y &= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= T(s);
  this->y |= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator|=
 (
  tvec2<U> const & v
 )
 {
  this->x |= T(v.x);
  this->y |= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= T(s);
  this->y ^= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator^=
 (
  tvec2<U> const & v
 )
 {
  this->x ^= T(v.x);
  this->y ^= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= T(s);
  this->y <<= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator<<=
 (
  tvec2<U> const & v
 )
 {
  this->x <<= T(v.x);
  this->y <<= T(v.y);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  this->y >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec2<T> & tvec2<T>::operator>>=
 (
  tvec2<U> const & v
 )
 {
  this->x >>= T(v.x);
  this->y >>= T(v.y);
  return *this;
 }




 template <typename T> inline
                    typename tvec2<T>::value_type tvec2<T>::swizzle
 (
  comp x
 ) const
 {
  return (*this)[x];
 }

 template <typename T> inline
                    tvec2<T> tvec2<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T> inline
                    tvec3<T> tvec2<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T> inline
                    tvec4<T> tvec2<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T> inline
                    tref2<T> tvec2<T>::swizzle
 (
  comp x,
  comp y
 )
 {
  return tref2<T>(
   (*this)[x],
   (*this)[y]);
 }




 template <typename T> inline
                    tvec2<T> operator+
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x + T(s),
   v.y + T(s));
 }

 template <typename T> inline
                    tvec2<T> operator+
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) + v.x,
   T(s) + v.y);
 }

 template <typename T> inline
                    tvec2<T> operator+
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x + T(v2.x),
   v1.y + T(v2.y));
 }


 template <typename T> inline
                    tvec2<T> operator-
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x - T(s),
   v.y - T(s));
 }

 template <typename T> inline
                    tvec2<T> operator-
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) - v.x,
   T(s) - v.y);
 }

 template <typename T> inline
                    tvec2<T> operator-
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x - T(v2.x),
   v1.y - T(v2.y));
 }


 template <typename T> inline
                    tvec2<T> operator*
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x * T(s),
   v.y * T(s));
 }

 template <typename T> inline
                    tvec2<T> operator*
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) * v.x,
   T(s) * v.y);
 }

 template <typename T> inline
                    tvec2<T> operator*
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x * T(v2.x),
   v1.y * T(v2.y));
 }


 template <typename T> inline
                    tvec2<T> operator/
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x / T(s),
   v.y / T(s));
 }

 template <typename T> inline
                    tvec2<T> operator/
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) / v.x,
   T(s) / v.y);
 }

 template <typename T> inline
                    tvec2<T> operator/
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x / T(v2.x),
   v1.y / T(v2.y));
 }


 template <typename T> inline
                    tvec2<T> operator-
 (
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   -v.x,
   -v.y);
 }

 template <typename T> inline
                    tvec2<T> operator++
 (
  tvec2<T> const & v,
  int
 )
 {
  return tvec2<T>(
   v.x + T(1),
   v.y + T(1));
 }

 template <typename T> inline
                    tvec2<T> operator--
 (
  tvec2<T> const & v,
  int
 )
 {
  return tvec2<T>(
   v.x - T(1),
   v.y - T(1));
 }




 template <typename T> inline
                    tvec2<T> operator%
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x % T(s),
   v.y % T(s));
 }

 template <typename T> inline
                    tvec2<T> operator%
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) % v.x,
   T(s) % v.y);
 }

 template <typename T> inline
                    tvec2<T> operator%
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x % T(v2.x),
   v1.y % T(v2.y));
 }

 template <typename T> inline
                    tvec2<T> operator&
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x & T(s),
   v.y & T(s));
 }

 template <typename T> inline
                    tvec2<T> operator&
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) & v.x,
   T(s) & v.y);
 }

 template <typename T> inline
                    tvec2<T> operator&
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x & T(v2.x),
   v1.y & T(v2.y));
 }

 template <typename T> inline
                    tvec2<T> operator|
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x | T(s),
   v.y | T(s));
 }

 template <typename T> inline
                    tvec2<T> operator|
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) | v.x,
   T(s) | v.y);
 }

 template <typename T> inline
                    tvec2<T> operator|
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x | T(v2.x),
   v1.y | T(v2.y));
 }

 template <typename T> inline
                    tvec2<T> operator^
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x ^ T(s),
   v.y ^ T(s));
 }

 template <typename T> inline
                    tvec2<T> operator^
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) ^ v.x,
   T(s) ^ v.y);
 }

 template <typename T> inline
                    tvec2<T> operator^
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x ^ T(v2.x),
   v1.y ^ T(v2.y));
 }

 template <typename T> inline
                    tvec2<T> operator<<
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x << T(s),
   v.y << T(s));
 }

 template <typename T> inline
                    tvec2<T> operator<<
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   s << T(v.x),
   s << T(v.y));
 }

 template <typename T> inline
                    tvec2<T> operator<<
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x << T(v2.x),
   v1.y << T(v2.y));
 }

 template <typename T> inline
                    tvec2<T> operator>>
 (
  tvec2<T> const & v,
  T const & s
 )
 {
  return tvec2<T>(
   v.x >> T(s),
   v.y >> T(s));
 }

 template <typename T> inline
                    tvec2<T> operator>>
 (
  T const & s,
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   T(s) >> v.x,
   T(s) >> v.y);
 }

 template <typename T> inline
                    tvec2<T> operator>>
 (
  tvec2<T> const & v1,
  tvec2<T> const & v2
 )
 {
  return tvec2<T>(
   v1.x >> T(v2.x),
   v1.y >> T(v2.y));
 }

 template <typename T> inline
                    tvec2<T> operator~
 (
  tvec2<T> const & v
 )
 {
  return tvec2<T>(
   ~v.x,
   ~v.y);
 }




 template <typename T>
 tref2<T>::tref2
 (
  T & x,
  T & y
 ) :
  x(x),
  y(y)
 {}

 template <typename T>
 tref2<T>::tref2
 (
  tref2<T> const & r
 ) :
  x(r.x),
  y(r.y)
 {}

 template <typename T>
 tref2<T>::tref2
 (
  tvec2<T> const & v
 ) :
  x(v.x),
  y(v.y)
 {}

 template <typename T>
 tref2<T>& tref2<T>::operator=
 (
  tref2<T> const & r
 )
 {
  x = r.x;
  y = r.y;
  return *this;
 }

 template <typename T>
 tref2<T>& tref2<T>::operator=
 (
  tvec2<T> const & v
 )
 {
  x = v.x;
  y = v.y;
  return *this;
 }

 template <typename T> inline
                    tvec2<T> tref2<T>::operator() ()
 {
  return tvec2<T>(this->x, this->y);
 }
}
}
# 314 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec2.hpp" 2
# 39 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.hpp" 1
# 38 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec2;
 template <typename T> struct tvec4;

 template <typename T>
 struct tvec3
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T> type;
  typedef tvec3<bool> bool_type;

                              size_type length() const;
# 82 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.hpp"
  union {value_type x, r, s;};
  union {value_type y, g, t;};
  union {value_type z, b, p;};
# 104 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.hpp"
                value_type & operator[](size_type i);
                value_type const & operator[](size_type i) const;




                tvec3();
                tvec3(tvec3<T> const & v);




                explicit tvec3(
   ctor);
                explicit tvec3(
   value_type const & s);
                explicit tvec3(
   value_type const & s1,
   value_type const & s2,
   value_type const & s3);





  template <typename U>
                explicit tvec3(
   U const & x);

  template <typename U, typename V, typename W>
                explicit tvec3(
   U const & x,
   V const & y,
   W const & z);





  template <typename A, typename B>
                explicit tvec3(tvec2<A> const & v, B const & s);

  template <typename A, typename B>
                explicit tvec3(A const & s, tvec2<B> const & v);

  template <typename U>
                explicit tvec3(tvec3<U> const & v);

  template <typename U>
                explicit tvec3(tvec4<U> const & v);




                tvec3(tref3<T> const & r);

  template <typename A, typename B>
                explicit tvec3(tref2<A> const & v, B const & s);

  template <typename A, typename B>
                explicit tvec3(A const & s, tref2<B> const & v);

  template <int E0, int E1, int E2>
                tvec3(glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & that)
  {
   *this = that();
  }

  template <int E0, int E1>
                tvec3(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & s)
  {
   *this = tvec3<T>(v(), s);
  }

  template <int E0, int E1>
                tvec3(T const & s, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v)
  {
   *this = tvec3<T>(s, v());
  }




                tvec3<T> & operator= (tvec3<T> const & v);
  template <typename U>
                tvec3<T> & operator= (tvec3<U> const & v);

  template <typename U>
                tvec3<T> & operator+=(U const & s);
  template <typename U>
                tvec3<T> & operator+=(tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator-=(U const & s);
  template <typename U>
                tvec3<T> & operator-=(tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator*=(U const & s);
  template <typename U>
                tvec3<T> & operator*=(tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator/=(U const & s);
  template <typename U>
                tvec3<T> & operator/=(tvec3<U> const & v);
                tvec3<T> & operator++();
                tvec3<T> & operator--();




  template <typename U>
                tvec3<T> & operator%= (U const & s);
  template <typename U>
                tvec3<T> & operator%= (tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator&= (U const & s);
  template <typename U>
                tvec3<T> & operator&= (tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator|= (U const & s);
  template <typename U>
                tvec3<T> & operator|= (tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator^= (U const & s);
  template <typename U>
                tvec3<T> & operator^= (tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator<<=(U const & s);
  template <typename U>
                tvec3<T> & operator<<=(tvec3<U> const & v);
  template <typename U>
                tvec3<T> & operator>>=(U const & s);
  template <typename U>
                tvec3<T> & operator>>=(tvec3<U> const & v);




                value_type swizzle(comp X) const;
                tvec2<T> swizzle(comp X, comp Y) const;
                tvec3<T> swizzle(comp X, comp Y, comp Z) const;
                tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
                tref2<T> swizzle(comp X, comp Y);
                tref3<T> swizzle(comp X, comp Y, comp Z);
 };

 template <typename T>
 struct tref3
 {
                tref3(T & x, T & y, T & z);
                tref3(tref3<T> const & r);
                explicit tref3(tvec3<T> const & v);

                tref3<T> & operator= (tref3<T> const & r);
                tref3<T> & operator= (tvec3<T> const & v);

                tvec3<T> operator() ();

  T & x;
  T & y;
  T & z;
 };

 template <typename T> struct is_vector<tvec3<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };
}
# 277 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.hpp"
 typedef detail::tvec3<highp_float> highp_vec3;






 typedef detail::tvec3<mediump_float> mediump_vec3;






 typedef detail::tvec3<lowp_float> lowp_vec3;






 typedef detail::tvec3<highp_int> highp_ivec3;






 typedef detail::tvec3<mediump_int> mediump_ivec3;






 typedef detail::tvec3<lowp_int> lowp_ivec3;






 typedef detail::tvec3<highp_uint> highp_uvec3;






 typedef detail::tvec3<mediump_uint> mediump_uvec3;






 typedef detail::tvec3<lowp_uint> lowp_uvec3;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tvec3<T>::size_type tvec3<T>::length() const
 {
  return 3;
 }




 template <typename T> inline
                    typename tvec3<T>::value_type &
 tvec3<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.inl", 48, "i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T> inline
                    typename tvec3<T>::value_type const &
 tvec3<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.inl", 59, "i < this->length()") : (void)0);
  return (&x)[i];
 }




 template <typename T> inline
                    tvec3<T>::tvec3() :
  x(value_type(0)),
  y(value_type(0)),
  z(value_type(0))
 {}

 template <typename T> inline
                    tvec3<T>::tvec3
 (
  ctor
 )
 {}

 template <typename T> inline
                    tvec3<T>::tvec3
 (
  tvec3<T> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z)
 {}




 template <typename T> inline
                    tvec3<T>::tvec3
 (
  value_type const & s
 ) :
  x(s),
  y(s),
  z(s)
 {}

 template <typename T> inline
                    tvec3<T>::tvec3
 (
  value_type const & s0,
  value_type const & s1,
  value_type const & s2
 ) :
  x(s0),
  y(s1),
  z(s2)
 {}




 template <typename T> inline
                    tvec3<T>::tvec3
 (
  tref3<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z)
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec3<T>::tvec3
 (
  tref2<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec3<T>::tvec3
 (
  A const & s,
  tref2<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y))
 {}




 template <typename T>
 template <typename U> inline
                    tvec3<T>::tvec3
 (
  U const & s
 ) :
  x(value_type(s)),
  y(value_type(s)),
  z(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B, typename C> inline
                    tvec3<T>::tvec3
 (
  A const & x,
  B const & y,
  C const & z
 ) :
  x(value_type(x)),
  y(value_type(y)),
  z(value_type(z))
 {}




 template <typename T>
 template <typename A, typename B> inline
                    tvec3<T>::tvec3
 (
  tvec2<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec3<T>::tvec3
 (
  A const & s,
  tvec2<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y))
 {}

 template <typename T>
 template <typename U> inline
                    tvec3<T>::tvec3
 (
  tvec3<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z))
 {}

 template <typename T>
 template <typename U> inline
                    tvec3<T>::tvec3
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z))
 {}




 template <typename T> inline
                    tvec3<T>& tvec3<T>::operator=
 (
  tvec3<T> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T>& tvec3<T>::operator=
 (
  tvec3<U> const & v
 )
 {
  this->x = T(v.x);
  this->y = T(v.y);
  this->z = T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  this->y += T(s);
  this->z += T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator+=
 (
  tvec3<U> const & v
 )
 {
  this->x += T(v.x);
  this->y += T(v.y);
  this->z += T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  this->y -= T(s);
  this->z -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator-=
 (
  tvec3<U> const & v
 )
 {
  this->x -= T(v.x);
  this->y -= T(v.y);
  this->z -= T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  this->y *= T(s);
  this->z *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator*=
 (
  tvec3<U> const & v
 )
 {
  this->x *= T(v.x);
  this->y *= T(v.y);
  this->z *= T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  this->y /= T(s);
  this->z /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator/=
 (
  tvec3<U> const & v
 )
 {
  this->x /= T(v.x);
  this->y /= T(v.y);
  this->z /= T(v.z);
  return *this;
 }

 template <typename T> inline
                    tvec3<T> & tvec3<T>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template <typename T> inline
                    tvec3<T> & tvec3<T>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }




 template <typename T> inline
                    bool operator==
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
 }

 template <typename T> inline
                    bool operator!=
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
 }




 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= s;
  this->y %= s;
  this->z %= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator%=
 (
  tvec3<U> const & v
 )
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= s;
  this->y &= s;
  this->z &= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator&=
 (
  tvec3<U> const & v
 )
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= s;
  this->y |= s;
  this->z |= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator|=
 (
  tvec3<U> const & v
 )
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= s;
  this->y ^= s;
  this->z ^= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator^=
 (
  tvec3<U> const & v
 )
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= s;
  this->y <<= s;
  this->z <<= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator<<=
 (
  tvec3<U> const & v
 )
 {
  this->x <<= T(v.x);
  this->y <<= T(v.y);
  this->z <<= T(v.z);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  this->y >>= T(s);
  this->z >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec3<T> & tvec3<T>::operator>>=
 (
  tvec3<U> const & v
 )
 {
  this->x >>= T(v.x);
  this->y >>= T(v.y);
  this->z >>= T(v.z);
  return *this;
 }




 template <typename T> inline
                    typename tvec3<T>::value_type
 tvec3<T>::swizzle
 (
  comp x
 ) const
 {
  return (*this)[x];
 }

 template <typename T> inline
                    tvec2<T> tvec3<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T> inline
                    tvec3<T> tvec3<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T> inline
                    tvec4<T> tvec3<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T> inline
                    tref2<T> tvec3<T>::swizzle
 (
  comp x,
  comp y
 )
 {
  return tref2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T> inline
                    tref3<T> tvec3<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 )
 {
  return tref3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }




 template <typename T> inline
                    tvec3<T> operator+
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x + T(s),
   v.y + T(s),
   v.z + T(s));
 }

 template <typename T> inline
                    tvec3<T> operator+
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) + v.x,
   T(s) + v.y,
   T(s) + v.z);
 }

 template <typename T> inline
                    tvec3<T> operator+
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x + T(v2.x),
   v1.y + T(v2.y),
   v1.z + T(v2.z));
 }


 template <typename T> inline
                    tvec3<T> operator-
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x - T(s),
   v.y - T(s),
   v.z - T(s));
 }

 template <typename T> inline
                    tvec3<T> operator-
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) - v.x,
   T(s) - v.y,
   T(s) - v.z);
 }

 template <typename T> inline
                    tvec3<T> operator-
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x - T(v2.x),
   v1.y - T(v2.y),
   v1.z - T(v2.z));
 }


 template <typename T> inline
                    tvec3<T> operator*
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x * T(s),
   v.y * T(s),
   v.z * T(s));
 }

 template <typename T> inline
                    tvec3<T> operator*
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) * v.x,
   T(s) * v.y,
   T(s) * v.z);
 }

 template <typename T> inline
                    tvec3<T> operator*
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x * T(v2.x),
   v1.y * T(v2.y),
   v1.z * T(v2.z));
 }


 template <typename T> inline
                    tvec3<T> operator/
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x / T(s),
   v.y / T(s),
   v.z / T(s));
 }

 template <typename T> inline
                    tvec3<T> operator/
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) / v.x,
   T(s) / v.y,
   T(s) / v.z);
 }

 template <typename T> inline
                    tvec3<T> operator/
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x / T(v2.x),
   v1.y / T(v2.y),
   v1.z / T(v2.z));
 }


 template <typename T> inline
                    tvec3<T> operator-
 (
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   -v.x,
   -v.y,
   -v.z);
 }

 template <typename T> inline
                    tvec3<T> operator++
 (
  tvec3<T> const & v,
  int
 )
 {
  return tvec3<T>(
   v.x + T(1),
   v.y + T(1),
   v.z + T(1));
 }

 template <typename T> inline
                    tvec3<T> operator--
 (
  tvec3<T> const & v,
  int
 )
 {
  return tvec3<T>(
   v.x - T(1),
   v.y - T(1),
   v.z - T(1));
 }




 template <typename T> inline
                    tvec3<T> operator%
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x % T(s),
   v.y % T(s),
   v.z % T(s));
 }

 template <typename T> inline
                    tvec3<T> operator%
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) % v.x,
   T(s) % v.y,
   T(s) % v.z);
 }

 template <typename T> inline
                    tvec3<T> operator%
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x % T(v2.x),
   v1.y % T(v2.y),
   v1.z % T(v2.z));
 }

 template <typename T> inline
                    tvec3<T> operator&
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x & T(s),
   v.y & T(s),
   v.z & T(s));
 }

 template <typename T> inline
                    tvec3<T> operator&
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) & v.x,
   T(s) & v.y,
   T(s) & v.z);
 }

 template <typename T> inline
                    tvec3<T> operator&
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x & T(v2.x),
   v1.y & T(v2.y),
   v1.z & T(v2.z));
 }

 template <typename T> inline
                    tvec3<T> operator|
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x | T(s),
   v.y | T(s),
   v.z | T(s));
 }

 template <typename T> inline
                    tvec3<T> operator|
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) | v.x,
   T(s) | v.y,
   T(s) | v.z);
 }

 template <typename T> inline
                    tvec3<T> operator|
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x | T(v2.x),
   v1.y | T(v2.y),
   v1.z | T(v2.z));
 }

 template <typename T> inline
                    tvec3<T> operator^
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x ^ T(s),
   v.y ^ T(s),
   v.z ^ T(s));
 }

 template <typename T> inline
                    tvec3<T> operator^
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) ^ v.x,
   T(s) ^ v.y,
   T(s) ^ v.z);
 }

 template <typename T> inline
                    tvec3<T> operator^
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x ^ T(v2.x),
   v1.y ^ T(v2.y),
   v1.z ^ T(v2.z));
 }

 template <typename T> inline
                    tvec3<T> operator<<
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x << T(s),
   v.y << T(s),
   v.z << T(s));
 }

 template <typename T> inline
                    tvec3<T> operator<<
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   T(s) << v.x,
   T(s) << v.y,
   T(s) << v.z);
 }

 template <typename T> inline
                    tvec3<T> operator<<
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x << T(v2.x),
   v1.y << T(v2.y),
   v1.z << T(v2.z));
 }

 template <typename T> inline
                    tvec3<T> operator>>
 (
  tvec3<T> const & v,
  T const & s
 )
 {
  return tvec3<T>(
   v.x >> T(s),
   v.y >> T(s),
   v.z >> T(s));
 }

 template <typename T> inline
                    tvec3<T> operator>>
 (
  T const & s,
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   s >> T(v.x),
   s >> T(v.y),
   s >> T(v.z));
 }

 template <typename T> inline
                    tvec3<T> operator>>
 (
  tvec3<T> const & v1,
  tvec3<T> const & v2
 )
 {
  return tvec3<T>(
   v1.x >> T(v2.x),
   v1.y >> T(v2.y),
   v1.z >> T(v2.z));
 }

 template <typename T> inline
                    tvec3<T> operator~
 (
  tvec3<T> const & v
 )
 {
  return tvec3<T>(
   ~v.x,
   ~v.y,
   ~v.z);
 }




 template <typename T> inline
                    tref3<T>::tref3(T & x, T & y, T & z) :
  x(x),
  y(y),
  z(z)
 {}

 template <typename T> inline
                    tref3<T>::tref3
 (
  tref3<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z)
 {}

 template <typename T> inline
                    tref3<T>::tref3
 (
  tvec3<T> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z)
 {}

 template <typename T> inline
                    tref3<T> & tref3<T>::operator=
 (
  tref3<T> const & r
 )
 {
  x = r.x;
  y = r.y;
  z = r.z;
  return *this;
 }

 template <typename T> inline
                    tref3<T> & tref3<T>::operator=
 (
  tvec3<T> const & v
 )
 {
  x = v.x;
  y = v.y;
  z = v.z;
  return *this;
 }

 template <typename T> inline
                    tvec3<T> tref3<T>::operator() ()
 {
  return tvec3<T>(this->x, this->y, this->z);
 }

}
}
# 339 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec3.hpp" 2
# 40 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.hpp" 1
# 38 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tref2;
 template <typename T> struct tref3;
 template <typename T> struct tref4;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;

 template <typename T>
 struct tvec4
 {
  enum ctor{null};

  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T> type;
  typedef tvec4<bool> bool_type;

                              size_type length() const;
# 82 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.hpp"
  union {value_type x, r, s;};
  union {value_type y, g, t;};
  union {value_type z, b, p;};
  union {value_type w, a, q;};
# 105 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.hpp"
                value_type & operator[](size_type i);
                value_type const & operator[](size_type i) const;




                tvec4();
                tvec4(type const & v);




                explicit tvec4(
   ctor);
                explicit tvec4(
   value_type const & s);
                explicit tvec4(
   value_type const & s0,
   value_type const & s1,
   value_type const & s2,
   value_type const & s3);





  template <typename U>
                explicit tvec4(
   U const & x);

  template <typename A, typename B, typename C, typename D>
                explicit tvec4(
   A const & x,
   B const & y,
   C const & z,
   D const & w);





  template <typename A, typename B, typename C>
                explicit tvec4(tvec2<A> const & v, B const & s1, C const & s2);

  template <typename A, typename B, typename C>
                explicit tvec4(A const & s1, tvec2<B> const & v, C const & s2);

  template <typename A, typename B, typename C>
                explicit tvec4(A const & s1, B const & s2, tvec2<C> const & v);

  template <typename A, typename B>
                explicit tvec4(tvec3<A> const & v, B const & s);

  template <typename A, typename B>
                explicit tvec4(A const & s, tvec3<B> const & v);

  template <typename A, typename B>
                explicit tvec4(tvec2<A> const & v1, tvec2<B> const & v2);

  template <typename U>
                explicit tvec4(tvec4<U> const & v);

  template <int E0, int E1, int E2, int E3>
                tvec4(glm::detail::swizzle<4, T, tvec4<T>, E0, E1, E2, E3> const & that)
  {
   *this = that();
  }

  template <int E0, int E1, int F0, int F1>
                tvec4(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, glm::detail::swizzle<2, T, tvec2<T>, F0, F1, -1, -2> const & u)
  {
   *this = tvec4<T>(v(), u());
  }

  template <int E0, int E1>
                tvec4(T const & x, T const & y, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v)
  {
   *this = tvec4<T>(x, y, v());
  }

  template <int E0, int E1>
                tvec4(T const & x, glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & w)
  {
   *this = tvec4<T>(x, v(), w);
  }

  template <int E0, int E1>
                tvec4(glm::detail::swizzle<2, T, tvec2<T>, E0, E1, -1, -2> const & v, T const & z, T const & w)
  {
   *this = tvec4<T>(v(), z, w);
  }

  template <int E0, int E1, int E2>
                tvec4(glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & v, T const & w)
  {
   *this = tvec4<T>(v(), w);
  }

  template <int E0, int E1, int E2>
                tvec4(T const & x, glm::detail::swizzle<3, T, tvec3<T>, E0, E1, E2, -1> const & v)
  {
   *this = tvec4<T>(x, v());
  }




                tvec4(tref4<T> const & r);


  template <typename A, typename B, typename C>
                explicit tvec4(tref2<A> const & v, B const & s1, C const & s2);

  template <typename A, typename B, typename C>
                explicit tvec4(A const & s1, tref2<B> const & v, C const & s2);

  template <typename A, typename B, typename C>
                explicit tvec4(A const & s1, B const & s2, tref2<C> const & v);

  template <typename A, typename B>
                explicit tvec4(tref3<A> const & v, B const & s);

  template <typename A, typename B>
                explicit tvec4(A const & s, tref3<B> const & v);

  template <typename A, typename B>
                explicit tvec4(tref2<A> const & v1, tref2<B> const & v2);

  template <typename A, typename B>
                explicit tvec4(tvec2<A> const & v1, tref2<B> const & v2);

  template <typename A, typename B>
                explicit tvec4(tref2<A> const & v1, tvec2<B> const & v2);




                tvec4<T> & operator= (tvec4<T> const & v);
  template <typename U>
                tvec4<T> & operator= (tvec4<U> const & v);

  template <typename U>
                tvec4<T> & operator+=(U const & s);
  template <typename U>
                tvec4<T> & operator+=(tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator-=(U const & s);
  template <typename U>
                tvec4<T> & operator-=(tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator*=(U const & s);
  template <typename U>
                tvec4<T> & operator*=(tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator/=(U const & s);
  template <typename U>
                tvec4<T> & operator/=(tvec4<U> const & v);
                tvec4<T> & operator++();
                tvec4<T> & operator--();




  template <typename U>
                tvec4<T> & operator%= (U const & s);
  template <typename U>
                tvec4<T> & operator%= (tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator&= (U const & s);
  template <typename U>
                tvec4<T> & operator&= (tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator|= (U const & s);
  template <typename U>
                tvec4<T> & operator|= (tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator^= (U const & s);
  template <typename U>
                tvec4<T> & operator^= (tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator<<=(U const & s);
  template <typename U>
                tvec4<T> & operator<<=(tvec4<U> const & v);
  template <typename U>
                tvec4<T> & operator>>=(U const & s);
  template <typename U>
                tvec4<T> & operator>>=(tvec4<U> const & v);




                value_type swizzle(comp X) const;
                tvec2<T> swizzle(comp X, comp Y) const;
                tvec3<T> swizzle(comp X, comp Y, comp Z) const;
                tvec4<T> swizzle(comp X, comp Y, comp Z, comp W) const;
                tref2<T> swizzle(comp X, comp Y);
                tref3<T> swizzle(comp X, comp Y, comp Z);
                tref4<T> swizzle(comp X, comp Y, comp Z, comp W);
 };

 template <typename T>
 struct tref4
 {
                tref4(T & x, T & y, T & z, T & w);
                tref4(tref4<T> const & r);
                explicit tref4(tvec4<T> const & v);

                tref4<T> & operator= (tref4<T> const & r);
                tref4<T> & operator= (tvec4<T> const & v);

                tvec4<T> operator() ();

  T & x;
  T & y;
  T & z;
  T & w;
 };

 template <typename T> struct is_vector<tvec4<T> > { enum is_vector_enum { _YES = 1, _NO = 0 }; };
}
# 334 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.hpp"
 typedef detail::tvec4<highp_float> highp_vec4;






 typedef detail::tvec4<mediump_float> mediump_vec4;






 typedef detail::tvec4<lowp_float> lowp_vec4;






 typedef detail::tvec4<highp_int> highp_ivec4;






 typedef detail::tvec4<mediump_int> mediump_ivec4;






 typedef detail::tvec4<lowp_int> lowp_ivec4;






 typedef detail::tvec4<highp_uint> highp_uvec4;






 typedef detail::tvec4<mediump_uint> mediump_uvec4;






 typedef detail::tvec4<lowp_uint> lowp_uvec4;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tvec4<T>::size_type tvec4<T>::length() const
 {
  return 4;
 }




 template <typename T> inline
                    typename tvec4<T>::value_type &
 tvec4<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.inl", 48, "i < this->length()") : (void)0);
  return (&x)[i];
 }

 template <typename T> inline
                    typename tvec4<T>::value_type const &
 tvec4<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.inl", 59, "i < this->length()") : (void)0);
  return (&x)[i];
 }




 template <typename T> inline
                    tvec4<T>::tvec4() :
  x(value_type(0)),
  y(value_type(0)),
  z(value_type(0)),
  w(value_type(0))
 {}

 template <typename T> inline
                    tvec4<T>::tvec4
 (
  ctor
 )
 {}

 template <typename T> inline
                    tvec4<T>::tvec4
 (
  type const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z),
  w(v.w)
 {}




 template <typename T> inline
                    tvec4<T>::tvec4
 (
  value_type const & s
 ) :
  x(s),
  y(s),
  z(s),
  w(s)
 {}

 template <typename T> inline
                    tvec4<T>::tvec4
 (
  value_type const & s1,
  value_type const & s2,
  value_type const & s3,
  value_type const & s4
 ) :
  x(s1),
  y(s2),
  z(s3),
  w(s4)
 {}




 template <typename T> inline
                    tvec4<T>::tvec4
 (
  tref4<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z),
  w(r.w)
 {}

 template <typename T>
 template <typename A, typename B, typename C> inline
                    tvec4<T>::tvec4
 (
  tref2<A> const & v,
  B const & s1,
  C const & s2
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s1)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C> inline
                    tvec4<T>::tvec4
 (
  A const & s1,
  tref2<B> const & v,
  C const & s2
 ) :
  x(value_type(s1)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C> inline
                    tvec4<T>::tvec4
 (
  A const & s1,
  B const & s2,
  tref2<C> const & v
 ) :
  x(value_type(s1)),
  y(value_type(s2)),
  z(value_type(v.x)),
  w(value_type(v.y))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  tref3<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z)),
  w(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  A const & s,
  tref3<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(v.z))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  tref2<A> const & v1,
  tref2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  tvec2<A> const & v1,
  tref2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  tref2<A> const & v1,
  tvec2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}




 template <typename T>
 template <typename U> inline
                    tvec4<T>::tvec4
 (
  U const & x
 ) :
  x(value_type(x)),
  y(value_type(x)),
  z(value_type(x)),
  w(value_type(x))
 {}

 template <typename T>
 template <typename A, typename B, typename C, typename D> inline
                    tvec4<T>::tvec4
 (
  A const & x,
  B const & y,
  C const & z,
  D const & w
 ) :
  x(value_type(x)),
  y(value_type(y)),
  z(value_type(z)),
  w(value_type(w))
 {}




 template <typename T>
 template <typename A, typename B, typename C> inline
                    tvec4<T>::tvec4
 (
  tvec2<A> const & v,
  B const & s1,
  C const & s2
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(s1)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C> inline
                    tvec4<T>::tvec4
 (
  A const & s1,
  tvec2<B> const & v,
  C const & s2
 ) :
  x(value_type(s1)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(s2))
 {}

 template <typename T>
 template <typename A, typename B, typename C> inline
                    tvec4<T>::tvec4
 (
  A const & s1,
  B const & s2,
  tvec2<C> const & v
 ) :
  x(value_type(s1)),
  y(value_type(s2)),
  z(value_type(v.x)),
  w(value_type(v.y))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  tvec3<A> const & v,
  B const & s
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z)),
  w(value_type(s))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  A const & s,
  tvec3<B> const & v
 ) :
  x(value_type(s)),
  y(value_type(v.x)),
  z(value_type(v.y)),
  w(value_type(v.z))
 {}

 template <typename T>
 template <typename A, typename B> inline
                    tvec4<T>::tvec4
 (
  tvec2<A> const & v1,
  tvec2<B> const & v2
 ) :
  x(value_type(v1.x)),
  y(value_type(v1.y)),
  z(value_type(v2.x)),
  w(value_type(v2.y))
 {}

 template <typename T>
 template <typename U> inline
                    tvec4<T>::tvec4
 (
  tvec4<U> const & v
 ) :
  x(value_type(v.x)),
  y(value_type(v.y)),
  z(value_type(v.z)),
  w(value_type(v.w))
 {}




 template <typename T> inline
                    tvec4<T> & tvec4<T>::operator=
 (
  tvec4<T> const & v
 )
 {
  this->x = v.x;
  this->y = v.y;
  this->z = v.z;
  this->w = v.w;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator=
 (
  tvec4<U> const & v
 )
 {
  this->x = T(v.x);
  this->y = T(v.y);
  this->z = T(v.z);
  this->w = T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator+=
 (
  U const & s
 )
 {
  this->x += T(s);
  this->y += T(s);
  this->z += T(s);
  this->w += T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator+=
 (
  tvec4<U> const & v
 )
 {
  this->x += T(v.x);
  this->y += T(v.y);
  this->z += T(v.z);
  this->w += T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator-=
 (
  U const & s
 )
 {
  this->x -= T(s);
  this->y -= T(s);
  this->z -= T(s);
  this->w -= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator-=
 (
  tvec4<U> const & v
 )
 {
  this->x -= T(v.x);
  this->y -= T(v.y);
  this->z -= T(v.z);
  this->w -= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator*=
 (
  U const & s
 )
 {
  this->x *= T(s);
  this->y *= T(s);
  this->z *= T(s);
  this->w *= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator*=
 (
  tvec4<U> const & v
 )
 {
  this->x *= T(v.x);
  this->y *= T(v.y);
  this->z *= T(v.z);
  this->w *= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator/=
 (
  U const & s
 )
 {
  this->x /= T(s);
  this->y /= T(s);
  this->z /= T(s);
  this->w /= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator/=
 (
  tvec4<U> const & v
 )
 {
  this->x /= T(v.x);
  this->y /= T(v.y);
  this->z /= T(v.z);
  this->w /= T(v.w);
  return *this;
 }

 template <typename T> inline
                    tvec4<T> & tvec4<T>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template <typename T> inline
                    tvec4<T> & tvec4<T>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }




 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator%=
 (
  U const & s
 )
 {
  this->x %= T(s);
  this->y %= T(s);
  this->z %= T(s);
  this->w %= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator%=
 (
  tvec4<U> const & v
 )
 {
  this->x %= T(v.x);
  this->y %= T(v.y);
  this->z %= T(v.z);
  this->w %= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator&=
 (
  U const & s
 )
 {
  this->x &= T(s);
  this->y &= T(s);
  this->z &= T(s);
  this->w &= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator&=
 (
  tvec4<U> const & v
 )
 {
  this->x &= T(v.x);
  this->y &= T(v.y);
  this->z &= T(v.z);
  this->w &= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator|=
 (
  U const & s
 )
 {
  this->x |= T(s);
  this->y |= T(s);
  this->z |= T(s);
  this->w |= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator|=
 (
  tvec4<U> const & v
 )
 {
  this->x |= T(v.x);
  this->y |= T(v.y);
  this->z |= T(v.z);
  this->w |= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator^=
 (
  U const & s
 )
 {
  this->x ^= T(s);
  this->y ^= T(s);
  this->z ^= T(s);
  this->w ^= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator^=
 (
  tvec4<U> const & v
 )
 {
  this->x ^= T(v.x);
  this->y ^= T(v.y);
  this->z ^= T(v.z);
  this->w ^= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator<<=
 (
  U const & s
 )
 {
  this->x <<= T(s);
  this->y <<= T(s);
  this->z <<= T(s);
  this->w <<= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator<<=
 (
  tvec4<U> const & v
 )
 {
  this->x <<= T(v.x);
  this->y <<= T(v.y);
  this->z <<= T(v.z);
  this->w <<= T(v.w);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator>>=
 (
  U const & s
 )
 {
  this->x >>= T(s);
  this->y >>= T(s);
  this->z >>= T(s);
  this->w >>= T(s);
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tvec4<T> & tvec4<T>::operator>>=
 (
  tvec4<U> const & v
 )
 {
  this->x >>= T(v.x);
  this->y >>= T(v.y);
  this->z >>= T(v.z);
  this->w >>= T(v.w);
  return *this;
 }




 template <typename T> inline
                    typename tvec4<T>::value_type
 tvec4<T>::swizzle
 (
  comp x
 ) const
 {
  return (*this)[x];
 }

 template <typename T> inline
                    tvec2<T> tvec4<T>::swizzle
 (
  comp x,
  comp y
 ) const
 {
  return tvec2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T> inline
                    tvec3<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 ) const
 {
  return tvec3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T> inline
                    tvec4<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 ) const
 {
  return tvec4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }

 template <typename T> inline
                    tref2<T> tvec4<T>::swizzle
 (
  comp x,
  comp y
 )
 {
  return tref2<T>(
   (*this)[x],
   (*this)[y]);
 }

 template <typename T> inline
                    tref3<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z
 )
 {
  return tref3<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z]);
 }

 template <typename T> inline
                    tref4<T> tvec4<T>::swizzle
 (
  comp x,
  comp y,
  comp z,
  comp w
 )
 {
  return tref4<T>(
   (*this)[x],
   (*this)[y],
   (*this)[z],
   (*this)[w]);
 }




 template <typename T> inline
                    tvec4<T> operator+
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x + s,
   v.y + s,
   v.z + s,
   v.w + s);
 }

 template <typename T> inline
                    tvec4<T> operator+
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s + v.x,
   s + v.y,
   s + v.z,
   s + v.w);
 }

 template <typename T> inline
                    tvec4<T> operator+
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z,
   v1.w + v2.w);
 }


 template <typename T> inline
                    tvec4<T> operator-
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x - s,
   v.y - s,
   v.z - s,
   v.w - s);
 }

 template <typename T> inline
                    tvec4<T> operator-
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s - v.x,
   s - v.y,
   s - v.z,
   s - v.w);
 }

 template <typename T> inline
                    tvec4<T> operator-
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z,
   v1.w - v2.w);
 }


 template <typename T> inline
                    tvec4<T> operator*
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x * s,
   v.y * s,
   v.z * s,
   v.w * s);
 }

 template <typename T> inline
                    tvec4<T> operator*
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s * v.x,
   s * v.y,
   s * v.z,
   s * v.w);
 }

 template <typename T> inline
                    tvec4<T> operator*
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z,
   v1.w * v2.w);
 }


 template <typename T> inline
                    tvec4<T> operator/
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x / s,
   v.y / s,
   v.z / s,
   v.w / s);
 }

 template <typename T> inline
                    tvec4<T> operator/
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s / v.x,
   s / v.y,
   s / v.z,
   s / v.w);
 }

 template <typename T> inline
                    tvec4<T> operator/
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z,
   v1.w / v2.w);
 }


 template <typename T> inline
                    tvec4<T> operator-
 (
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   -v.x,
   -v.y,
   -v.z,
   -v.w);
 }

 template <typename T> inline
                    tvec4<T> operator++
 (
  tvec4<T> const & v,
  int
 )
 {
  typename tvec4<T>::value_type One(1);
  return tvec4<T>(
   v.x + One,
   v.y + One,
   v.z + One,
   v.w + One);
 }

 template <typename T> inline
                    tvec4<T> operator--
 (
  tvec4<T> const & v,
  int
 )
 {
  typename tvec4<T>::value_type One(1);
  return tvec4<T>(
   v.x - One,
   v.y - One,
   v.z - One,
   v.w - One);
 }




 template <typename T> inline
                    bool operator==
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
 }

 template <typename T> inline
                    bool operator!=
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
 }




 template <typename T> inline
                    tvec4<T> operator%
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x % s,
   v.y % s,
   v.z % s,
   v.w % s);
 }

 template <typename T> inline
                    tvec4<T> operator%
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s % v.x,
   s % v.y,
   s % v.z,
   s % v.w);
 }

 template <typename T> inline
                    tvec4<T> operator%
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z,
   v1.w % v2.w);
 }

 template <typename T> inline
                    tvec4<T> operator&
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x & s,
   v.y & s,
   v.z & s,
   v.w & s);
 }

 template <typename T> inline
                    tvec4<T> operator&
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s & v.x,
   s & v.y,
   s & v.z,
   s & v.w);
 }

 template <typename T> inline
                    tvec4<T> operator&
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z,
   v1.w & v2.w);
 }

 template <typename T> inline
                    tvec4<T> operator|
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x | s,
   v.y | s,
   v.z | s,
   v.w | s);
 }

 template <typename T> inline
                    tvec4<T> operator|
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s | v.x,
   s | v.y,
   s | v.z,
   s | v.w);
 }

 template <typename T> inline
                    tvec4<T> operator|
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z,
   v1.w | v2.w);
 }

 template <typename T> inline
                    tvec4<T> operator^
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x ^ s,
   v.y ^ s,
   v.z ^ s,
   v.w ^ s);
 }

 template <typename T> inline
                    tvec4<T> operator^
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s ^ v.x,
   s ^ v.y,
   s ^ v.z,
   s ^ v.w);
 }

 template <typename T> inline
                    tvec4<T> operator^
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z,
   v1.w ^ v2.w);
 }

 template <typename T> inline
                    tvec4<T> operator<<
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x << s,
   v.y << s,
   v.z << s,
   v.w << s);
 }

 template <typename T> inline
                    tvec4<T> operator<<
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s << v.x,
   s << v.y,
   s << v.z,
   s << v.w);
 }

 template <typename T> inline
                    tvec4<T> operator<<
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z,
   v1.w << v2.w);
 }

 template <typename T> inline
                    tvec4<T> operator>>
 (
  tvec4<T> const & v,
  typename tvec4<T>::value_type const & s
 )
 {
  return tvec4<T>(
   v.x >> s,
   v.y >> s,
   v.z >> s,
   v.w >> s);
 }

 template <typename T> inline
                    tvec4<T> operator>>
 (
  typename tvec4<T>::value_type const & s,
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   s >> v.x,
   s >> v.y,
   s >> v.z,
   s >> v.w);
 }

 template <typename T> inline
                    tvec4<T> operator>>
 (
  tvec4<T> const & v1,
  tvec4<T> const & v2
 )
 {
  return tvec4<T>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z,
   v1.w >> v2.w);
 }

 template <typename T> inline
                    tvec4<T> operator~
 (
  tvec4<T> const & v
 )
 {
  return tvec4<T>(
   ~v.x,
   ~v.y,
   ~v.z,
   ~v.w);
 }




 template <typename T>
 tref4<T>::tref4
 (
  T & x,
  T & y,
  T & z,
  T & w
 ) :
  x(x),
  y(y),
  z(z),
  w(w)
 {}

 template <typename T>
 tref4<T>::tref4
 (
  tref4<T> const & r
 ) :
  x(r.x),
  y(r.y),
  z(r.z),
  w(r.w)
 {}

 template <typename T>
 tref4<T>::tref4
 (
  tvec4<T> const & v
 ) :
  x(v.x),
  y(v.y),
  z(v.z),
  w(v.w)
 {}

 template <typename T>
 tref4<T>& tref4<T>::operator=
 (
  tref4<T> const & r
 )
 {
  x = r.x;
  y = r.y;
  z = r.z;
  w = r.w;
  return *this;
 }

 template <typename T>
 tref4<T>& tref4<T>::operator=
 (
  tvec4<T> const & v
 )
 {
  x = v.x;
  y = v.y;
  z = v.z;
  w = v.w;
  return *this;
 }

 template <typename T> inline
                    tvec4<T> tref4<T>::operator() ()
 {
  return tvec4<T>(this->x, this->y, this->z, this->w);
 }

}
}
# 396 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_vec4.hpp" 2
# 41 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.hpp" 1
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.hpp"
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat.hpp"
namespace glm{
namespace detail
{
# 72 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat.hpp"
}
}
# 32 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.hpp" 2


namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat2x2
 {

  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T> col_type;
  typedef tvec2<T> row_type;
  typedef tmat2x2<T> type;
  typedef tmat2x2<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 public:

                tmat2x2<T> _inverse() const;

 private:


  col_type value[2];

 public:


                tmat2x2();
                tmat2x2(
   tmat2x2 const & m);

                explicit tmat2x2(
   ctor Null);
                explicit tmat2x2(
   value_type const & x);
                explicit tmat2x2(
   value_type const & x1, value_type const & y1,
   value_type const & x2, value_type const & y2);
                explicit tmat2x2(
   col_type const & v1,
   col_type const & v2);



  template <typename U>
                explicit tmat2x2(
   U const & x);

  template <typename U, typename V, typename M, typename N>
                explicit tmat2x2(
   U const & x1, V const & y1,
   M const & x2, N const & y2);

  template <typename U, typename V>
                explicit tmat2x2(
   tvec2<U> const & v1,
   tvec2<V> const & v2);



  template <typename U>
                explicit tmat2x2(tmat2x2<U> const & m);

                explicit tmat2x2(tmat3x3<T> const & x);
                explicit tmat2x2(tmat4x4<T> const & x);
                explicit tmat2x2(tmat2x3<T> const & x);
                explicit tmat2x2(tmat3x2<T> const & x);
                explicit tmat2x2(tmat2x4<T> const & x);
                explicit tmat2x2(tmat4x2<T> const & x);
                explicit tmat2x2(tmat3x4<T> const & x);
                explicit tmat2x2(tmat4x3<T> const & x);




                col_type & operator[](size_type i);
                col_type const & operator[](size_type i) const;


                tmat2x2<T> & operator=(tmat2x2<T> const & m);
  template <typename U>
                tmat2x2<T> & operator=(tmat2x2<U> const & m);
  template <typename U>
                tmat2x2<T> & operator+=(U const & s);
  template <typename U>
                tmat2x2<T> & operator+=(tmat2x2<U> const & m);
  template <typename U>
                tmat2x2<T> & operator-=(U const & s);
  template <typename U>
                tmat2x2<T> & operator-=(tmat2x2<U> const & m);
  template <typename U>
                tmat2x2<T> & operator*=(U const & s);
  template <typename U>
                tmat2x2<T> & operator*=(tmat2x2<U> const & m);
  template <typename U>
                tmat2x2<T> & operator/=(U const & s);
  template <typename U>
                tmat2x2<T> & operator/=(tmat2x2<U> const & m);
                tmat2x2<T> & operator++();
                tmat2x2<T> & operator--();
 };


 template <typename T>
 tmat2x2<T> operator+ (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator+ (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator+ (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat2x2<T> operator- (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator- (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator- (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat2x2<T> operator* (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator* (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 typename tmat2x2<T>::col_type operator* (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type const & v);

 template <typename T>
 typename tmat2x2<T>::row_type operator* (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator* (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat3x2<T> operator* (
  tmat2x2<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat2x2<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat2x2<T> operator/ (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s);

 template <typename T>
 tmat2x2<T> operator/ (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m);

 template <typename T>
 typename tmat2x2<T>::col_type operator/ (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type const & v);

 template <typename T>
 typename tmat2x2<T>::row_type operator/ (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator/ (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2);


 template <typename T>
 tmat2x2<T> const operator- (
  tmat2x2<T> const & m);

 template <typename T>
 tmat2x2<T> const operator-- (
  tmat2x2<T> const & m,
  int);

 template <typename T>
 tmat2x2<T> const operator++ (
  tmat2x2<T> const & m,
  int);
}
# 270 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.hpp"
 typedef detail::tmat2x2<lowp_float> lowp_mat2;






 typedef detail::tmat2x2<mediump_float> mediump_mat2;






 typedef detail::tmat2x2<highp_float> highp_mat2;






 typedef detail::tmat2x2<lowp_float> lowp_mat2x2;






 typedef detail::tmat2x2<mediump_float> mediump_mat2x2;






 typedef detail::tmat2x2<highp_float> highp_mat2x2;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat2x2<T>::size_type tmat2x2<T>::length() const
 {
  return 2;
 }

 template <typename T> inline
                    typename tmat2x2<T>::size_type tmat2x2<T>::col_size()
 {
  return 2;
 }

 template <typename T> inline
                    typename tmat2x2<T>::size_type tmat2x2<T>::row_size()
 {
  return 2;
 }




 template <typename T> inline
                    typename tmat2x2<T>::col_type &
 tmat2x2<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat2x2<T>::col_type const &
 tmat2x2<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat2x2<T>::tmat2x2()
 {
  this->value[0] = col_type(1, 0);
  this->value[1] = col_type(0, 1);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  value_type const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero);
  this->value[1] = col_type(Zero, s);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  value_type const & x0, value_type const & y0,
  value_type const & x1, value_type const & y1
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  col_type const & v0,
  col_type const & v1
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T>
 template <typename U>
               tmat2x2<T>::tmat2x2
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec2<T>(value_type(s), Zero);
  this->value[1] = tvec2<T>(Zero, value_type(s));
 }

 template <typename T>
 template <typename X1, typename Y1, typename X2, typename Y2>
               tmat2x2<T>::tmat2x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1));
  this->value[1] = col_type(value_type(x2), value_type(y2));
 }

 template <typename T>
 template <typename V1, typename V2>
               tmat2x2<T>::tmat2x2
 (
  tvec2<V1> const & v1,
  tvec2<V2> const & v2
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T>
 template <typename U> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat2x2<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x2<T>::tmat2x2
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x2<T> tmat2x2<T>::_inverse() const
 {
  typename tmat2x2<T>::value_type Determinant = this->value[0][0] * this->value[1][1] - this->value[1][0] * this->value[0][1];

  tmat2x2<T> Inverse(
   + this->value[1][1] / Determinant,
   - this->value[0][1] / Determinant,
   - this->value[1][0] / Determinant,
   + this->value[0][0] / Determinant);
  return Inverse;
 }





 template <typename T> inline
                    tmat2x2<T>& tmat2x2<T>::operator=
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator=
 (
  tmat2x2<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator+=
 (
  tmat2x2<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator-=
 (
  tmat2x2<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator*=
 (
  tmat2x2<U> const & m
 )
 {
  return (*this = *this * m);
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x2<T>& tmat2x2<T>::operator/=
 (
  tmat2x2<U> const & m
 )
 {
  return (*this = *this / m);
 }

 template <typename T> inline
                    tmat2x2<T>& tmat2x2<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T> inline
                    tmat2x2<T>& tmat2x2<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }




 template <typename T> inline
                    tmat2x2<T> operator+
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
 {
  return tmat2x2<T>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T> inline
                    tmat2x2<T> operator+
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
 {
  return tmat2x2<T>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T> inline
                    tmat2x2<T> operator+
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x2<T>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T> inline
                    tmat2x2<T> operator-
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
 {
  return tmat2x2<T>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T> inline
                    tmat2x2<T> operator-
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
 {
  return tmat2x2<T>(
   s - m[0],
   s - m[1]);
 }

 template <typename T> inline
                    tmat2x2<T> operator-
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x2<T>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T> inline
                    tmat2x2<T> operator*
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
 {
  return tmat2x2<T>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T> inline
                    tmat2x2<T> operator*
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
 {
  return tmat2x2<T>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T> inline
                    typename tmat2x2<T>::col_type operator*
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type const & v
 )
 {
  return detail::tvec2<T>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template <typename T> inline
                    typename tmat2x2<T>::row_type operator*
 (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m
 )
 {
  return detail::tvec2<T>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template <typename T> inline
                    tmat2x2<T> operator*
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template <typename T> inline
                    tmat3x2<T> operator*
 (
  tmat2x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template <typename T> inline
                    tmat4x2<T> operator*
 (
  tmat2x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template <typename T> inline
                    tmat2x2<T> operator/
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::value_type const & s
 )
 {
  return tmat2x2<T>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T> inline
                    tmat2x2<T> operator/
 (
  typename tmat2x2<T>::value_type const & s,
  tmat2x2<T> const & m
 )
 {
  return tmat2x2<T>(
   s / m[0],
   s / m[1]);
 }

 template <typename T> inline
                    typename tmat2x2<T>::col_type operator/
 (
  tmat2x2<T> const & m,
  typename tmat2x2<T>::row_type & v
 )
 {
  return m._inverse() * v;
 }

 template <typename T> inline
                    typename tmat2x2<T>::row_type operator/
 (
  typename tmat2x2<T>::col_type const & v,
  tmat2x2<T> const & m
 )
 {
  return v * m._inverse();
 }

 template <typename T> inline
                    tmat2x2<T> operator/
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return m1 * m2._inverse();
 }


 template <typename T> inline
                    tmat2x2<T> const operator-
 (
  tmat2x2<T> const & m
 )
 {
  return tmat2x2<T>(
   -m[0],
   -m[1]);
 }

 template <typename T> inline
                    tmat2x2<T> const operator++
 (
  tmat2x2<T> const & m,
  int
 )
 {
  return tmat2x2<T>(
   m[0] + T(1),
   m[1] + T(1));
 }

 template <typename T> inline
                    tmat2x2<T> const operator--
 (
  tmat2x2<T> const & m,
  int
 )
 {
  return tmat2x2<T>(
   m[0] - T(1),
   m[1] - T(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat2x2<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }

}
}
# 311 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x2.hpp" 2
# 43 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat2x3
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T> col_type;
  typedef tvec2<T> row_type;
  typedef tmat2x3<T> type;
  typedef tmat3x2<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 private:

  col_type value[2];

 public:

                tmat2x3();
                tmat2x3(tmat2x3 const & m);

                explicit tmat2x3(
   ctor);
                explicit tmat2x3(
   value_type const & s);
                explicit tmat2x3(
   value_type const & x0, value_type const & y0, value_type const & z0,
   value_type const & x1, value_type const & y1, value_type const & z1);
                explicit tmat2x3(
   col_type const & v0,
   col_type const & v1);



  template <typename U>
                explicit tmat2x3(
   U const & x);

  template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
                explicit tmat2x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2);

  template <typename U, typename V>
                explicit tmat2x3(
   tvec3<U> const & v1,
   tvec3<V> const & v2);



  template <typename U>
                explicit tmat2x3(tmat2x3<U> const & m);

                explicit tmat2x3(tmat2x2<T> const & x);
                explicit tmat2x3(tmat3x3<T> const & x);
                explicit tmat2x3(tmat4x4<T> const & x);
                explicit tmat2x3(tmat2x4<T> const & x);
                explicit tmat2x3(tmat3x2<T> const & x);
                explicit tmat2x3(tmat3x4<T> const & x);
                explicit tmat2x3(tmat4x2<T> const & x);
                explicit tmat2x3(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


                tmat2x3<T> & operator= (tmat2x3<T> const & m);
  template <typename U>
                tmat2x3<T> & operator= (tmat2x3<U> const & m);
  template <typename U>
                tmat2x3<T> & operator+= (U const & s);
  template <typename U>
                tmat2x3<T> & operator+= (tmat2x3<U> const & m);
  template <typename U>
                tmat2x3<T> & operator-= (U const & s);
  template <typename U>
                tmat2x3<T> & operator-= (tmat2x3<U> const & m);
  template <typename U>
                tmat2x3<T> & operator*= (U const & s);
  template <typename U>
                tmat2x3<T> & operator*= (tmat2x3<U> const & m);
  template <typename U>
                tmat2x3<T> & operator/= (U const & s);

                tmat2x3<T> & operator++ ();
                tmat2x3<T> & operator-- ();
 };


 template <typename T>
 tmat2x3<T> operator+ (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator+ (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat2x3<T> operator- (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator- (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat2x3<T> operator* (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator* (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m);

 template <typename T>
 typename tmat2x3<T>::col_type operator* (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::row_type const & v);

 template <typename T>
 typename tmat2x3<T>::row_type operator* (
  typename tmat2x3<T>::col_type const & v,
  tmat2x3<T> const & m);

 template <typename T>
 tmat2x3<T> operator* (
  tmat2x3<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat3x3<T> operator* (
  tmat2x3<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat2x3<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat2x3<T> operator/ (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s);

 template <typename T>
 tmat2x3<T> operator/ (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m);


 template <typename T>
 tmat2x3<T> const operator- (
  tmat2x3<T> const & m);

 template <typename T>
 tmat2x3<T> const operator-- (
  tmat2x3<T> const & m,
  int);

 template <typename T>
 tmat2x3<T> const operator++ (
  tmat2x3<T> const & m,
  int);

}
# 235 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.hpp"
 typedef detail::tmat2x3<lowp_float> lowp_mat2x3;






 typedef detail::tmat2x3<mediump_float> mediump_mat2x3;






 typedef detail::tmat2x3<highp_float> highp_mat2x3;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat2x3<T>::size_type tmat2x3<T>::length() const
 {
  return 2;
 }

 template <typename T> inline
                    typename tmat2x3<T>::size_type tmat2x3<T>::col_size()
 {
  return 3;
 }

 template <typename T> inline
                    typename tmat2x3<T>::size_type tmat2x3<T>::row_size()
 {
  return 2;
 }




 template <typename T> inline
                    typename tmat2x3<T>::col_type &
 tmat2x3<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat2x3<T>::col_type const &
 tmat2x3<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat2x3<T>::tmat2x3()
 {
  this->value[0] = col_type(T(1), T(0), T(0));
  this->value[1] = col_type(T(0), T(1), T(0));
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  value_type const & s
 )
 {
  this->value[0] = col_type(s, T(0), T(0));
  this->value[1] = col_type(T(0), s, T(0));
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  value_type const & x0, value_type const & y0, value_type const & z0,
  value_type const & x1, value_type const & y1, value_type const & z1
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  col_type const & v0,
  col_type const & v1
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T>
 template <typename U>
               tmat2x3<T>::tmat2x3
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
  this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
               tmat2x3<T>::tmat2x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
 }

 template <typename T>
 template <typename V1, typename V2>
               tmat2x3<T>::tmat2x3
 (
  tvec3<V1> const & v1,
  tvec3<V2> const & v2
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T>
 template <typename U> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat2x3<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T> inline
                    tmat2x3<T>::tmat2x3
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }




 template <typename T> inline
                    tmat2x3<T>& tmat2x3<T>::operator=
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T>& tmat2x3<T>::operator=
 (
  tmat2x3<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T> & tmat2x3<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T>& tmat2x3<T>::operator+=
 (
  tmat2x3<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T>& tmat2x3<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T>& tmat2x3<T>::operator-=
 (
  tmat2x3<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T>& tmat2x3<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T> & tmat2x3<T>::operator*=
 (
  tmat2x3<U> const & m
 )
 {
  return (*this = tmat2x3<U>(*this * m));
 }

 template <typename T>
 template <typename U> inline
                    tmat2x3<T> & tmat2x3<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T> inline
                    tmat2x3<T> & tmat2x3<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T> inline
                    tmat2x3<T> & tmat2x3<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }




 template <typename T> inline
                    tmat2x3<T> operator+
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
 {
  return tmat2x3<T>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T> inline
                    tmat2x3<T> operator+
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T> inline
                    tmat2x3<T> operator-
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
 {
  return tmat2x3<T>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T> inline
                    tmat2x3<T> operator-
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T> inline
                    tmat2x3<T> operator*
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
 {
  return tmat2x3<T>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T> inline
                    tmat2x3<T> operator*
 (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m
 )
 {
  return tmat2x3<T>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T> inline
                    typename tmat2x3<T>::col_type operator*
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::row_type const & v)
 {
  return typename tmat2x3<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template <typename T> inline
                    typename tmat2x3<T>::row_type operator*
 (
  typename tmat2x3<T>::col_type const & v,
  tmat2x3<T> const & m)
 {
  return typename tmat2x3<T>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template <typename T> inline
                    tmat2x3<T> operator*
 (
  tmat2x3<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template <typename T> inline
                    tmat3x3<T> operator*
 (
  tmat2x3<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  typename tmat2x3<T>::value_type SrcA00 = m1[0][0];
  typename tmat2x3<T>::value_type SrcA01 = m1[0][1];
  typename tmat2x3<T>::value_type SrcA02 = m1[0][2];
  typename tmat2x3<T>::value_type SrcA10 = m1[1][0];
  typename tmat2x3<T>::value_type SrcA11 = m1[1][1];
  typename tmat2x3<T>::value_type SrcA12 = m1[1][2];

  typename tmat2x3<T>::value_type SrcB00 = m2[0][0];
  typename tmat2x3<T>::value_type SrcB01 = m2[0][1];
  typename tmat2x3<T>::value_type SrcB10 = m2[1][0];
  typename tmat2x3<T>::value_type SrcB11 = m2[1][1];
  typename tmat2x3<T>::value_type SrcB20 = m2[2][0];
  typename tmat2x3<T>::value_type SrcB21 = m2[2][1];

  tmat3x3<T> Result(tmat3x3<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template <typename T> inline
                    tmat4x3<T> operator*
 (
  tmat2x3<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return tmat4x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template <typename T> inline
                    tmat2x3<T> operator/
 (
  tmat2x3<T> const & m,
  typename tmat2x3<T>::value_type const & s
 )
 {
  return tmat2x3<T>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T> inline
                    tmat2x3<T> operator/
 (
  typename tmat2x3<T>::value_type const & s,
  tmat2x3<T> const & m
 )
 {
  return tmat2x3<T>(
   s / m[0],
   s / m[1]);
 }


 template <typename T> inline
                    tmat2x3<T> const operator-
 (
  tmat2x3<T> const & m
 )
 {
  return tmat2x3<T>(
   -m[0],
   -m[1]);
 }

 template <typename T> inline
                    tmat2x3<T> const operator++
 (
  tmat2x3<T> const & m,
  int
 )
 {
  return tmat2x3<T>(
   m[0] + typename tmat2x3<T>::value_type(1),
   m[1] + typename tmat2x3<T>::value_type(1));
 }

 template <typename T> inline
                    tmat2x3<T> const operator--
 (
  tmat2x3<T> const & m,
  int
 )
 {
  return tmat2x3<T>(
   m[0] - typename tmat2x3<T>::value_type(1),
   m[1] - typename tmat2x3<T>::value_type(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat2x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
}
# 255 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x3.hpp" 2
# 44 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat2x4
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T> col_type;
  typedef tvec2<T> row_type;
  typedef tmat2x4<T> type;
  typedef tmat4x2<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 private:

  col_type value[2];

 public:

                tmat2x4();
                tmat2x4(tmat2x4 const & m);

                explicit tmat2x4(
   ctor);
                explicit tmat2x4(
   value_type const & s);
                explicit tmat2x4(
   value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
   value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1);
                explicit tmat2x4(
   col_type const & v0,
   col_type const & v1);



  template <typename U>
                explicit tmat2x4(
   U const & x);

  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
                explicit tmat2x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2);

  template <typename U, typename V>
                explicit tmat2x4(
   tvec4<U> const & v1,
   tvec4<V> const & v2);



  template <typename U>
                explicit tmat2x4(tmat2x4<U> const & m);

                explicit tmat2x4(tmat2x2<T> const & x);
                explicit tmat2x4(tmat3x3<T> const & x);
                explicit tmat2x4(tmat4x4<T> const & x);
                explicit tmat2x4(tmat2x3<T> const & x);
                explicit tmat2x4(tmat3x2<T> const & x);
                explicit tmat2x4(tmat3x4<T> const & x);
                explicit tmat2x4(tmat4x2<T> const & x);
                explicit tmat2x4(tmat4x3<T> const & x);


                col_type & operator[](size_type i);
                col_type const & operator[](size_type i) const;


                tmat2x4<T>& operator= (tmat2x4<T> const & m);
  template <typename U>
                tmat2x4<T>& operator= (tmat2x4<U> const & m);
  template <typename U>
                tmat2x4<T>& operator+= (U const & s);
  template <typename U>
                tmat2x4<T>& operator+= (tmat2x4<U> const & m);
  template <typename U>
                tmat2x4<T>& operator-= (U const & s);
  template <typename U>
                tmat2x4<T>& operator-= (tmat2x4<U> const & m);
  template <typename U>
                tmat2x4<T>& operator*= (U const & s);
  template <typename U>
                tmat2x4<T>& operator*= (tmat2x4<U> const & m);
  template <typename U>
                tmat2x4<T>& operator/= (U const & s);

                tmat2x4<T>& operator++ ();
                tmat2x4<T>& operator-- ();
 };


 template <typename T>
 tmat2x4<T> operator+ (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator+ (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat2x4<T> operator- (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator- (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat2x4<T> operator* (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator* (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m);

 template <typename T>
 typename tmat2x4<T>::col_type operator* (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::row_type const & v);

 template <typename T>
 typename tmat2x4<T>::row_type operator* (
  typename tmat2x4<T>::col_type const & v,
  tmat2x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator* (
  tmat2x4<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat2x4<T> operator* (
  tmat2x4<T> const & m1,
  tmat2x2<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat2x4<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat2x4<T> operator/ (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s);

 template <typename T>
 tmat2x4<T> operator/ (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m);


 template <typename T>
 tmat2x4<T> const operator- (
  tmat2x4<T> const & m);

 template <typename T>
 tmat2x4<T> const operator-- (
  tmat2x4<T> const & m,
  int);

 template <typename T>
 tmat2x4<T> const operator++ (
  tmat2x4<T> const & m,
  int);

}
# 237 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.hpp"
 typedef detail::tmat2x4<lowp_float> lowp_mat2x4;






 typedef detail::tmat2x4<mediump_float> mediump_mat2x4;






 typedef detail::tmat2x4<highp_float> highp_mat2x4;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat2x4<T>::size_type tmat2x4<T>::length() const
 {
  return 2;
 }

 template <typename T> inline
                    typename tmat2x4<T>::size_type tmat2x4<T>::col_size()
 {
  return 4;
 }

 template <typename T> inline
                    typename tmat2x4<T>::size_type tmat2x4<T>::row_size()
 {
  return 2;
 }




 template <typename T> inline
                    typename tmat2x4<T>::col_type &
 tmat2x4<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat2x4<T>::col_type const &
 tmat2x4<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat2x4<T>::tmat2x4()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero, Zero);
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  value_type const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, Zero, Zero, Zero);
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
  value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  col_type const & v0,
  col_type const & v1
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T>
 template <typename U>
               tmat2x4<T>::tmat2x4
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
  this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
               tmat2x4<T>::tmat2x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
 }

 template <typename T>
 template <typename V1, typename V2>
               tmat2x4<T>::tmat2x4
 (
  tvec4<V1> const & v1,
  tvec4<V2> const & v2
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T>
 template <typename U> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat2x4<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T>(0));
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T>(0));
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(T(0)));
  this->value[1] = col_type(m[1], detail::tvec2<T>(T(0)));
 }

 template <typename T> inline
                    tmat2x4<T>::tmat2x4
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
 }




 template <typename T> inline
                    tmat2x4<T>& tmat2x4<T>::operator=
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T>& tmat2x4<T>::operator=
 (
  tmat2x4<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T>& tmat2x4<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T>& tmat2x4<T>::operator+=
 (
  tmat2x4<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T>& tmat2x4<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T>& tmat2x4<T>::operator-=
 (
  tmat2x4<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T>& tmat2x4<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T>& tmat2x4<T>::operator*=
 (
  tmat2x4<U> const & m
 )
 {
  return (*this = tmat2x4<T>(*this * m));
 }

 template <typename T>
 template <typename U> inline
                    tmat2x4<T> & tmat2x4<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T> inline
                    tmat2x4<T>& tmat2x4<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T> inline
                    tmat2x4<T>& tmat2x4<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }




 template <typename T> inline
                    tmat2x4<T> operator+
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
 {
  return tmat2x4<T>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T> inline
                    tmat2x4<T> operator+
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T> inline
                    tmat2x4<T> operator-
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
 {
  return tmat2x4<T>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T> inline
                    tmat2x4<T> operator-
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T> inline
                    tmat2x4<T> operator*
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
 {
  return tmat2x4<T>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T> inline
                    tmat2x4<T> operator*
 (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m
 )
 {
  return tmat2x4<T>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T> inline
                    typename tmat2x4<T>::col_type operator*
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::row_type const & v
 )
 {
  return typename tmat2x4<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template <typename T> inline
                    typename tmat2x4<T>::row_type operator*
 (
  typename tmat2x4<T>::col_type const & v,
  tmat2x4<T> const & m
 )
 {
  return typename tmat2x4<T>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template <typename T> inline
                    tmat4x4<T> operator*
 (
  tmat2x4<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  typename tmat2x4<T>::value_type SrcA00 = m1[0][0];
  typename tmat2x4<T>::value_type SrcA01 = m1[0][1];
  typename tmat2x4<T>::value_type SrcA02 = m1[0][2];
  typename tmat2x4<T>::value_type SrcA03 = m1[0][3];
  typename tmat2x4<T>::value_type SrcA10 = m1[1][0];
  typename tmat2x4<T>::value_type SrcA11 = m1[1][1];
  typename tmat2x4<T>::value_type SrcA12 = m1[1][2];
  typename tmat2x4<T>::value_type SrcA13 = m1[1][3];

  typename tmat2x4<T>::value_type SrcB00 = m2[0][0];
  typename tmat2x4<T>::value_type SrcB01 = m2[0][1];
  typename tmat2x4<T>::value_type SrcB10 = m2[1][0];
  typename tmat2x4<T>::value_type SrcB11 = m2[1][1];
  typename tmat2x4<T>::value_type SrcB20 = m2[2][0];
  typename tmat2x4<T>::value_type SrcB21 = m2[2][1];
  typename tmat2x4<T>::value_type SrcB30 = m2[3][0];
  typename tmat2x4<T>::value_type SrcB31 = m2[3][1];

  tmat4x4<T> Result(tmat4x4<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template <typename T> inline
                    tmat2x4<T> operator*
 (
  tmat2x4<T> const & m1,
  tmat2x2<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template <typename T> inline
                    tmat3x4<T> operator*
 (
  tmat2x4<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template <typename T> inline
                    tmat2x4<T> operator/
 (
  tmat2x4<T> const & m,
  typename tmat2x4<T>::value_type const & s
 )
 {
  return tmat2x4<T>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T> inline
                    tmat2x4<T> operator/
 (
  typename tmat2x4<T>::value_type const & s,
  tmat2x4<T> const & m
 )
 {
  return tmat2x4<T>(
   s / m[0],
   s / m[1]);
 }


 template <typename T> inline
                    tmat2x4<T> const operator-
 (
  tmat2x4<T> const & m
 )
 {
  return tmat2x4<T>(
   -m[0],
   -m[1]);
 }

 template <typename T> inline
                    tmat2x4<T> const operator++
 (
  tmat2x4<T> const & m,
  int
 )
 {
  return tmat2x4<T>(
   m[0] + typename tmat2x4<T>::value_type(1),
   m[1] + typename tmat2x4<T>::value_type(1));
 }

 template <typename T> inline
                    tmat2x4<T> const operator--
 (
  tmat2x4<T> const & m,
  int
 )
 {
  return tmat2x4<T>(
   m[0] - typename tmat2x4<T>::value_type(1),
   m[1] - typename tmat2x4<T>::value_type(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat2x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
}
# 257 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat2x4.hpp" 2
# 45 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat3x2
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T> col_type;
  typedef tvec3<T> row_type;
  typedef tmat3x2<T> type;
  typedef tmat2x3<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 private:

  col_type value[3];

 public:

                tmat3x2();
                tmat3x2(tmat3x2 const & m);

                explicit tmat3x2(
   ctor);
                explicit tmat3x2(
   value_type const & s);
                explicit tmat3x2(
   value_type const & x0, value_type const & y0,
   value_type const & x1, value_type const & y1,
   value_type const & x2, value_type const & y2);
                explicit tmat3x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template <typename U>
                explicit tmat3x2(
   U const & x);

  template
  <
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3
  >
                explicit tmat3x2(
   X1 const & x1, Y1 const & y1,
   X2 const & x2, Y2 const & y2,
   X3 const & x3, Y3 const & y3);

  template <typename V1, typename V2, typename V3>
                explicit tmat3x2(
   tvec2<V1> const & v1,
   tvec2<V2> const & v2,
   tvec2<V3> const & v3);


  template <typename U>
                explicit tmat3x2(tmat3x2<U> const & m);

                explicit tmat3x2(tmat2x2<T> const & x);
                explicit tmat3x2(tmat3x3<T> const & x);
                explicit tmat3x2(tmat4x4<T> const & x);
                explicit tmat3x2(tmat2x3<T> const & x);
                explicit tmat3x2(tmat2x4<T> const & x);
                explicit tmat3x2(tmat3x4<T> const & x);
                explicit tmat3x2(tmat4x2<T> const & x);
                explicit tmat3x2(tmat4x3<T> const & x);


                col_type & operator[](size_type i);
                col_type const & operator[](size_type i) const;


                tmat3x2<T> & operator= (tmat3x2<T> const & m);
  template <typename U>
                tmat3x2<T> & operator= (tmat3x2<U> const & m);
  template <typename U>
                tmat3x2<T> & operator+= (U const & s);
  template <typename U>
                tmat3x2<T> & operator+= (tmat3x2<U> const & m);
  template <typename U>
                tmat3x2<T> & operator-= (U const & s);
  template <typename U>
                tmat3x2<T> & operator-= (tmat3x2<U> const & m);
  template <typename U>
                tmat3x2<T> & operator*= (U const & s);
  template <typename U>
                tmat3x2<T> & operator*= (tmat3x2<U> const & m);
  template <typename U>
                tmat3x2<T> & operator/= (U const & s);

                tmat3x2<T> & operator++ ();
                tmat3x2<T> & operator-- ();
 };


 template <typename T>
 tmat3x2<T> operator+ (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator+ (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat3x2<T> operator- (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator- (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2);

 template <typename T>
 tmat3x2<T> operator* (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator* (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m);

 template <typename T>
 typename tmat3x2<T>::col_type operator* (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::row_type const & v);

 template <typename T>
 typename tmat3x2<T>::row_type operator* (
  typename tmat3x2<T>::col_type const & v,
  tmat3x2<T> const & m);

 template <typename T>
 tmat2x2<T> operator* (
  tmat3x2<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat3x2<T> operator* (
  tmat3x2<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat3x2<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat3x2<T> operator/ (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s);

 template <typename T>
 tmat3x2<T> operator/ (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m);


 template <typename T>
 tmat3x2<T> const operator- (
  tmat3x2<T> const & m);

 template <typename T>
 tmat3x2<T> const operator-- (
  tmat3x2<T> const & m,
  int);

 template <typename T>
 tmat3x2<T> const operator++ (
  tmat3x2<T> const & m,
  int);
}
# 242 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.hpp"
 typedef detail::tmat3x2<lowp_float> lowp_mat3x2;






 typedef detail::tmat3x2<mediump_float> mediump_mat3x2;






 typedef detail::tmat3x2<highp_float> highp_mat3x2;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat3x2<T>::size_type tmat3x2<T>::length() const
 {
  return 3;
 }

 template <typename T> inline
                    typename tmat3x2<T>::size_type tmat3x2<T>::col_size()
 {
  return 2;
 }

 template <typename T> inline
                    typename tmat3x2<T>::size_type tmat3x2<T>::row_size()
 {
  return 3;
 }




 template <typename T> inline
                    typename tmat3x2<T>::col_type &
 tmat3x2<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat3x2<T>::col_type const &
 tmat3x2<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat3x2<T>::tmat3x2()
 {
  this->value[0] = col_type(1, 0);
  this->value[1] = col_type(0, 1);
  this->value[2] = col_type(0, 0);
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  value_type const & s
 )
 {
  this->value[0] = col_type(s, 0);
  this->value[1] = col_type(0, s);
  this->value[2] = col_type(0, 0);
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  value_type const & x0, value_type const & y0,
  value_type const & x1, value_type const & y1,
  value_type const & x2, value_type const & y2
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T>
 template <typename U>
               tmat3x2<T>::tmat3x2
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec2<T>(value_type(s), Zero);
  this->value[1] = tvec2<T>(Zero, value_type(s));
  this->value[2] = tvec2<T>(Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
               tmat3x2<T>::tmat3x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1));
  this->value[1] = col_type(value_type(x2), value_type(y2));
  this->value[2] = col_type(value_type(x3), value_type(y3));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3>
               tmat3x2<T>::tmat3x2
 (
  tvec2<V1> const & v1,
  tvec2<V2> const & v2,
  tvec2<V3> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }




 template <typename T>
 template <typename U> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat3x2<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(T(0));
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }

 template <typename T> inline
                    tmat3x2<T>::tmat3x2
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }




 template <typename T> inline
                    tmat3x2<T>& tmat3x2<T>::operator=
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T>& tmat3x2<T>::operator=
 (
  tmat3x2<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T>& tmat3x2<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T>& tmat3x2<T>::operator+=
 (
  tmat3x2<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T>& tmat3x2<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T>& tmat3x2<T>::operator-=
 (
  tmat3x2<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T>& tmat3x2<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T>& tmat3x2<T>::operator*=
 (
  tmat3x2<U> const & m
 )
 {
  return (*this = tmat3x2<T>(*this * m));
 }

 template <typename T>
 template <typename U> inline
                    tmat3x2<T> & tmat3x2<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T> inline
                    tmat3x2<T>& tmat3x2<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T> inline
                    tmat3x2<T>& tmat3x2<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }




 template <typename T> inline
                    tmat3x2<T> operator+
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
 {
  return tmat3x2<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T> inline
                    tmat3x2<T> operator+
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T> inline
                    tmat3x2<T> operator-
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
 {
  return tmat3x2<T>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T> inline
                    tmat3x2<T> operator-
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T> inline
                    tmat3x2<T> operator*
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
 {
  return tmat3x2<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T> inline
                    tmat3x2<T> operator*
 (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m
 )
 {
  return tmat3x2<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T> inline
                    typename tmat3x2<T>::col_type operator*
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::row_type const & v)
 {
  return typename tmat3x2<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template <typename T> inline
                    typename tmat3x2<T>::row_type operator*
 (
  typename tmat3x2<T>::col_type const & v,
  tmat3x2<T> const & m)
 {
  return typename tmat3x2<T>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template <typename T> inline
                    tmat2x2<T> operator*
 (
  tmat3x2<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  tmat2x2<T> Result(tmat2x2<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template <typename T> inline
                    tmat3x2<T> operator*
 (
  tmat3x2<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template <typename T> inline
                    tmat4x2<T> operator*
 (
  tmat3x2<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template <typename T> inline
                    tmat3x2<T> operator/
 (
  tmat3x2<T> const & m,
  typename tmat3x2<T>::value_type const & s
 )
 {
  return tmat3x2<T>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T> inline
                    tmat3x2<T> operator/
 (
  typename tmat3x2<T>::value_type const & s,
  tmat3x2<T> const & m
 )
 {
  return tmat3x2<T>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }


 template <typename T> inline
                    tmat3x2<T> const operator-
 (
  tmat3x2<T> const & m
 )
 {
  return tmat3x2<T>(
   -m[0],
   -m[1],
   -m[2]);
 }

 template <typename T> inline
                    tmat3x2<T> const operator++
 (
  tmat3x2<T> const & m,
  int
 )
 {
  typename tmat3x2<T>::value_type One(1);
  return tmat3x2<T>(
   m[0] + One,
   m[1] + One,
   m[2] + One);
 }

 template <typename T> inline
                    tmat3x2<T> const operator--
 (
  tmat3x2<T> const & m,
  int
 )
 {
  typename tmat3x2<T>::value_type One(1);
  return tmat3x2<T>(
   m[0] - One,
   m[1] - One,
   m[2] - One);
 }




 template <typename T> inline
                    bool operator==
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat3x2<T> const & m1,
  tmat3x2<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }

}
}
# 262 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x2.hpp" 2
# 46 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat3x3
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T> col_type;
  typedef tvec3<T> row_type;
  typedef tmat3x3<T> type;
  typedef tmat3x3<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 public:


                tmat3x3<T> _inverse() const;


 private:

  col_type value[3];

 public:

                tmat3x3();
                tmat3x3(tmat3x3 const & m);

                explicit tmat3x3(
   ctor Null);
                explicit tmat3x3(
   value_type const & s);
                explicit tmat3x3(
   value_type const & x0, value_type const & y0, value_type const & z0,
   value_type const & x1, value_type const & y1, value_type const & z1,
   value_type const & x2, value_type const & y2, value_type const & z2);
                explicit tmat3x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template <typename U>
                explicit tmat3x3(
   U const & x);

  template
  <
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3
  >
                explicit tmat3x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3);

  template <typename V1, typename V2, typename V3>
                explicit tmat3x3(
   tvec3<V1> const & v1,
   tvec3<V2> const & v2,
   tvec3<V3> const & v3);


  template <typename U>
                explicit tmat3x3(tmat3x3<U> const & m);

                explicit tmat3x3(tmat2x2<T> const & x);
                explicit tmat3x3(tmat4x4<T> const & x);
                explicit tmat3x3(tmat2x3<T> const & x);
                explicit tmat3x3(tmat3x2<T> const & x);
                explicit tmat3x3(tmat2x4<T> const & x);
                explicit tmat3x3(tmat4x2<T> const & x);
                explicit tmat3x3(tmat3x4<T> const & x);
                explicit tmat3x3(tmat4x3<T> const & x);


                col_type & operator[](size_type i);
                col_type const & operator[](size_type i) const;


                tmat3x3<T>& operator= (tmat3x3<T> const & m);
  template <typename U>
                tmat3x3<T>& operator= (tmat3x3<U> const & m);
  template <typename U>
                tmat3x3<T>& operator+= (U const & s);
  template <typename U>
                tmat3x3<T>& operator+= (tmat3x3<U> const & m);
  template <typename U>
                tmat3x3<T>& operator-= (U const & s);
  template <typename U>
                tmat3x3<T>& operator-= (tmat3x3<U> const & m);
  template <typename U>
                tmat3x3<T>& operator*= (U const & s);
  template <typename U>
                tmat3x3<T>& operator*= (tmat3x3<U> const & m);
  template <typename U>
                tmat3x3<T>& operator/= (U const & s);
  template <typename U>
                tmat3x3<T>& operator/= (tmat3x3<U> const & m);
                tmat3x3<T>& operator++ ();
                tmat3x3<T>& operator-- ();
 };


 template <typename T>
 tmat3x3<T> operator+ (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator+ (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator+ (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat3x3<T> operator- (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator- (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator- (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat3x3<T> operator* (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator* (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 typename tmat3x3<T>::col_type operator* (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v);

 template <typename T>
 typename tmat3x3<T>::row_type operator* (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator* (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat2x3<T> operator* (
  tmat3x3<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat3x3<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat3x3<T> operator/ (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s);

 template <typename T>
 tmat3x3<T> operator/ (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m);

 template <typename T>
 typename tmat3x3<T>::col_type operator/ (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v);

 template <typename T>
 typename tmat3x3<T>::row_type operator/ (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> operator/ (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2);


 template <typename T>
 tmat3x3<T> const operator- (
  tmat3x3<T> const & m);

 template <typename T>
 tmat3x3<T> const operator-- (
  tmat3x3<T> const & m,
  int);

 template <typename T>
 tmat3x3<T> const operator++ (
  tmat3x3<T> const & m,
  int);
}
# 274 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.hpp"
 typedef detail::tmat3x3<lowp_float> lowp_mat3;






 typedef detail::tmat3x3<mediump_float> mediump_mat3;






 typedef detail::tmat3x3<highp_float> highp_mat3;






 typedef detail::tmat3x3<lowp_float> lowp_mat3x3;






 typedef detail::tmat3x3<mediump_float> mediump_mat3x3;






 typedef detail::tmat3x3<highp_float> highp_mat3x3;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat3x3<T>::size_type tmat3x3<T>::length() const
 {
  return 3;
 }

 template <typename T> inline
                    typename tmat3x3<T>::size_type tmat3x3<T>::col_size()
 {
  return 3;
 }

 template <typename T> inline
                    typename tmat3x3<T>::size_type tmat3x3<T>::row_size()
 {
  return 3;
 }




 template <typename T> inline
                    typename tmat3x3<T>::col_type &
 tmat3x3<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat3x3<T>::col_type const &
 tmat3x3<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat3x3<T>::tmat3x3()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero);
  this->value[2] = col_type(Zero, Zero, One);
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  value_type const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero);
  this->value[2] = col_type(Zero, Zero, s);
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  value_type const & x0, value_type const & y0, value_type const & z0,
  value_type const & x1, value_type const & y1, value_type const & z1,
  value_type const & x2, value_type const & y2, value_type const & z2
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T>
 template <typename U>
               tmat3x3<T>::tmat3x3
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
  this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
  this->value[2] = tvec3<T>(Zero, Zero, value_type(s));
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
               tmat3x3<T>::tmat3x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3>
               tmat3x3<T>::tmat3x3
 (
  tvec3<V1> const & v1,
  tvec3<V2> const & v2,
  tvec3<V3> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }




 template <typename T>
 template <typename U> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat3x3<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(detail::tvec2<T>(0), value_type(1));
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x3<T>::tmat3x3
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }




 template <typename T> inline
                    tmat3x3<T> & tmat3x3<T>::operator=
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator=
 (
  tmat3x3<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator+=
 (
  tmat3x3<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator-=
 (
  tmat3x3<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator*=
 (
  tmat3x3<U> const & m
 )
 {
  return (*this = *this * m);
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x3<T> & tmat3x3<T>::operator/=
 (
  tmat3x3<U> const & m
 )
 {
  return (*this = *this / m);
 }

 template <typename T> inline
                    tmat3x3<T> & tmat3x3<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T> inline
                    tmat3x3<T> & tmat3x3<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T> inline
                    tmat3x3<T> tmat3x3<T>::_inverse() const
 {
  T S00 = value[0][0];
  T S01 = value[0][1];
  T S02 = value[0][2];

  T S10 = value[1][0];
  T S11 = value[1][1];
  T S12 = value[1][2];

  T S20 = value[2][0];
  T S21 = value[2][1];
  T S22 = value[2][2];
# 463 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.inl"
  tmat3x3<T> Inverse(
   S11 * S22 - S21 * S12,
   S12 * S20 - S22 * S10,
   S10 * S21 - S20 * S11,
   S02 * S21 - S01 * S22,
   S00 * S22 - S02 * S20,
   S01 * S20 - S00 * S21,
   S12 * S01 - S11 * S02,
   S10 * S02 - S12 * S00,
   S11 * S00 - S10 * S01);

  T Determinant = S00 * (S11 * S22 - S21 * S12)
      - S10 * (S01 * S22 - S21 * S02)
      + S20 * (S01 * S12 - S11 * S02);

  Inverse /= Determinant;
  return Inverse;
 }




 template <typename T> inline
                    tmat3x3<T> operator+
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
 {
  return tmat3x3<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T> inline
                    tmat3x3<T> operator+
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
 {
  return tmat3x3<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T> inline
                    tmat3x3<T> operator+
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return tmat3x3<T>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T> inline
                    tmat3x3<T> operator-
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
 {
  return tmat3x3<T>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T> inline
                    tmat3x3<T> operator-
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
 {
  return tmat3x3<T>(
   s - m[0],
   s - m[1],
   s - m[2]);
 }

 template <typename T> inline
                    tmat3x3<T> operator-
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return tmat3x3<T>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T> inline
                    tmat3x3<T> operator*
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
 {
  return tmat3x3<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T> inline
                    tmat3x3<T> operator*
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
 {
  return tmat3x3<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T> inline
                    typename tmat3x3<T>::col_type operator*
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v
 )
 {
  return typename tmat3x3<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template <typename T> inline
                    typename tmat3x3<T>::row_type operator*
 (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m
 )
 {
  return typename tmat3x3<T>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template <typename T> inline
                    tmat3x3<T> operator*
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  typename tmat3x3<T>::value_type const SrcA00 = m1[0][0];
  typename tmat3x3<T>::value_type const SrcA01 = m1[0][1];
  typename tmat3x3<T>::value_type const SrcA02 = m1[0][2];
  typename tmat3x3<T>::value_type const SrcA10 = m1[1][0];
  typename tmat3x3<T>::value_type const SrcA11 = m1[1][1];
  typename tmat3x3<T>::value_type const SrcA12 = m1[1][2];
  typename tmat3x3<T>::value_type const SrcA20 = m1[2][0];
  typename tmat3x3<T>::value_type const SrcA21 = m1[2][1];
  typename tmat3x3<T>::value_type const SrcA22 = m1[2][2];

  typename tmat3x3<T>::value_type const SrcB00 = m2[0][0];
  typename tmat3x3<T>::value_type const SrcB01 = m2[0][1];
  typename tmat3x3<T>::value_type const SrcB02 = m2[0][2];
  typename tmat3x3<T>::value_type const SrcB10 = m2[1][0];
  typename tmat3x3<T>::value_type const SrcB11 = m2[1][1];
  typename tmat3x3<T>::value_type const SrcB12 = m2[1][2];
  typename tmat3x3<T>::value_type const SrcB20 = m2[2][0];
  typename tmat3x3<T>::value_type const SrcB21 = m2[2][1];
  typename tmat3x3<T>::value_type const SrcB22 = m2[2][2];

  tmat3x3<T> Result(tmat3x3<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template <typename T> inline
                    tmat2x3<T> operator*
 (
  tmat3x3<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template <typename T> inline
                    tmat4x3<T> operator*
 (
  tmat3x3<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return tmat4x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template <typename T> inline
                    tmat3x3<T> operator/
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::value_type const & s
 )
 {
  return tmat3x3<T>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T> inline
                    tmat3x3<T> operator/
 (
  typename tmat3x3<T>::value_type const & s,
  tmat3x3<T> const & m
 )
 {
  return tmat3x3<T>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }

 template <typename T> inline
                    typename tmat3x3<T>::col_type operator/
 (
  tmat3x3<T> const & m,
  typename tmat3x3<T>::row_type const & v
 )
 {
  return m._inverse() * v;
 }

 template <typename T> inline
                    typename tmat3x3<T>::row_type operator/
 (
  typename tmat3x3<T>::col_type const & v,
  tmat3x3<T> const & m
 )
 {
  return v * m._inverse();
 }

 template <typename T> inline
                    tmat3x3<T> operator/
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return m1 * m2._inverse();
 }


 template <typename T> inline
                    tmat3x3<T> const operator-
 (
  tmat3x3<T> const & m
 )
 {
  return tmat3x3<T>(
   -m[0],
   -m[1],
   -m[2]);
 }

 template <typename T> inline
                    tmat3x3<T> const operator++
 (
  tmat3x3<T> const & m,
  int
 )
 {
  return tmat3x3<T>(
   m[0] + T(1),
   m[1] + T(1),
   m[2] + T(1));
 }

 template <typename T> inline
                    tmat3x3<T> const operator--
 (
  tmat3x3<T> const & m,
  int
 )
 {
  return tmat3x3<T>(
   m[0] - T(1),
   m[1] - T(1),
   m[2] - T(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat3x3<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }

}
}
# 315 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x3.hpp" 2
# 47 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat3x4
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T> col_type;
  typedef tvec3<T> row_type;
  typedef tmat3x4<T> type;
  typedef tmat4x3<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 private:

  col_type value[3];

 public:

                tmat3x4();
                tmat3x4(tmat3x4 const & m);

                explicit tmat3x4(
   ctor Null);
                explicit tmat3x4(
   value_type const & s);
                explicit tmat3x4(
   value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
   value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
   value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2);
                explicit tmat3x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template <typename U>
                explicit tmat3x4(
            U const & x);

  template
        <
            typename X1, typename Y1, typename Z1, typename W1,
            typename X2, typename Y2, typename Z2, typename W2,
            typename X3, typename Y3, typename Z3, typename W3
        >
                explicit tmat3x4(
            X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
            X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
            X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3);

  template <typename V1, typename V2, typename V3>
                explicit tmat3x4(
            tvec4<V1> const & v1,
            tvec4<V2> const & v2,
            tvec4<V3> const & v3);


  template <typename U>
                explicit tmat3x4(tmat3x4<U> const & m);

                explicit tmat3x4(tmat2x2<T> const & x);
                explicit tmat3x4(tmat3x3<T> const & x);
                explicit tmat3x4(tmat4x4<T> const & x);
                explicit tmat3x4(tmat2x3<T> const & x);
                explicit tmat3x4(tmat3x2<T> const & x);
                explicit tmat3x4(tmat2x4<T> const & x);
                explicit tmat3x4(tmat4x2<T> const & x);
                explicit tmat3x4(tmat4x3<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


                tmat3x4<T> & operator= (tmat3x4<T> const & m);
  template <typename U>
                tmat3x4<T> & operator= (tmat3x4<U> const & m);
  template <typename U>
                tmat3x4<T> & operator+= (U const & s);
  template <typename U>
                tmat3x4<T> & operator+= (tmat3x4<U> const & m);
  template <typename U>
                tmat3x4<T> & operator-= (U const & s);
  template <typename U>
                tmat3x4<T> & operator-= (tmat3x4<U> const & m);
  template <typename U>
                tmat3x4<T> & operator*= (U const & s);
  template <typename U>
                tmat3x4<T> & operator*= (tmat3x4<U> const & m);
  template <typename U>
                tmat3x4<T> & operator/= (U const & s);

                tmat3x4<T> & operator++ ();
                tmat3x4<T> & operator-- ();
 };


 template <typename T>
 tmat3x4<T> operator+ (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator+ (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat3x4<T> operator- (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator- (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator* (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m);

 template <typename T>
 typename tmat3x4<T>::col_type operator* (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::row_type const & v);

 template <typename T>
 typename tmat3x4<T>::row_type operator* (
  typename tmat3x4<T>::col_type const & v,
  tmat3x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator* (
  tmat3x4<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat2x4<T> operator* (
  tmat3x4<T> const & m1,
  tmat2x3<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat3x4<T> const & m1,
  tmat3x3<T> const & m2);

 template <typename T>
 tmat3x4<T> operator/ (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s);

 template <typename T>
 tmat3x4<T> operator/ (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m);


 template <typename T>
 tmat3x4<T> const operator- (
  tmat3x4<T> const & m);

 template <typename T>
 tmat3x4<T> const operator-- (
  tmat3x4<T> const & m,
  int);

 template <typename T>
 tmat3x4<T> const operator++ (
  tmat3x4<T> const & m,
  int);

}
# 243 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.hpp"
 typedef detail::tmat3x4<lowp_float> lowp_mat3x4;






 typedef detail::tmat3x4<mediump_float> mediump_mat3x4;






 typedef detail::tmat3x4<highp_float> highp_mat3x4;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat3x4<T>::size_type tmat3x4<T>::length() const
 {
  return 3;
 }

 template <typename T> inline
                    typename tmat3x4<T>::size_type tmat3x4<T>::col_size()
 {
  return 4;
 }

 template <typename T> inline
                    typename tmat3x4<T>::size_type tmat3x4<T>::row_size()
 {
  return 3;
 }




 template <typename T> inline
                    typename tmat3x4<T>::col_type &
 tmat3x4<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat3x4<T>::col_type const &
 tmat3x4<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat3x4<T>::tmat3x4()
 {
  this->value[0] = col_type(1, 0, 0, 0);
  this->value[1] = col_type(0, 1, 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  value_type const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero, Zero);
  this->value[2] = col_type(Zero, Zero, s, Zero);
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
  value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
  value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T>
 template <typename U>
               tmat3x4<T>::tmat3x4
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
  this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
  this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3>
               tmat3x4<T>::tmat3x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3), value_type(w3));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3>
               tmat3x4<T>::tmat3x4
 (
  tvec4<V1> const & v1,
  tvec4<V2> const & v2,
  tvec4<V3> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }


 template <typename T>
 template <typename U> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat3x4<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T>(0));
  this->value[2] = col_type(T(0), T(0), T(1), T(0));
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(m[2], T(0));
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(T(0), T(0), T(1), T(0));
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T>(0));
  this->value[2] = col_type(m[2], T(0), T(1));
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0), T(0), T(1), T(0));
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(T(0)));
  this->value[1] = col_type(m[1], detail::tvec2<T>(T(0)));
  this->value[2] = col_type(m[2], detail::tvec2<T>(T(1), T(0)));
 }

 template <typename T> inline
                    tmat3x4<T>::tmat3x4
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(m[2], T(0));
 }




 template <typename T> inline
                    tmat3x4<T>& tmat3x4<T>::operator=
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T>& tmat3x4<T>::operator=
 (
  tmat3x4<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T>& tmat3x4<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T>& tmat3x4<T>::operator+=
 (
  tmat3x4<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T>& tmat3x4<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T>& tmat3x4<T>::operator-=
 (
  tmat3x4<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T>& tmat3x4<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T>& tmat3x4<T>::operator*=
 (
  tmat3x4<U> const & m
 )
 {
  return (*this = tmat3x4<T>(*this * m));
 }

 template <typename T>
 template <typename U> inline
                    tmat3x4<T> & tmat3x4<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T> inline
                    tmat3x4<T>& tmat3x4<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T> inline
                    tmat3x4<T>& tmat3x4<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }




 template <typename T> inline
                    tmat3x4<T> operator+
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
 {
  return tmat3x4<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T> inline
                    tmat3x4<T> operator+
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T> inline
                    tmat3x4<T> operator-
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
 {
  return tmat3x4<T>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T> inline
                    tmat3x4<T> operator-
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T> inline
                    tmat3x4<T> operator*
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
 {
  return tmat3x4<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T> inline
                    tmat3x4<T> operator*
 (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m
 )
 {
  return tmat3x4<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T> inline
                    typename tmat3x4<T>::col_type operator*
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::row_type const & v
 )
 {
  return typename tmat3x4<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template <typename T> inline
                    typename tmat3x4<T>::row_type operator*
 (
  typename tmat3x4<T>::col_type const & v,
  tmat3x4<T> const & m
 )
 {
  return typename tmat3x4<T>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template <typename T> inline
                    tmat4x4<T> operator*
 (
  tmat3x4<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  tmat4x4<T> Result(tmat4x4<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template <typename T> inline
                    tmat2x4<T> operator*
 (
  tmat3x4<T> const & m1,
  tmat2x3<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template <typename T> inline
                    tmat3x4<T> operator*
 (
  tmat3x4<T> const & m1,
  tmat3x3<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template <typename T> inline
                    tmat3x4<T> operator/
 (
  tmat3x4<T> const & m,
  typename tmat3x4<T>::value_type const & s
 )
 {
  return tmat3x4<T>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T> inline
                    tmat3x4<T> operator/
 (
  typename tmat3x4<T>::value_type const & s,
  tmat3x4<T> const & m
 )
 {
  return tmat3x4<T>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }


 template <typename T> inline
                    tmat3x4<T> const operator-
 (
  tmat3x4<T> const & m
 )
 {
  return tmat3x4<T>(
   -m[0],
   -m[1],
   -m[2]);
 }

 template <typename T> inline
                    tmat3x4<T> const operator++
 (
  tmat3x4<T> const & m,
  int
 )
 {
  return tmat3x4<T>(
   m[0] + T(1),
   m[1] + T(1),
   m[2] + T(1));
 }

 template <typename T> inline
                    tmat3x4<T> const operator--
 (
  tmat3x4<T> const & m,
  int
 )
 {
  return tmat3x4<T>(
   m[0] - T(1),
   m[1] - T(1),
   m[2] - T(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat3x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
}
# 263 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat3x4.hpp" 2
# 48 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat4x2
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec2<T> col_type;
  typedef tvec4<T> row_type;
  typedef tmat4x2<T> type;
  typedef tmat2x4<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 private:

  col_type value[4];

 public:

                tmat4x2();
                tmat4x2(tmat4x2 const & m);

                explicit tmat4x2(
   ctor Null);
                explicit tmat4x2(
   value_type const & x);
                explicit tmat4x2(
   value_type const & x0, value_type const & y0,
   value_type const & x1, value_type const & y1,
   value_type const & x2, value_type const & y2,
   value_type const & x3, value_type const & y3);
                explicit tmat4x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <typename U>
                explicit tmat4x2(
   U const & x);

  template
  <
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3,
   typename X4, typename Y4
  >
                explicit tmat4x2(
   X1 const & x1, Y1 const & y1,
   X2 const & x2, Y2 const & y2,
   X3 const & x3, Y3 const & y3,
   X4 const & x4, Y4 const & y4);

  template <typename V1, typename V2, typename V3, typename V4>
                explicit tmat4x2(
   tvec2<V1> const & v1,
   tvec2<V2> const & v2,
   tvec2<V3> const & v3,
   tvec2<V4> const & v4);


  template <typename U>
                explicit tmat4x2(tmat4x2<U> const & m);

                explicit tmat4x2(tmat2x2<T> const & x);
                explicit tmat4x2(tmat3x3<T> const & x);
                explicit tmat4x2(tmat4x4<T> const & x);
                explicit tmat4x2(tmat2x3<T> const & x);
                explicit tmat4x2(tmat3x2<T> const & x);
                explicit tmat4x2(tmat2x4<T> const & x);
                explicit tmat4x2(tmat4x3<T> const & x);
                explicit tmat4x2(tmat3x4<T> const & x);


                col_type & operator[](size_type i);
                col_type const & operator[](size_type i) const;


                tmat4x2<T>& operator= (tmat4x2<T> const & m);
  template <typename U>
                tmat4x2<T>& operator= (tmat4x2<U> const & m);
  template <typename U>
                tmat4x2<T>& operator+= (U const & s);
  template <typename U>
                tmat4x2<T>& operator+= (tmat4x2<U> const & m);
  template <typename U>
                tmat4x2<T>& operator-= (U const & s);
  template <typename U>
                tmat4x2<T>& operator-= (tmat4x2<U> const & m);
  template <typename U>
                tmat4x2<T>& operator*= (U const & s);
  template <typename U>
                tmat4x2<T>& operator*= (tmat4x2<U> const & m);
  template <typename U>
                tmat4x2<T>& operator/= (U const & s);

                tmat4x2<T>& operator++ ();
                tmat4x2<T>& operator-- ();
 };


 template <typename T>
 tmat4x2<T> operator+ (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator+ (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat4x2<T> operator- (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator- (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator* (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m);

 template <typename T>
 typename tmat4x2<T>::col_type operator* (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::row_type const & v);

 template <typename T>
 typename tmat4x2<T>::row_type operator* (
  typename tmat4x2<T>::col_type const & v,
  tmat4x2<T> const & m);

 template <typename T>
 tmat3x2<T> operator* (
  tmat4x2<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat4x2<T> operator* (
  tmat4x2<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat2x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat4x2<T> operator/ (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s);

 template <typename T>
 tmat4x2<T> operator/ (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m);


 template <typename T>
 tmat4x2<T> const operator- (
  tmat4x2<T> const & m);

 template <typename T>
 tmat4x2<T> const operator-- (
  tmat4x2<T> const & m,
  int);

 template <typename T>
 tmat4x2<T> const operator++ (
  tmat4x2<T> const & m,
  int);
}
# 247 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.hpp"
 typedef detail::tmat4x2<lowp_float> lowp_mat4x2;






 typedef detail::tmat4x2<mediump_float> mediump_mat4x2;






 typedef detail::tmat4x2<highp_float> highp_mat4x2;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat4x2<T>::size_type tmat4x2<T>::length() const
 {
  return 4;
 }

 template <typename T> inline
                    typename tmat4x2<T>::size_type tmat4x2<T>::col_size()
 {
  return 2;
 }

 template <typename T> inline
                    typename tmat4x2<T>::size_type tmat4x2<T>::row_size()
 {
  return 4;
 }




 template <typename T> inline
                    typename tmat4x2<T>::col_type &
 tmat4x2<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat4x2<T>::col_type const &
 tmat4x2<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat4x2<T>::tmat4x2()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero);
  this->value[1] = col_type(Zero, One);
  this->value[2] = col_type(Zero, Zero);
  this->value[3] = col_type(Zero, Zero);
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  value_type const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero);
  this->value[1] = col_type(Zero, s);
  this->value[2] = col_type(Zero, Zero);
  this->value[3] = col_type(Zero, Zero);
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  value_type const & x0, value_type const & y0,
  value_type const & x1, value_type const & y1,
  value_type const & x2, value_type const & y2,
  value_type const & x3, value_type const & y3
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
  this->value[3] = col_type(x3, y3);
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }



 template <typename T>
 template <typename U>
               tmat4x2<T>::tmat4x2
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec2<T>(value_type(s), Zero);
  this->value[1] = tvec2<T>(Zero, value_type(s));
  this->value[2] = tvec2<T>(Zero, Zero);
  this->value[3] = tvec2<T>(Zero, Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3,
  typename X4, typename Y4>
               tmat4x2<T>::tmat4x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3,
  X4 const & x4, Y4 const & y4
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1));
  this->value[1] = col_type(value_type(x2), value_type(y2));
  this->value[2] = col_type(value_type(x3), value_type(y3));
  this->value[3] = col_type(value_type(x4), value_type(y4));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3, typename V4>
               tmat4x2<T>::tmat4x2
 (
  tvec2<V1> const & v1,
  tvec2<V2> const & v2,
  tvec2<V3> const & v3,
  tvec2<V4> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }


 template <typename T>
 template <typename U> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat4x2<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(value_type(0));
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(value_type(0));
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(value_type(0));
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T> inline
                    tmat4x2<T>::tmat4x2
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(value_type(0));
 }




 template <typename T> inline
                    tmat4x2<T>& tmat4x2<T>::operator=
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T>& tmat4x2<T>::operator=
 (
  tmat4x2<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T> & tmat4x2<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T> & tmat4x2<T>::operator+=
 (
  tmat4x2<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T> & tmat4x2<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T> & tmat4x2<T>::operator-=
 (
  tmat4x2<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T> & tmat4x2<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T> & tmat4x2<T>::operator*=
 (
  tmat4x2<U> const & m
 )
 {
  return (*this = tmat4x2<T>(*this * m));
 }

 template <typename T>
 template <typename U> inline
                    tmat4x2<T> & tmat4x2<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T> inline
                    tmat4x2<T> & tmat4x2<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T> inline
                    tmat4x2<T> & tmat4x2<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }




 template <typename T> inline
                    tmat4x2<T> operator+
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
 {
  return tmat4x2<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T> inline
                    tmat4x2<T> operator+
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T> inline
                    tmat4x2<T> operator-
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
 {
  return tmat4x2<T>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T> inline
                    tmat4x2<T> operator-
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T> inline
                    tmat4x2<T> operator*
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
 {
  return tmat4x2<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T> inline
                    tmat4x2<T> operator*
 (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m
 )
 {
  return tmat4x2<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T> inline
                    typename tmat4x2<T>::col_type operator*
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::row_type const & v)
 {
  return typename tmat4x2<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template <typename T> inline
                    typename tmat4x2<T>::row_type operator*
 (
  typename tmat4x2<T>::col_type const & v,
  tmat4x2<T> const & m)
 {
  return typename tmat4x2<T>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template <typename T> inline
                    tmat2x2<T> operator*
 (
  tmat4x2<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  tmat2x2<T> Result(tmat2x2<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template <typename T> inline
                    tmat3x2<T> operator*
 (
  tmat4x2<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return tmat3x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template <typename T> inline
                    tmat4x2<T> operator*
 (
  tmat4x2<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return tmat4x2<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template <typename T> inline
                    tmat4x2<T> operator/
 (
  tmat4x2<T> const & m,
  typename tmat4x2<T>::value_type const & s
 )
 {
  return tmat4x2<T>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T> inline
                    tmat4x2<T> operator/
 (
  typename tmat4x2<T>::value_type const & s,
  tmat4x2<T> const & m
 )
 {
  return tmat4x2<T>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }


 template <typename T> inline
                    tmat4x2<T> const operator-
 (
  tmat4x2<T> const & m
 )
 {
  return tmat4x2<T>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }

 template <typename T> inline
                    tmat4x2<T> const operator++
 (
  tmat4x2<T> const & m,
  int
 )
 {
  return tmat4x2<T>(
   m[0] + typename tmat4x2<T>::value_type(1),
   m[1] + typename tmat4x2<T>::value_type(1),
   m[2] + typename tmat4x2<T>::value_type(1),
   m[3] + typename tmat4x2<T>::value_type(1));
 }

 template <typename T> inline
                    tmat4x2<T> const operator--
 (
  tmat4x2<T> const & m,
  int
 )
 {
  return tmat4x2<T>(
   m[0] - typename tmat4x2<T>::value_type(1),
   m[1] - typename tmat4x2<T>::value_type(1),
   m[2] - typename tmat4x2<T>::value_type(1),
   m[3] - typename tmat4x2<T>::value_type(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat4x2<T> const & m1,
  tmat4x2<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
}
# 267 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x2.hpp" 2
# 49 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat4x3
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec3<T> col_type;
  typedef tvec4<T> row_type;
  typedef tmat4x3<T> type;
  typedef tmat3x4<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 private:

  col_type value[4];

 public:

                tmat4x3();
                tmat4x3(tmat4x3 const & m);

                explicit tmat4x3(
   ctor Null);
                explicit tmat4x3(
   value_type const & x);
                explicit tmat4x3(
   value_type const & x0, value_type const & y0, value_type const & z0,
   value_type const & x1, value_type const & y1, value_type const & z1,
   value_type const & x2, value_type const & y2, value_type const & z2,
   value_type const & x3, value_type const & y3, value_type const & z3);
                explicit tmat4x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <typename U>
                explicit tmat4x3(
   U const & x);

  template <
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
                explicit tmat4x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3,
   X4 const & x4, Y4 const & y4, Z4 const & z4);

  template <typename V1, typename V2, typename V3, typename V4>
                explicit tmat4x3(
   tvec3<V1> const & v1,
   tvec3<V2> const & v2,
   tvec3<V3> const & v3,
   tvec3<V4> const & v4);


  template <typename U>
                explicit tmat4x3(tmat4x3<U> const & m);

                explicit tmat4x3(tmat2x2<T> const & x);
                explicit tmat4x3(tmat3x3<T> const & x);
                explicit tmat4x3(tmat4x4<T> const & x);
                explicit tmat4x3(tmat2x3<T> const & x);
                explicit tmat4x3(tmat3x2<T> const & x);
                explicit tmat4x3(tmat2x4<T> const & x);
                explicit tmat4x3(tmat4x2<T> const & x);
                explicit tmat4x3(tmat3x4<T> const & x);


  col_type & operator[](size_type i);
  col_type const & operator[](size_type i) const;


                tmat4x3<T> & operator= (tmat4x3<T> const & m);
  template <typename U>
                tmat4x3<T> & operator= (tmat4x3<U> const & m);
  template <typename U>
                tmat4x3<T> & operator+= (U const & s);
  template <typename U>
                tmat4x3<T> & operator+= (tmat4x3<U> const & m);
  template <typename U>
                tmat4x3<T> & operator-= (U const & s);
  template <typename U>
                tmat4x3<T> & operator-= (tmat4x3<U> const & m);
  template <typename U>
                tmat4x3<T> & operator*= (U const & s);
  template <typename U>
                tmat4x3<T> & operator*= (tmat4x3<U> const & m);
  template <typename U>
                tmat4x3<T> & operator/= (U const & s);

                tmat4x3<T> & operator++ ();
                tmat4x3<T> & operator-- ();
 };


 template <typename T>
 tmat4x3<T> operator+ (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator+ (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat4x3<T> operator- (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator- (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator* (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m);

 template <typename T>
 typename tmat4x3<T>::col_type operator* (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::row_type const & v);

 template <typename T>
 typename tmat4x3<T>::row_type operator* (
  typename tmat4x3<T>::col_type const & v,
  tmat4x3<T> const & m);

 template <typename T>
 tmat2x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat3x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat4x3<T> operator* (
  tmat4x3<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x3<T> operator/ (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s);

 template <typename T>
 tmat4x3<T> operator/ (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m);


 template <typename T>
 tmat4x3<T> const operator- (
  tmat4x3<T> const & m);

 template <typename T>
 tmat4x3<T> const operator-- (
  tmat4x3<T> const & m,
  int);

 template <typename T>
 tmat4x3<T> const operator++ (
  tmat4x3<T> const & m,
  int);
}
# 245 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.hpp"
 typedef detail::tmat4x3<lowp_float> lowp_mat4x3;






 typedef detail::tmat4x3<mediump_float> mediump_mat4x3;






 typedef detail::tmat4x3<highp_float> highp_mat4x3;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat4x3<T>::size_type tmat4x3<T>::length() const
 {
  return 4;
 }

 template <typename T> inline
                    typename tmat4x3<T>::size_type tmat4x3<T>::col_size()
 {
  return 3;
 }

 template <typename T> inline
                    typename tmat4x3<T>::size_type tmat4x3<T>::row_size()
 {
  return 4;
 }




 template <typename T> inline
                    typename tmat4x3<T>::col_type &
 tmat4x3<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat4x3<T>::col_type const &
 tmat4x3<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat4x3<T>::tmat4x3()
 {
  value_type const Zero(0);
  value_type const One(1);
  this->value[0] = col_type(One, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero);
  this->value[2] = col_type(Zero, Zero, One);
  this->value[3] = col_type(Zero, Zero, Zero);
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  value_type const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero);
  this->value[2] = col_type(Zero, Zero, s);
  this->value[3] = col_type(Zero, Zero, Zero);
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  value_type const & x0, value_type const & y0, value_type const & z0,
  value_type const & x1, value_type const & y1, value_type const & z1,
  value_type const & x2, value_type const & y2, value_type const & z2,
  value_type const & x3, value_type const & y3, value_type const & z3
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
  this->value[3] = col_type(x3, y3, z3);
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }



 template <typename T>
 template <typename U>
               tmat4x3<T>::tmat4x3
 (
  U const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = tvec3<T>(value_type(s), Zero, Zero);
  this->value[1] = tvec3<T>(Zero, value_type(s), Zero);
  this->value[2] = tvec3<T>(Zero, Zero, value_type(s));
  this->value[3] = tvec3<T>(Zero, Zero, Zero);
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3,
  typename X4, typename Y4, typename Z4>
               tmat4x3<T>::tmat4x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3,
  X4 const & x4, Y4 const & y4, Z4 const & z4
 )
 {
  this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3));
  this->value[3] = col_type(value_type(x4), value_type(y4), value_type(z4));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3, typename V4>
               tmat4x3<T>::tmat4x3
 (
  tvec3<V1> const & v1,
  tvec3<V2> const & v2,
  tvec3<V3> const & v3,
  tvec3<V4> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }




 template <typename T>
 template <typename U> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat4x3<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(value_type(0), value_type(0), value_type(1));
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(value_type(0), value_type(0), value_type(1));
  this->value[3] = col_type(value_type(0));
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(1));
  this->value[3] = col_type(m[3], value_type(0));
 }

 template <typename T> inline
                    tmat4x3<T>::tmat4x3
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(value_type(0));
 }




 template <typename T> inline
                    tmat4x3<T>& tmat4x3<T>::operator=
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T>& tmat4x3<T>::operator=
 (
  tmat4x3<U> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T> & tmat4x3<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T> & tmat4x3<T>::operator+=
 (
  tmat4x3<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T> & tmat4x3<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T> & tmat4x3<T>::operator-=
 (
  tmat4x3<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T> & tmat4x3<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T> & tmat4x3<T>::operator*=
 (
  tmat4x3<U> const & m
 )
 {
  return (*this = tmat4x3<T>(*this * m));
 }

 template <typename T>
 template <typename U> inline
                    tmat4x3<T> & tmat4x3<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T> inline
                    tmat4x3<T> & tmat4x3<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T> inline
                    tmat4x3<T> & tmat4x3<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }




 template <typename T> inline
                    tmat4x3<T> operator+ (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s)
 {
  return tmat4x3<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T> inline
                    tmat4x3<T> operator+ (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2)
 {
  return tmat4x3<T>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T> inline
                    tmat4x3<T> operator- (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s)
 {
  return tmat4x3<T>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T> inline
                    tmat4x3<T> operator- (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2)
 {
  return tmat4x3<T>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T> inline
                    tmat4x3<T> operator* (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s)
 {
  return tmat4x3<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T> inline
                    tmat4x3<T> operator* (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m)
 {
  return tmat4x3<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T> inline
                    typename tmat4x3<T>::col_type operator*
 (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::row_type const & v)
 {
  return typename tmat4x3<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template <typename T> inline
                    typename tmat4x3<T>::row_type operator*
 (
  typename tmat4x3<T>::col_type const & v,
  tmat4x3<T> const & m)
 {
  return typename tmat4x3<T>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template <typename T> inline
                    tmat2x3<T> operator*
 (
  tmat4x3<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return tmat2x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template <typename T> inline
                    tmat3x3<T> operator*
 (
  tmat4x3<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  tmat3x3<T> Result(tmat3x3<T>::null);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template <typename T> inline
                    tmat4x3<T> operator*
 (
  tmat4x3<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return tmat4x3<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template <typename T> inline
                    tmat4x3<T> operator/
 (
  tmat4x3<T> const & m,
  typename tmat4x3<T>::value_type const & s
 )
 {
  return tmat4x3<T>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T> inline
                    tmat4x3<T> operator/
 (
  typename tmat4x3<T>::value_type const & s,
  tmat4x3<T> const & m
 )
 {
  return tmat4x3<T>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }


 template <typename T> inline
                    tmat4x3<T> const operator-
 (
  tmat4x3<T> const & m
 )
 {
  return tmat4x3<T>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }

 template <typename T> inline
                    tmat4x3<T> const operator++
 (
  tmat4x3<T> const & m,
  int
 )
 {
  return tmat4x3<T>(
   m[0] + T(1),
   m[1] + T(1),
   m[2] + T(1),
   m[3] + T(1));
 }

 template <typename T> inline
                    tmat4x3<T> const operator--
 (
  tmat4x3<T> const & m,
  int
 )
 {
  return tmat4x3<T>(
   m[0] - T(1),
   m[1] - T(1),
   m[2] - T(1),
   m[3] - T(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat4x3<T> const & m1,
  tmat4x3<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
}
# 265 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x3.hpp" 2
# 50 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.hpp" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.hpp"
namespace glm{
namespace detail
{
 template <typename T> struct tvec1;
 template <typename T> struct tvec2;
 template <typename T> struct tvec3;
 template <typename T> struct tvec4;
 template <typename T> struct tmat2x2;
 template <typename T> struct tmat2x3;
 template <typename T> struct tmat2x4;
 template <typename T> struct tmat3x2;
 template <typename T> struct tmat3x3;
 template <typename T> struct tmat3x4;
 template <typename T> struct tmat4x2;
 template <typename T> struct tmat4x3;
 template <typename T> struct tmat4x4;

 template <typename T>
 struct tmat4x4
 {
  enum ctor{null};
  typedef T value_type;
  typedef std::size_t size_type;
  typedef tvec4<T> col_type;
  typedef tvec4<T> row_type;
  typedef tmat4x4<T> type;
  typedef tmat4x4<T> transpose_type;

  static size_type col_size();
  static size_type row_size();

                              size_type length() const;

 public:


                tmat4x4<T> _inverse() const;


 private:

  col_type value[4];

 public:

                tmat4x4();
                tmat4x4(tmat4x4 const & m);

                explicit tmat4x4(
   ctor Null);
                explicit tmat4x4(
   value_type const & x);
                explicit tmat4x4(
   value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
   value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
   value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2,
   value_type const & x3, value_type const & y3, value_type const & z3, value_type const & w3);
                explicit tmat4x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);



  template <typename U>
                explicit tmat4x4(
   U const & x);

  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
                explicit tmat4x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
   X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
   X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

  template <typename V1, typename V2, typename V3, typename V4>
                explicit tmat4x4(
   tvec4<V1> const & v1,
   tvec4<V2> const & v2,
   tvec4<V3> const & v3,
   tvec4<V4> const & v4);


  template <typename U>
                explicit tmat4x4(tmat4x4<U> const & m);

                explicit tmat4x4(tmat2x2<T> const & x);
                explicit tmat4x4(tmat3x3<T> const & x);
                explicit tmat4x4(tmat2x3<T> const & x);
                explicit tmat4x4(tmat3x2<T> const & x);
                explicit tmat4x4(tmat2x4<T> const & x);
                explicit tmat4x4(tmat4x2<T> const & x);
                explicit tmat4x4(tmat3x4<T> const & x);
                explicit tmat4x4(tmat4x3<T> const & x);


                col_type & operator[](size_type i);
                col_type const & operator[](size_type i) const;


                tmat4x4<T> & operator= (tmat4x4<T> const & m);
  template <typename U>
                tmat4x4<T> & operator= (tmat4x4<U> const & m);
  template <typename U>
                tmat4x4<T> & operator+= (U const & s);
  template <typename U>
                tmat4x4<T> & operator+= (tmat4x4<U> const & m);
  template <typename U>
                tmat4x4<T> & operator-= (U const & s);
  template <typename U>
                tmat4x4<T> & operator-= (tmat4x4<U> const & m);
  template <typename U>
                tmat4x4<T> & operator*= (U const & s);
  template <typename U>
                tmat4x4<T> & operator*= (tmat4x4<U> const & m);
  template <typename U>
                tmat4x4<T> & operator/= (U const & s);
  template <typename U>
                tmat4x4<T> & operator/= (tmat4x4<U> const & m);
                tmat4x4<T> & operator++ ();
                tmat4x4<T> & operator-- ();
 };


 template <typename T>
 tmat4x4<T> operator+ (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator+ (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator+ (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator- (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator- (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator- (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator* (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator* (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 typename tmat4x4<T>::col_type operator* (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v);

 template <typename T>
 typename tmat4x4<T>::row_type operator* (
  typename tmat4x4<T>::col_type const & v,
  tmat4x4<T> const & m);

 template <typename T>
 tmat2x4<T> operator* (
  tmat4x4<T> const & m1,
  tmat2x4<T> const & m2);

 template <typename T>
 tmat3x4<T> operator* (
  tmat4x4<T> const & m1,
  tmat3x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator* (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);

 template <typename T>
 tmat4x4<T> operator/ (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s);

 template <typename T>
 tmat4x4<T> operator/ (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m);

 template <typename T>
 typename tmat4x4<T>::col_type operator/ (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v);

 template <typename T>
 typename tmat4x4<T>::row_type operator/ (
  typename tmat4x4<T>::col_type & v,
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> operator/ (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2);


 template <typename T>
 tmat4x4<T> const operator- (
  tmat4x4<T> const & m);

 template <typename T>
 tmat4x4<T> const operator-- (
  tmat4x4<T> const & m, int);

 template <typename T>
 tmat4x4<T> const operator++ (
  tmat4x4<T> const & m, int);

}
# 276 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.hpp"
 typedef detail::tmat4x4<lowp_float> lowp_mat4;






 typedef detail::tmat4x4<mediump_float> mediump_mat4;






 typedef detail::tmat4x4<highp_float> highp_mat4;






 typedef detail::tmat4x4<lowp_float> lowp_mat4x4;






 typedef detail::tmat4x4<mediump_float> mediump_mat4x4;






 typedef detail::tmat4x4<highp_float> highp_mat4x4;


}



# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.inl"
namespace glm{
namespace detail
{
 template <typename T> inline
                                  typename tmat4x4<T>::size_type tmat4x4<T>::length() const
 {
  return 4;
 }

 template <typename T> inline
                    typename tmat4x4<T>::size_type tmat4x4<T>::col_size()
 {
  return 4;
 }

 template <typename T> inline
                    typename tmat4x4<T>::size_type tmat4x4<T>::row_size()
 {
  return 4;
 }




 template <typename T> inline
                    typename tmat4x4<T>::col_type &
 tmat4x4<T>::operator[]
 (
  size_type i
 )
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.inl", 60, "i < this->length()") : (void)0);
  return this->value[i];
 }

 template <typename T> inline
                    typename tmat4x4<T>::col_type const &
 tmat4x4<T>::operator[]
 (
  size_type i
 ) const
 {
  (__builtin_expect(!(i < this->length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.inl", 71, "i < this->length()") : (void)0);
  return this->value[i];
 }




 template <typename T> inline
                    tmat4x4<T>::tmat4x4()
 {
  value_type Zero(0);
  value_type One(1);
  this->value[0] = col_type(One, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, One, Zero, Zero);
  this->value[2] = col_type(Zero, Zero, One, Zero);
  this->value[3] = col_type(Zero, Zero, Zero, One);
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat4x4<T> const & m
 )
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  ctor
 )
 {}

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  value_type const & s
 )
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero, Zero);
  this->value[2] = col_type(Zero, Zero, s, Zero);
  this->value[3] = col_type(Zero, Zero, Zero, s);
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  value_type const & x0, value_type const & y0, value_type const & z0, value_type const & w0,
  value_type const & x1, value_type const & y1, value_type const & z1, value_type const & w1,
  value_type const & x2, value_type const & y2, value_type const & z2, value_type const & w2,
  value_type const & x3, value_type const & y3, value_type const & z3, value_type const & w3
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
  this->value[3] = col_type(x3, y3, z3, w3);
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat4x4<U> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }



 template <typename T>
 template <typename U>
               tmat4x4<T>::tmat4x4
 (
  U const & s
 )
 {
                                                                                                                                              ;

  value_type const Zero(0);
  this->value[0] = tvec4<T>(value_type(s), Zero, Zero, Zero);
  this->value[1] = tvec4<T>(Zero, value_type(s), Zero, Zero);
  this->value[2] = tvec4<T>(Zero, Zero, value_type(s), Zero);
  this->value[3] = tvec4<T>(Zero, Zero, Zero, value_type(s));
 }

 template <typename T>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
               tmat4x4<T>::tmat4x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
  X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
 )
 {
                                                                                                                                                                             ;
                                                                                                                                                                             ;
                                                                                                                                                                             ;
                                                                                                                                                                             ;

                                                                                                                                                                             ;
                                                                                                                                                                             ;
                                                                                                                                                                             ;
                                                                                                                                                                             ;

                                                                                                                                                                             ;
                                                                                                                                                                              ;
                                                                                                                                                                              ;
                                                                                                                                                                              ;

                                                                                                                                                                              ;
                                                                                                                                                                              ;
                                                                                                                                                                              ;
                                                                                                                                                                              ;

  this->value[0] = col_type(value_type(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(value_type(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(value_type(x3), value_type(y3), value_type(z3), value_type(w3));
  this->value[3] = col_type(value_type(x4), value_type(y4), value_type(z4), value_type(w4));
 }

 template <typename T>
 template <typename V1, typename V2, typename V3, typename V4>
               tmat4x4<T>::tmat4x4
 (
  tvec4<V1> const & v1,
  tvec4<V2> const & v2,
  tvec4<V3> const & v3,
  tvec4<V4> const & v4
 )
 {
                                                                                                                                                                             ;
                                                                                                                                                                             ;
                                                                                                                                                                             ;
                                                                                                                                                                             ;

  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat2x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T>(0));
  this->value[2] = col_type(value_type(0));
  this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat3x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(m[2], value_type(0));
  this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat2x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], value_type(0));
  this->value[1] = col_type(m[1], value_type(0));
  this->value[2] = col_type(value_type(0));
  this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat3x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T>(0));
  this->value[2] = col_type(m[2], detail::tvec2<T>(0));
  this->value[3] = col_type(value_type(0), value_type(0), value_type(0), value_type(1));
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat2x4<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(T(0));
  this->value[3] = col_type(T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat4x2<T> const & m
 )
 {
  this->value[0] = col_type(m[0], detail::tvec2<T>(0));
  this->value[1] = col_type(m[1], detail::tvec2<T>(0));
  this->value[2] = col_type(T(0));
  this->value[3] = col_type(T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat3x4<T> const & m
 )
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = col_type(T(0), T(0), T(0), T(1));
 }

 template <typename T> inline
                    tmat4x4<T>::tmat4x4
 (
  tmat4x3<T> const & m
 )
 {
  this->value[0] = col_type(m[0], T(0));
  this->value[1] = col_type(m[1], T(0));
  this->value[2] = col_type(m[2], T(0));
  this->value[3] = col_type(m[3], T(1));
 }




 template <typename T> inline
                    tmat4x4<T>& tmat4x4<T>::operator=
 (
  tmat4x4<T> const & m
 )
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T>& tmat4x4<T>::operator=
 (
  tmat4x4<U> const & m
 )
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T>& tmat4x4<T>::operator+=
 (
  U const & s
 )
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T>& tmat4x4<T>::operator+=
 (
  tmat4x4<U> const & m
 )
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T> & tmat4x4<T>::operator-=
 (
  U const & s
 )
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T> & tmat4x4<T>::operator-=
 (
  tmat4x4<U> const & m
 )
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T> & tmat4x4<T>::operator*=
 (
  U const & s
 )
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T> & tmat4x4<T>::operator*=
 (
  tmat4x4<U> const & m
 )
 {
  return (*this = *this * m);
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T> & tmat4x4<T>::operator/=
 (
  U const & s
 )
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T>
 template <typename U> inline
                    tmat4x4<T> & tmat4x4<T>::operator/=
 (
  tmat4x4<U> const & m
 )
 {
  return (*this = *this / m);
 }

 template <typename T> inline
                    tmat4x4<T> & tmat4x4<T>::operator++ ()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T> inline
                    tmat4x4<T> & tmat4x4<T>::operator-- ()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T> inline
                    tmat4x4<T> tmat4x4<T>::_inverse() const
 {

  value_type SubFactor00 = this->value[2][2] * this->value[3][3] - this->value[3][2] * this->value[2][3];
  value_type SubFactor01 = this->value[2][1] * this->value[3][3] - this->value[3][1] * this->value[2][3];
  value_type SubFactor02 = this->value[2][1] * this->value[3][2] - this->value[3][1] * this->value[2][2];
  value_type SubFactor03 = this->value[2][0] * this->value[3][3] - this->value[3][0] * this->value[2][3];
  value_type SubFactor04 = this->value[2][0] * this->value[3][2] - this->value[3][0] * this->value[2][2];
  value_type SubFactor05 = this->value[2][0] * this->value[3][1] - this->value[3][0] * this->value[2][1];
  value_type SubFactor06 = this->value[1][2] * this->value[3][3] - this->value[3][2] * this->value[1][3];
  value_type SubFactor07 = this->value[1][1] * this->value[3][3] - this->value[3][1] * this->value[1][3];
  value_type SubFactor08 = this->value[1][1] * this->value[3][2] - this->value[3][1] * this->value[1][2];
  value_type SubFactor09 = this->value[1][0] * this->value[3][3] - this->value[3][0] * this->value[1][3];
  value_type SubFactor10 = this->value[1][0] * this->value[3][2] - this->value[3][0] * this->value[1][2];
  value_type SubFactor11 = this->value[1][1] * this->value[3][3] - this->value[3][1] * this->value[1][3];
  value_type SubFactor12 = this->value[1][0] * this->value[3][1] - this->value[3][0] * this->value[1][1];
  value_type SubFactor13 = this->value[1][2] * this->value[2][3] - this->value[2][2] * this->value[1][3];
  value_type SubFactor14 = this->value[1][1] * this->value[2][3] - this->value[2][1] * this->value[1][3];
  value_type SubFactor15 = this->value[1][1] * this->value[2][2] - this->value[2][1] * this->value[1][2];
  value_type SubFactor16 = this->value[1][0] * this->value[2][3] - this->value[2][0] * this->value[1][3];
  value_type SubFactor17 = this->value[1][0] * this->value[2][2] - this->value[2][0] * this->value[1][2];
  value_type SubFactor18 = this->value[1][0] * this->value[2][1] - this->value[2][0] * this->value[1][1];
# 544 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.inl"
  tmat4x4<T> Inverse(
   + this->value[1][1] * SubFactor00 - this->value[1][2] * SubFactor01 + this->value[1][3] * SubFactor02,
   - this->value[1][0] * SubFactor00 + this->value[1][2] * SubFactor03 - this->value[1][3] * SubFactor04,
   + this->value[1][0] * SubFactor01 - this->value[1][1] * SubFactor03 + this->value[1][3] * SubFactor05,
   - this->value[1][0] * SubFactor02 + this->value[1][1] * SubFactor04 - this->value[1][2] * SubFactor05,

   - this->value[0][1] * SubFactor00 + this->value[0][2] * SubFactor01 - this->value[0][3] * SubFactor02,
   + this->value[0][0] * SubFactor00 - this->value[0][2] * SubFactor03 + this->value[0][3] * SubFactor04,
   - this->value[0][0] * SubFactor01 + this->value[0][1] * SubFactor03 - this->value[0][3] * SubFactor05,
   + this->value[0][0] * SubFactor02 - this->value[0][1] * SubFactor04 + this->value[0][2] * SubFactor05,

   + this->value[0][1] * SubFactor06 - this->value[0][2] * SubFactor07 + this->value[0][3] * SubFactor08,
   - this->value[0][0] * SubFactor06 + this->value[0][2] * SubFactor09 - this->value[0][3] * SubFactor10,
   + this->value[0][0] * SubFactor11 - this->value[0][1] * SubFactor09 + this->value[0][3] * SubFactor12,
   - this->value[0][0] * SubFactor08 + this->value[0][1] * SubFactor10 - this->value[0][2] * SubFactor12,

   - this->value[0][1] * SubFactor13 + this->value[0][2] * SubFactor14 - this->value[0][3] * SubFactor15,
   + this->value[0][0] * SubFactor13 - this->value[0][2] * SubFactor16 + this->value[0][3] * SubFactor17,
   - this->value[0][0] * SubFactor14 + this->value[0][1] * SubFactor16 - this->value[0][3] * SubFactor18,
   + this->value[0][0] * SubFactor15 - this->value[0][1] * SubFactor17 + this->value[0][2] * SubFactor18);

  value_type Determinant =
   + this->value[0][0] * Inverse[0][0]
   + this->value[0][1] * Inverse[1][0]
   + this->value[0][2] * Inverse[2][0]
   + this->value[0][3] * Inverse[3][0];

  Inverse /= Determinant;
  return Inverse;
 }


 template <typename T> inline
                    tmat4x4<T> operator+
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
 {
  return tmat4x4<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T> inline
                    tmat4x4<T> operator+
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
 {
  return tmat4x4<T>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T> inline
                    tmat4x4<T> operator+
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return tmat4x4<T>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T> inline
                    tmat4x4<T> operator-
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
 {
  return tmat4x4<T>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T> inline
                    tmat4x4<T> operator-
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
 {
  return tmat4x4<T>(
   s - m[0],
   s - m[1],
   s - m[2],
   s - m[3]);
 }

 template <typename T> inline
                    tmat4x4<T> operator-
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return tmat4x4<T>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T> inline
                    tmat4x4<T> operator*
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
 {
  return tmat4x4<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T> inline
                    tmat4x4<T> operator*
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
 {
  return tmat4x4<T>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T> inline
                    typename tmat4x4<T>::col_type operator*
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v
 )
 {
  return typename tmat4x4<T>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z + m[3][3] * v.w);
 }

 template <typename T> inline
                    typename tmat4x4<T>::row_type operator*
 (
  typename tmat4x4<T>::col_type const & v,
  tmat4x4<T> const & m
 )
 {
  return typename tmat4x4<T>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z + m[0][3] * v.w,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z + m[1][3] * v.w,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z + m[2][3] * v.w,
   m[3][0] * v.x + m[3][1] * v.y + m[3][2] * v.z + m[3][3] * v.w);
 }

 template <typename T> inline
                    tmat2x4<T> operator*
 (
  tmat4x4<T> const & m1,
  tmat2x4<T> const & m2
 )
 {
  return tmat2x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template <typename T> inline
                    tmat3x4<T> operator*
 (
  tmat4x4<T> const & m1,
  tmat3x4<T> const & m2
 )
 {
  return tmat3x4<T>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template <typename T> inline
                    tmat4x4<T> operator*
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  typename tmat4x4<T>::col_type const SrcA0 = m1[0];
  typename tmat4x4<T>::col_type const SrcA1 = m1[1];
  typename tmat4x4<T>::col_type const SrcA2 = m1[2];
  typename tmat4x4<T>::col_type const SrcA3 = m1[3];

  typename tmat4x4<T>::col_type const SrcB0 = m2[0];
  typename tmat4x4<T>::col_type const SrcB1 = m2[1];
  typename tmat4x4<T>::col_type const SrcB2 = m2[2];
  typename tmat4x4<T>::col_type const SrcB3 = m2[3];

  tmat4x4<T> Result(tmat4x4<T>::null);
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template <typename T> inline
                    tmat4x4<T> operator/
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::value_type const & s
 )
 {
  return tmat4x4<T>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T> inline
                    tmat4x4<T> operator/
 (
  typename tmat4x4<T>::value_type const & s,
  tmat4x4<T> const & m
 )
 {
  return tmat4x4<T>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }

 template <typename T> inline
                    typename tmat4x4<T>::col_type operator/
 (
  tmat4x4<T> const & m,
  typename tmat4x4<T>::row_type const & v
 )
 {
  return m._inverse() * v;
 }

 template <typename T> inline
                    typename tmat4x4<T>::row_type operator/
 (
  typename tmat4x4<T>::col_type const & v,
  tmat4x4<T> const & m
 )
 {
  return v * m._inverse();
 }

 template <typename T> inline
                    tmat4x4<T> operator/
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return m1 * m2._inverse();
 }


 template <typename T> inline
                    tmat4x4<T> const operator-
 (
  tmat4x4<T> const & m
 )
 {
  return tmat4x4<T>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }

 template <typename T> inline
                    tmat4x4<T> const operator++
 (
  tmat4x4<T> const & m,
  int
 )
 {
  return tmat4x4<T>(
   m[0] + typename tmat4x4<T>::value_type(1),
   m[1] + typename tmat4x4<T>::value_type(1),
   m[2] + typename tmat4x4<T>::value_type(1),
   m[3] + typename tmat4x4<T>::value_type(1));
 }

 template <typename T> inline
                    tmat4x4<T> const operator--
 (
  tmat4x4<T> const & m,
  int
 )
 {
  return tmat4x4<T>(
   m[0] - typename tmat4x4<T>::value_type(1),
   m[1] - typename tmat4x4<T>::value_type(1),
   m[2] - typename tmat4x4<T>::value_type(1),
   m[3] - typename tmat4x4<T>::value_type(1));
 }




 template <typename T> inline
                    bool operator==
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T> inline
                    bool operator!=
 (
  tmat4x4<T> const & m1,
  tmat4x4<T> const & m2
 )
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }

}
}
# 317 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/type_mat4x4.hpp" 2
# 51 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp" 2


namespace glm
{
# 104 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp"
 typedef mediump_vec2 vec2;




 typedef mediump_vec3 vec3;




 typedef mediump_vec4 vec4;




 typedef mediump_mat2x2 mat2x2;




 typedef mediump_mat2x3 mat2x3;




 typedef mediump_mat2x4 mat2x4;




 typedef mediump_mat3x2 mat3x2;




 typedef mediump_mat3x3 mat3x3;




 typedef mediump_mat3x4 mat3x4;




 typedef mediump_mat4x2 mat4x2;




 typedef mediump_mat4x3 mat4x3;




 typedef mediump_mat4x4 mat4x4;






 typedef mat2x2 mat2;




 typedef mat3x3 mat3;




 typedef mat4x4 mat4;
# 197 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp"
 typedef mediump_ivec2 ivec2;




 typedef mediump_ivec3 ivec3;




 typedef mediump_ivec4 ivec4;
# 229 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp"
 typedef mediump_uvec2 uvec2;




 typedef mediump_uvec3 uvec3;




 typedef mediump_uvec4 uvec4;
# 248 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/type.hpp"
 typedef detail::tvec2<bool> bvec2;




 typedef detail::tvec3<bool> bvec3;




 typedef detail::tvec4<bool> bvec4;







 typedef detail::tvec2<double> dvec2;




 typedef detail::tvec3<double> dvec3;




 typedef detail::tvec4<double> dvec4;




 typedef detail::tmat2x2<double> dmat2;




 typedef detail::tmat3x3<double> dmat3;




 typedef detail::tmat4x4<double> dmat4;




 typedef detail::tmat2x2<double> dmat2x2;




 typedef detail::tmat2x3<double> dmat2x3;




 typedef detail::tmat2x4<double> dmat2x4;




 typedef detail::tmat3x2<double> dmat3x2;




 typedef detail::tmat3x3<double> dmat3x3;




 typedef detail::tmat3x4<double> dmat3x4;




 typedef detail::tmat4x2<double> dmat4x2;




 typedef detail::tmat4x3<double> dmat4x3;




 typedef detail::tmat4x4<double> dmat4x4;


}
# 98 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp" 1
# 43 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
namespace glm
{
# 54 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType radians(genType const & degrees);







 template <typename genType>
 genType degrees(genType const & radians);
# 73 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType sin(genType const & angle);
# 83 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType cos(genType const & angle);







 template <typename genType>
 genType tan(genType const & angle);
# 103 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType asin(genType const & x);
# 114 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType acos(genType const & x);
# 127 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType atan(genType const & y, genType const & x);
# 137 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType atan(genType const & y_over_x);







 template <typename genType>
 genType sinh(genType const & angle);







 template <typename genType>
 genType cosh(genType const & angle);







 template <typename genType>
 genType tanh(genType const & angle);







 template <typename genType>
 genType asinh(genType const & x);
# 183 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType acosh(genType const & x);
# 193 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp"
 template <typename genType>
 genType atanh(genType const & x);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_trigonometric.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_trigonometric.inl"
namespace glm
{

 template <typename genType> inline
                    genType radians
 (
  genType const & degrees
 )
 {
                                                                                                  ;

  genType const pi = genType(3.1415926535897932384626433832795);
  return degrees * (pi / genType(180));
 }

 template <typename T> inline detail::tvec2<T> radians( detail::tvec2<T> const & v) { return detail::tvec2<T>( radians(v.x), radians(v.y)); } template <typename T> inline detail::tvec3<T> radians( detail::tvec3<T> const & v) { return detail::tvec3<T>( radians(v.x), radians(v.y), radians(v.z)); } template <typename T> inline detail::tvec4<T> radians( detail::tvec4<T> const & v) { return detail::tvec4<T>( radians(v.x), radians(v.y), radians(v.z), radians(v.w)); }


 template <typename genType> inline
                    genType degrees
 (
  genType const & radians
 )
 {
                                                                                                  ;

  const genType pi = genType(3.1415926535897932384626433832795);
  return radians * (genType(180) / pi);
 }

 template <typename T> inline detail::tvec2<T> degrees( detail::tvec2<T> const & v) { return detail::tvec2<T>( degrees(v.x), degrees(v.y)); } template <typename T> inline detail::tvec3<T> degrees( detail::tvec3<T> const & v) { return detail::tvec3<T>( degrees(v.x), degrees(v.y), degrees(v.z)); } template <typename T> inline detail::tvec4<T> degrees( detail::tvec4<T> const & v) { return detail::tvec4<T>( degrees(v.x), degrees(v.y), degrees(v.z), degrees(v.w)); }


 template <typename genType> inline
                    genType sin
 (
  genType const & angle
 )
 {
                                                                                              ;

  return ::std::sin(angle);
 }

 template <typename T> inline detail::tvec2<T> sin( detail::tvec2<T> const & v) { return detail::tvec2<T>( sin(v.x), sin(v.y)); } template <typename T> inline detail::tvec3<T> sin( detail::tvec3<T> const & v) { return detail::tvec3<T>( sin(v.x), sin(v.y), sin(v.z)); } template <typename T> inline detail::tvec4<T> sin( detail::tvec4<T> const & v) { return detail::tvec4<T>( sin(v.x), sin(v.y), sin(v.z), sin(v.w)); }


 template <typename genType> inline
                    genType cos(genType const & angle)
 {
                                                                                              ;

  return ::std::cos(angle);
 }

 template <typename T> inline detail::tvec2<T> cos( detail::tvec2<T> const & v) { return detail::tvec2<T>( cos(v.x), cos(v.y)); } template <typename T> inline detail::tvec3<T> cos( detail::tvec3<T> const & v) { return detail::tvec3<T>( cos(v.x), cos(v.y), cos(v.z)); } template <typename T> inline detail::tvec4<T> cos( detail::tvec4<T> const & v) { return detail::tvec4<T>( cos(v.x), cos(v.y), cos(v.z), cos(v.w)); }


 template <typename genType> inline
                    genType tan
 (
  genType const & angle
 )
 {
                                                                                              ;

  return ::std::tan(angle);
 }

 template <typename T> inline detail::tvec2<T> tan( detail::tvec2<T> const & v) { return detail::tvec2<T>( tan(v.x), tan(v.y)); } template <typename T> inline detail::tvec3<T> tan( detail::tvec3<T> const & v) { return detail::tvec3<T>( tan(v.x), tan(v.y), tan(v.z)); } template <typename T> inline detail::tvec4<T> tan( detail::tvec4<T> const & v) { return detail::tvec4<T>( tan(v.x), tan(v.y), tan(v.z), tan(v.w)); }


 template <typename genType> inline
                    genType asin
 (
  genType const & x
 )
 {
                                                                                               ;

  return ::std::asin(x);
 }

 template <typename T> inline detail::tvec2<T> asin( detail::tvec2<T> const & v) { return detail::tvec2<T>( asin(v.x), asin(v.y)); } template <typename T> inline detail::tvec3<T> asin( detail::tvec3<T> const & v) { return detail::tvec3<T>( asin(v.x), asin(v.y), asin(v.z)); } template <typename T> inline detail::tvec4<T> asin( detail::tvec4<T> const & v) { return detail::tvec4<T>( asin(v.x), asin(v.y), asin(v.z), asin(v.w)); }


 template <typename genType> inline
                    genType acos
 (
  genType const & x
 )
 {
                                                                                               ;

  return ::std::acos(x);
 }

 template <typename T> inline detail::tvec2<T> acos( detail::tvec2<T> const & v) { return detail::tvec2<T>( acos(v.x), acos(v.y)); } template <typename T> inline detail::tvec3<T> acos( detail::tvec3<T> const & v) { return detail::tvec3<T>( acos(v.x), acos(v.y), acos(v.z)); } template <typename T> inline detail::tvec4<T> acos( detail::tvec4<T> const & v) { return detail::tvec4<T>( acos(v.x), acos(v.y), acos(v.z), acos(v.w)); }


 template <typename genType> inline
                    genType atan
 (
  genType const & y,
  genType const & x
 )
 {
                                                                                               ;

  return ::std::atan2(y, x);
 }

 template <typename T> inline detail::tvec2<T> atan ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( atan(x.x, y.x), atan(x.y, y.y)); } template <typename T> inline detail::tvec3<T> atan ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z)); } template <typename T> inline detail::tvec4<T> atan ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( atan(x.x, y.x), atan(x.y, y.y), atan(x.z, y.z), atan(x.w, y.w)); }

 template <typename genType> inline
                    genType atan
 (
  genType const & x
 )
 {
                                                                                               ;

  return ::std::atan(x);
 }

 template <typename T> inline detail::tvec2<T> atan( detail::tvec2<T> const & v) { return detail::tvec2<T>( atan(v.x), atan(v.y)); } template <typename T> inline detail::tvec3<T> atan( detail::tvec3<T> const & v) { return detail::tvec3<T>( atan(v.x), atan(v.y), atan(v.z)); } template <typename T> inline detail::tvec4<T> atan( detail::tvec4<T> const & v) { return detail::tvec4<T>( atan(v.x), atan(v.y), atan(v.z), atan(v.w)); }


 template <typename genType> inline
                    genType sinh
 (
  genType const & angle
 )
 {
                                                                                               ;

  return std::sinh(angle);
 }

 template <typename T> inline detail::tvec2<T> sinh( detail::tvec2<T> const & v) { return detail::tvec2<T>( sinh(v.x), sinh(v.y)); } template <typename T> inline detail::tvec3<T> sinh( detail::tvec3<T> const & v) { return detail::tvec3<T>( sinh(v.x), sinh(v.y), sinh(v.z)); } template <typename T> inline detail::tvec4<T> sinh( detail::tvec4<T> const & v) { return detail::tvec4<T>( sinh(v.x), sinh(v.y), sinh(v.z), sinh(v.w)); }


 template <typename genType> inline
                    genType cosh
 (
  genType const & angle
 )
 {
                                                                                               ;

  return std::cosh(angle);
 }

 template <typename T> inline detail::tvec2<T> cosh( detail::tvec2<T> const & v) { return detail::tvec2<T>( cosh(v.x), cosh(v.y)); } template <typename T> inline detail::tvec3<T> cosh( detail::tvec3<T> const & v) { return detail::tvec3<T>( cosh(v.x), cosh(v.y), cosh(v.z)); } template <typename T> inline detail::tvec4<T> cosh( detail::tvec4<T> const & v) { return detail::tvec4<T>( cosh(v.x), cosh(v.y), cosh(v.z), cosh(v.w)); }


 template <typename genType> inline
                    genType tanh
 (
  genType const & angle
 )
 {
                                                                                               ;

  return std::tanh(angle);
 }

 template <typename T> inline detail::tvec2<T> tanh( detail::tvec2<T> const & v) { return detail::tvec2<T>( tanh(v.x), tanh(v.y)); } template <typename T> inline detail::tvec3<T> tanh( detail::tvec3<T> const & v) { return detail::tvec3<T>( tanh(v.x), tanh(v.y), tanh(v.z)); } template <typename T> inline detail::tvec4<T> tanh( detail::tvec4<T> const & v) { return detail::tvec4<T>( tanh(v.x), tanh(v.y), tanh(v.z), tanh(v.w)); }


 template <typename genType> inline
                    genType asinh
 (
  genType const & x
 )
 {
                                                                                                ;

  return (x < genType(0) ? genType(-1) : (x > genType(0) ? genType(1) : genType(0))) * log(abs(x) + sqrt(genType(1) + x * x));
 }

 template <typename T> inline detail::tvec2<T> asinh( detail::tvec2<T> const & v) { return detail::tvec2<T>( asinh(v.x), asinh(v.y)); } template <typename T> inline detail::tvec3<T> asinh( detail::tvec3<T> const & v) { return detail::tvec3<T>( asinh(v.x), asinh(v.y), asinh(v.z)); } template <typename T> inline detail::tvec4<T> asinh( detail::tvec4<T> const & v) { return detail::tvec4<T>( asinh(v.x), asinh(v.y), asinh(v.z), asinh(v.w)); }


 template <typename genType> inline
                    genType acosh
 (
  genType const & x
 )
 {
                                                                                                ;

  if(x < genType(1))
   return genType(0);
  return log(x + sqrt(x * x - genType(1)));
 }

 template <typename T> inline detail::tvec2<T> acosh( detail::tvec2<T> const & v) { return detail::tvec2<T>( acosh(v.x), acosh(v.y)); } template <typename T> inline detail::tvec3<T> acosh( detail::tvec3<T> const & v) { return detail::tvec3<T>( acosh(v.x), acosh(v.y), acosh(v.z)); } template <typename T> inline detail::tvec4<T> acosh( detail::tvec4<T> const & v) { return detail::tvec4<T>( acosh(v.x), acosh(v.y), acosh(v.z), acosh(v.w)); }


 template <typename genType> inline
                    genType atanh
 (
  genType const & x
 )
 {
                                                                                                ;

  if(abs(x) >= genType(1))
   return 0;
  return genType(0.5) * log((genType(1) + x) / (genType(1) - x));
 }

 template <typename T> inline detail::tvec2<T> atanh( detail::tvec2<T> const & v) { return detail::tvec2<T>( atanh(v.x), atanh(v.y)); } template <typename T> inline detail::tvec3<T> atanh( detail::tvec3<T> const & v) { return detail::tvec3<T>( atanh(v.x), atanh(v.y), atanh(v.z)); } template <typename T> inline detail::tvec4<T> atanh( detail::tvec4<T> const & v) { return detail::tvec4<T>( atanh(v.x), atanh(v.y), atanh(v.z), atanh(v.w)); }

}
# 199 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_trigonometric.hpp" 2
# 100 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp" 1
# 39 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
namespace glm
{
# 52 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
 template <typename genType>
 genType pow(genType const & x, genType const & y);
# 62 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
 template <typename genType>
 genType exp(genType const & x);
# 74 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
 template <typename genType>
 genType log(genType const & x);
# 84 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
 template <typename genType>
 genType exp2(genType const & x);
# 95 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
 template <typename genType>
 genType log2(genType const & x);
# 105 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
 template <typename genType>
 genType sqrt(genType const & x);
# 115 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp"
 template <typename genType>
 genType inversesqrt(genType const & x);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_exponential.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_exponential.inl"
namespace glm
{

 template <typename genType> inline
                    genType pow
 (
  genType const & x,
  genType const & y
 )
 {
                                                                                              ;

  return ::std::pow(x, y);
 }

 template <typename T> inline detail::tvec2<T> pow ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( pow(x.x, y.x), pow(x.y, y.y)); } template <typename T> inline detail::tvec3<T> pow ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z)); } template <typename T> inline detail::tvec4<T> pow ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( pow(x.x, y.x), pow(x.y, y.y), pow(x.z, y.z), pow(x.w, y.w)); }


 template <typename genType> inline
                    genType exp
 (
  genType const & x
 )
 {
                                                                                              ;

  return ::std::exp(x);
 }

 template <typename T> inline detail::tvec2<T> exp( detail::tvec2<T> const & v) { return detail::tvec2<T>( exp(v.x), exp(v.y)); } template <typename T> inline detail::tvec3<T> exp( detail::tvec3<T> const & v) { return detail::tvec3<T>( exp(v.x), exp(v.y), exp(v.z)); } template <typename T> inline detail::tvec4<T> exp( detail::tvec4<T> const & v) { return detail::tvec4<T>( exp(v.x), exp(v.y), exp(v.z), exp(v.w)); }


 template <typename genType> inline
                    genType log
 (
  genType const & x
 )
 {
                                                                                              ;

  return ::std::log(x);
 }

 template <typename T> inline detail::tvec2<T> log( detail::tvec2<T> const & v) { return detail::tvec2<T>( log(v.x), log(v.y)); } template <typename T> inline detail::tvec3<T> log( detail::tvec3<T> const & v) { return detail::tvec3<T>( log(v.x), log(v.y), log(v.z)); } template <typename T> inline detail::tvec4<T> log( detail::tvec4<T> const & v) { return detail::tvec4<T>( log(v.x), log(v.y), log(v.z), log(v.w)); }


 template <typename genType> inline
                    genType exp2
 (
  genType const & x
 )
 {
                                                                                               ;

  return ::std::exp(genType(0.69314718055994530941723212145818) * x);
 }

 template <typename T> inline detail::tvec2<T> exp2( detail::tvec2<T> const & v) { return detail::tvec2<T>( exp2(v.x), exp2(v.y)); } template <typename T> inline detail::tvec3<T> exp2( detail::tvec3<T> const & v) { return detail::tvec3<T>( exp2(v.x), exp2(v.y), exp2(v.z)); } template <typename T> inline detail::tvec4<T> exp2( detail::tvec4<T> const & v) { return detail::tvec4<T>( exp2(v.x), exp2(v.y), exp2(v.z), exp2(v.w)); }

namespace _detail
{
 template <int _PATH = detail::float_or_int_value::GLM_ERROR>
 struct _compute_log2
 {
  template <typename T>
  T operator() (T const & Value) const;






 };

 template <>
 struct _compute_log2<detail::float_or_int_value::GLM_FLOAT>
 {
  template <typename T>
  T operator() (T const & Value) const
  {
   return T(::std::log(Value)) / T(0.69314718055994530941723212145818);
  }
 };

}


 template <typename genType> inline
                    genType log2
 (
  genType const & x
 )
 {
  (__builtin_expect(!(x > genType(0)), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_exponential.inl", 122, "x > genType(0)") : (void)0);
  return _detail::_compute_log2<detail::float_or_int_trait<genType>::ID>()(x);
 }

 template <typename T> inline detail::tvec2<T> log2( detail::tvec2<T> const & v) { return detail::tvec2<T>( log2(v.x), log2(v.y)); } template <typename T> inline detail::tvec3<T> log2( detail::tvec3<T> const & v) { return detail::tvec3<T>( log2(v.x), log2(v.y), log2(v.z)); } template <typename T> inline detail::tvec4<T> log2( detail::tvec4<T> const & v) { return detail::tvec4<T>( log2(v.x), log2(v.y), log2(v.z), log2(v.w)); }


 template <typename genType> inline
                    genType sqrt
 (
  genType const & x
 )
 {
                                                                                               ;

  return genType(::std::sqrt(x));
 }

 template <typename T> inline detail::tvec2<T> sqrt( detail::tvec2<T> const & v) { return detail::tvec2<T>( sqrt(v.x), sqrt(v.y)); } template <typename T> inline detail::tvec3<T> sqrt( detail::tvec3<T> const & v) { return detail::tvec3<T>( sqrt(v.x), sqrt(v.y), sqrt(v.z)); } template <typename T> inline detail::tvec4<T> sqrt( detail::tvec4<T> const & v) { return detail::tvec4<T>( sqrt(v.x), sqrt(v.y), sqrt(v.z), sqrt(v.w)); }

 template <typename genType> inline
                    genType inversesqrt
 (
  genType const & x
 )
 {
                                                                                                      ;

  return genType(1) / ::std::sqrt(x);
 }

 template <typename T> inline detail::tvec2<T> inversesqrt( detail::tvec2<T> const & v) { return detail::tvec2<T>( inversesqrt(v.x), inversesqrt(v.y)); } template <typename T> inline detail::tvec3<T> inversesqrt( detail::tvec3<T> const & v) { return detail::tvec3<T>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z)); } template <typename T> inline detail::tvec4<T> inversesqrt( detail::tvec4<T> const & v) { return detail::tvec4<T>( inversesqrt(v.x), inversesqrt(v.y), inversesqrt(v.z), inversesqrt(v.w)); }

}
# 121 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_exponential.hpp" 2
# 101 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp" 1
# 39 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/_fixes.hpp" 1
# 39 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp" 2


namespace glm
{
# 52 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType abs(genType const & x);







 template <typename genType>
 genType sign(genType const & x);







 template <typename genType>
 genType floor(genType const & x);
# 80 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType trunc(genType const & x);
# 93 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType round(genType const & x);
# 105 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType roundEven(genType const & x);
# 115 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType ceil(genType const & x);







 template <typename genType>
 genType fract(genType const & x);
# 134 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType mod(
  genType const & x,
  genType const & y);
# 146 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType mod(
  genType const & x,
  typename genType::value_type const & y);
# 160 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType modf(
  genType const & x,
  genType & i);







 template <typename genType>
 genType min(
  genType const & x,
  genType const & y);

 template <typename genType>
 genType min(
  genType const & x,
  typename genType::value_type const & y);







 template <typename genType>
 genType max(
  genType const & x,
  genType const & y);

 template <typename genType>
 genType max(
  genType const & x,
  typename genType::value_type const & y);
# 204 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType clamp(
  genType const & x,
  genType const & minVal,
  genType const & maxVal);

 template <typename genType>
 genType clamp(
  genType const & x,
  typename genType::value_type const & minVal,
  typename genType::value_type const & maxVal);
# 258 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genTypeT, typename genTypeU>
 genTypeT mix(genTypeT const & x, genTypeT const & y, genTypeU const & a);





 template <typename genType>
 genType step(
  genType const & edge,
  genType const & x);

 template <typename genType>
 genType step(
  typename genType::value_type const & edge,
  genType const & x);
# 289 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 genType smoothstep(
  genType const & edge0,
  genType const & edge1,
  genType const & x);

 template <typename genType>
 genType smoothstep(
  typename genType::value_type const & edge0,
  typename genType::value_type const & edge1,
  genType const & x);
# 313 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 typename genType::bool_type isnan(genType const & x);
# 326 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType>
 typename genType::bool_type isinf(genType const & x);
# 338 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType, typename genIType>
 genIType floatBitsToInt(genType const & value);
# 350 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType, typename genUType>
 genUType floatBitsToUint(genType const & value);
# 366 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType, typename genIType>
 genType intBitsToFloat(genIType const & value);
# 382 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType, typename genUType>
 genType uintBitsToFloat(genUType const & value);







 template <typename genType>
 genType fma(genType const & a, genType const & b, genType const & c);
# 408 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType, typename genIType>
 genType frexp(genType const & x, genIType & exp);
# 422 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp"
 template <typename genType, typename genIType>
 genType ldexp(genType const & x, genIType const & exp);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl"
namespace glm{
namespace detail
{
 template <typename genFIType, bool >
 struct Abs_
 {};

 template <typename genFIType>
 struct Abs_<genFIType, true>
 {
  static genFIType get(genFIType const & x)
  {


                                                                                           ;
   return x >= genFIType(0) ? x : -x;

  }
 };

 template <typename genFIType>
 struct Abs_<genFIType, false>
 {
  static genFIType get(genFIType const & x)
  {

                                                                                             ;
   return x;
  }
 };
}


 template <typename genFIType> inline
                    genFIType abs
 (
  genFIType const & x
 )
 {
  return detail::Abs_<genFIType, std::numeric_limits<genFIType>::is_signed>::get(x);
 }

 template <typename T> inline detail::tvec2<T> abs( detail::tvec2<T> const & v) { return detail::tvec2<T>( abs(v.x), abs(v.y)); } template <typename T> inline detail::tvec3<T> abs( detail::tvec3<T> const & v) { return detail::tvec3<T>( abs(v.x), abs(v.y), abs(v.z)); } template <typename T> inline detail::tvec4<T> abs( detail::tvec4<T> const & v) { return detail::tvec4<T>( abs(v.x), abs(v.y), abs(v.z), abs(v.w)); }



 template <typename genFIType> inline
                    genFIType sign
 (
  genFIType const & x
 )
 {


                                                                       ;

  genFIType result;
  if(x > genFIType(0))
   result = genFIType(1);
  else if(x < genFIType(0))
   result = genFIType(-1);
  else
   result = genFIType(0);
  return result;
 }

 template <typename T> inline detail::tvec2<T> sign( detail::tvec2<T> const & v) { return detail::tvec2<T>( sign(v.x), sign(v.y)); } template <typename T> inline detail::tvec3<T> sign( detail::tvec3<T> const & v) { return detail::tvec3<T>( sign(v.x), sign(v.y), sign(v.z)); } template <typename T> inline detail::tvec4<T> sign( detail::tvec4<T> const & v) { return detail::tvec4<T>( sign(v.x), sign(v.y), sign(v.z), sign(v.w)); }


 template <> inline
                    detail::half floor<detail::half>(detail::half const & x)
 {
  return detail::half(::std::floor(float(x)));
 }

 template <typename genType> inline
                    genType floor(genType const & x)
 {
                                                                                                 ;

  return ::std::floor(x);
 }

 template <typename T> inline detail::tvec2<T> floor( detail::tvec2<T> const & v) { return detail::tvec2<T>( floor(v.x), floor(v.y)); } template <typename T> inline detail::tvec3<T> floor( detail::tvec3<T> const & v) { return detail::tvec3<T>( floor(v.x), floor(v.y), floor(v.z)); } template <typename T> inline detail::tvec4<T> floor( detail::tvec4<T> const & v) { return detail::tvec4<T>( floor(v.x), floor(v.y), floor(v.z), floor(v.w)); }


 template <typename genType> inline
                    genType trunc(genType const & x)
 {
                                                                                                 ;
  return x < 0 ? -floor(-x) : floor(x);
 }

 template <typename T> inline detail::tvec2<T> trunc( detail::tvec2<T> const & v) { return detail::tvec2<T>( trunc(v.x), trunc(v.y)); } template <typename T> inline detail::tvec3<T> trunc( detail::tvec3<T> const & v) { return detail::tvec3<T>( trunc(v.x), trunc(v.y), trunc(v.z)); } template <typename T> inline detail::tvec4<T> trunc( detail::tvec4<T> const & v) { return detail::tvec4<T>( trunc(v.x), trunc(v.y), trunc(v.z), trunc(v.w)); }


 template <typename genType> inline
                    genType round(genType const& x)
 {
                                                                                                 ;

  if(x < 0)
   return genType(int(x - genType(0.5)));
  return genType(int(x + genType(0.5)));
 }

 template <typename T> inline detail::tvec2<T> round( detail::tvec2<T> const & v) { return detail::tvec2<T>( round(v.x), round(v.y)); } template <typename T> inline detail::tvec3<T> round( detail::tvec3<T> const & v) { return detail::tvec3<T>( round(v.x), round(v.y), round(v.z)); } template <typename T> inline detail::tvec4<T> round( detail::tvec4<T> const & v) { return detail::tvec4<T>( round(v.x), round(v.y), round(v.z), round(v.w)); }
# 149 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl"
 template <typename genType> inline
                    genType roundEven(genType const & x)
 {
                                                                                                     ;

  int Integer = int(x);
  genType IntegerPart = genType(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > genType(0.5) || FractionalPart < genType(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= genType(0))
  {
   return IntegerPart - 1;
  }
  else
  {
   return IntegerPart + 1;
  }




 }

 template <typename T> inline detail::tvec2<T> roundEven( detail::tvec2<T> const & v) { return detail::tvec2<T>( roundEven(v.x), roundEven(v.y)); } template <typename T> inline detail::tvec3<T> roundEven( detail::tvec3<T> const & v) { return detail::tvec3<T>( roundEven(v.x), roundEven(v.y), roundEven(v.z)); } template <typename T> inline detail::tvec4<T> roundEven( detail::tvec4<T> const & v) { return detail::tvec4<T>( roundEven(v.x), roundEven(v.y), roundEven(v.z), roundEven(v.w)); }


 template <typename genType> inline
                    genType ceil(genType const & x)
 {
                                                                                                ;

  return ::std::ceil(x);
 }

 template <typename T> inline detail::tvec2<T> ceil( detail::tvec2<T> const & v) { return detail::tvec2<T>( ceil(v.x), ceil(v.y)); } template <typename T> inline detail::tvec3<T> ceil( detail::tvec3<T> const & v) { return detail::tvec3<T>( ceil(v.x), ceil(v.y), ceil(v.z)); } template <typename T> inline detail::tvec4<T> ceil( detail::tvec4<T> const & v) { return detail::tvec4<T>( ceil(v.x), ceil(v.y), ceil(v.z), ceil(v.w)); }


 template <typename genType> inline
                    genType fract
 (
  genType const & x
 )
 {
                                                                                                 ;

  return x - ::std::floor(x);
 }

 template <typename T> inline detail::tvec2<T> fract( detail::tvec2<T> const & v) { return detail::tvec2<T>( fract(v.x), fract(v.y)); } template <typename T> inline detail::tvec3<T> fract( detail::tvec3<T> const & v) { return detail::tvec3<T>( fract(v.x), fract(v.y), fract(v.z)); } template <typename T> inline detail::tvec4<T> fract( detail::tvec4<T> const & v) { return detail::tvec4<T>( fract(v.x), fract(v.y), fract(v.z), fract(v.w)); }


 template <typename genType> inline
                    genType mod
 (
  genType const & x,
  genType const & y
 )
 {
                                                                                               ;

  return x - y * floor(x / y);
 }

 template <typename T> inline detail::tvec2<T> mod ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( mod(x.x, y), mod(x.y, y)); } template <typename T> inline detail::tvec3<T> mod ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( mod(x.x, y), mod(x.y, y), mod(x.z, y)); } template <typename T> inline detail::tvec4<T> mod ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( mod(x.x, y), mod(x.y, y), mod(x.z, y), mod(x.w, y)); }
 template <typename T> inline detail::tvec2<T> mod ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( mod(x.x, y.x), mod(x.y, y.y)); } template <typename T> inline detail::tvec3<T> mod ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z)); } template <typename T> inline detail::tvec4<T> mod ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( mod(x.x, y.x), mod(x.y, y.y), mod(x.z, y.z), mod(x.w, y.w)); }


 template <typename genType> inline
                    genType modf
 (
  genType const & x,
  genType & i
 )
 {
                                                                                                ;

  return std::modf(x, &i);
 }

 template <typename valType> inline
                    detail::tvec2<valType> modf
 (
  detail::tvec2<valType> const & x,
  detail::tvec2<valType> & i
 )
 {
  return detail::tvec2<valType>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template <typename valType> inline
                    detail::tvec3<valType> modf
 (
  detail::tvec3<valType> const & x,
  detail::tvec3<valType> & i
 )
 {
  return detail::tvec3<valType>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template <typename valType> inline
                    detail::tvec4<valType> modf
 (
  detail::tvec4<valType> const & x,
  detail::tvec4<valType> & i
 )
 {
  return detail::tvec4<valType>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 284 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl"
 template <typename genType> inline
                    genType min
 (
  genType const & x,
  genType const & y
 )
 {



                                                               ;

  return x < y ? x : y;
 }

 template <typename T> inline detail::tvec2<T> min ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( min(x.x, y), min(x.y, y)); } template <typename T> inline detail::tvec3<T> min ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( min(x.x, y), min(x.y, y), min(x.z, y)); } template <typename T> inline detail::tvec4<T> min ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( min(x.x, y), min(x.y, y), min(x.z, y), min(x.w, y)); }
 template <typename T> inline detail::tvec2<T> min ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( min(x.x, y.x), min(x.y, y.y)); } template <typename T> inline detail::tvec3<T> min ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z)); } template <typename T> inline detail::tvec4<T> min ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( min(x.x, y.x), min(x.y, y.y), min(x.z, y.z), min(x.w, y.w)); }


 template <typename genType> inline
                    genType max
 (
  genType const & x,
  genType const & y
 )
 {



                                                               ;

  return x > y ? x : y;
 }

 template <typename T> inline detail::tvec2<T> max ( detail::tvec2<T> const & x, typename detail::tvec2<T>::value_type const & y ) { return detail::tvec2<T>( max(x.x, y), max(x.y, y)); } template <typename T> inline detail::tvec3<T> max ( detail::tvec3<T> const & x, typename detail::tvec3<T>::value_type const & y ) { return detail::tvec3<T>( max(x.x, y), max(x.y, y), max(x.z, y)); } template <typename T> inline detail::tvec4<T> max ( detail::tvec4<T> const & x, typename detail::tvec4<T>::value_type const & y ) { return detail::tvec4<T>( max(x.x, y), max(x.y, y), max(x.z, y), max(x.w, y)); }
 template <typename T> inline detail::tvec2<T> max ( detail::tvec2<T> const & x, detail::tvec2<T> const & y ) { return detail::tvec2<T>( max(x.x, y.x), max(x.y, y.y)); } template <typename T> inline detail::tvec3<T> max ( detail::tvec3<T> const & x, detail::tvec3<T> const & y ) { return detail::tvec3<T>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z)); } template <typename T> inline detail::tvec4<T> max ( detail::tvec4<T> const & x, detail::tvec4<T> const & y ) { return detail::tvec4<T>( max(x.x, y.x), max(x.y, y.y), max(x.z, y.z), max(x.w, y.w)); }


 template <typename valType> inline
                    valType clamp
 (
  valType const & x,
  valType const & minVal,
  valType const & maxVal
 )
 {



                                                                 ;





  return max(min(x, maxVal), minVal);
 }

 template <typename T> inline
                    detail::tvec2<T> clamp
 (
  detail::tvec2<T> const & x,
  typename detail::tvec2<T>::value_type const & minVal,
  typename detail::tvec2<T>::value_type const & maxVal
 )
 {
  return detail::tvec2<T>(
   clamp(x.x, minVal, maxVal),
   clamp(x.y, minVal, maxVal));
 }

 template <typename T> inline
                    detail::tvec3<T> clamp
 (
  detail::tvec3<T> const & x,
  typename detail::tvec3<T>::value_type const & minVal,
  typename detail::tvec3<T>::value_type const & maxVal
 )
 {
  return detail::tvec3<T>(
   clamp(x.x, minVal, maxVal),
   clamp(x.y, minVal, maxVal),
   clamp(x.z, minVal, maxVal));
 }

 template <typename T> inline
                    detail::tvec4<T> clamp
 (
  detail::tvec4<T> const & x,
  typename detail::tvec4<T>::value_type const & minVal,
  typename detail::tvec4<T>::value_type const & maxVal
 )
 {
  return detail::tvec4<T>(
   clamp(x.x, minVal, maxVal),
   clamp(x.y, minVal, maxVal),
   clamp(x.z, minVal, maxVal),
   clamp(x.w, minVal, maxVal));
 }

 template <typename T> inline
                    detail::tvec2<T> clamp
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & minVal,
  detail::tvec2<T> const & maxVal
 )
 {
  return detail::tvec2<T>(
   clamp(x.x, minVal.x, maxVal.x),
   clamp(x.y, minVal.y, maxVal.y));
 }

 template <typename T> inline
                    detail::tvec3<T> clamp
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & minVal,
  detail::tvec3<T> const & maxVal
 )
 {
  return detail::tvec3<T>(
   clamp(x.x, minVal.x, maxVal.x),
   clamp(x.y, minVal.y, maxVal.y),
   clamp(x.z, minVal.z, maxVal.z));
 }

 template <typename T> inline
                    detail::tvec4<T> clamp
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & minVal,
  detail::tvec4<T> const & maxVal
 )
 {
  return detail::tvec4<T>(
   clamp(x.x, minVal.x, maxVal.x),
   clamp(x.y, minVal.y, maxVal.y),
   clamp(x.z, minVal.z, maxVal.z),
   clamp(x.w, minVal.w, maxVal.w));
 }


 template <typename genTypeT, typename genTypeU> inline
                    genTypeT mix
 (
  genTypeT const & x,
  genTypeT const & y,
  genTypeU const & a
 )
 {






  return genTypeT(genTypeU(x) + a * genTypeU(y - x));
 }

 template <typename valTypeA, typename valTypeB> inline
                    detail::tvec2<valTypeA> mix
 (
  detail::tvec2<valTypeA> const & x,
  detail::tvec2<valTypeA> const & y,
  valTypeB const & a
 )
 {
  return detail::tvec2<valTypeA>(
   detail::tvec2<valTypeB>(x) + a * detail::tvec2<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB> inline
                    detail::tvec3<valTypeA> mix
 (
  detail::tvec3<valTypeA> const & x,
  detail::tvec3<valTypeA> const & y,
  valTypeB const & a
 )
 {
  return detail::tvec3<valTypeA>(
   detail::tvec3<valTypeB>(x) + a * detail::tvec3<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB> inline
                    detail::tvec4<valTypeA> mix
 (
  detail::tvec4<valTypeA> const & x,
  detail::tvec4<valTypeA> const & y,
  valTypeB const & a
 )
 {
  return detail::tvec4<valTypeA>(
   detail::tvec4<valTypeB>(x) + a * detail::tvec4<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB> inline
                    detail::tvec2<valTypeA> mix
 (
  detail::tvec2<valTypeA> const & x,
  detail::tvec2<valTypeA> const & y,
  detail::tvec2<valTypeB> const & a
 )
 {
  return detail::tvec2<valTypeA>(
   detail::tvec2<valTypeB>(x) + a * detail::tvec2<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB> inline
                    detail::tvec3<valTypeA> mix
 (
  detail::tvec3<valTypeA> const & x,
  detail::tvec3<valTypeA> const & y,
  detail::tvec3<valTypeB> const & a
 )
 {
  return detail::tvec3<valTypeA>(
   detail::tvec3<valTypeB>(x) + a * detail::tvec3<valTypeB>(y - x));
 }

 template <typename valTypeA, typename valTypeB> inline
                    detail::tvec4<valTypeA> mix
 (
  detail::tvec4<valTypeA> const & x,
  detail::tvec4<valTypeA> const & y,
  detail::tvec4<valTypeB> const & a
 )
 {
  return detail::tvec4<valTypeA>(
   detail::tvec4<valTypeB>(x) + a * detail::tvec4<valTypeB>(y - x));
 }
# 532 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl"
 template <typename genType> inline
                    genType mix
 (
  genType const & x,
  genType const & y,
  bool const & a
 )
 {
                                                                                               ;

  return a ? y : x;
 }

 template <typename T> inline
                    detail::tvec2<T> mix
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  typename detail::tvec2<T>::bool_type a
 )
 {
                                                                                         ;

  detail::tvec2<T> result;
  for
  (
   typename detail::tvec2<T>::size_type i = 0;
   i < detail::tvec2<T>::value_size();
   ++i
  )
  {
   result[i] = a[i] ? y[i] : x[i];
  }
  return result;
 }

 template <typename T> inline
                    detail::tvec3<T> mix
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  typename detail::tvec3<T>::bool_type a
 )
 {
                                                                                         ;

  detail::tvec3<T> result;
  for
  (
   typename detail::tvec3<T>::size_type i = 0;
   i < detail::tvec3<T>::value_size();
   ++i
  )
  {
   result[i] = a[i] ? y[i] : x[i];
  }
  return result;
 }

 template <typename T> inline
                    detail::tvec4<T> mix
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  typename detail::tvec4<T>::bool_type a
 )
 {
                                                                                         ;

  detail::tvec4<T> result;
  for
  (
   typename detail::tvec4<T>::size_type i = 0;
   i < detail::tvec4<T>::value_size();
   ++i
  )
  {
   result[i] = a[i] ? y[i] : x[i];
  }
  return result;
 }


 template <typename genType> inline
                    genType step
 (
  genType const & edge,
  genType const & x
 )
 {
                                                                                               ;

  return x < edge ? genType(0) : genType(1);
 }

 template <typename T> inline
                    detail::tvec2<T> step
 (
  typename detail::tvec2<T>::value_type const & edge,
  detail::tvec2<T> const & x
 )
 {
  return detail::tvec2<T>(
   x.x < edge ? T(0) : T(1),
   x.y < edge ? T(0) : T(1));
 }

 template <typename T> inline
                    detail::tvec3<T> step
 (
  typename detail::tvec3<T>::value_type const & edge,
  detail::tvec3<T> const & x
 )
 {
  return detail::tvec3<T>(
   x.x < edge ? T(0) : T(1),
   x.y < edge ? T(0) : T(1),
   x.z < edge ? T(0) : T(1));
 }

 template <typename T> inline
                    detail::tvec4<T> step
 (
  typename detail::tvec4<T>::value_type const & edge,
  detail::tvec4<T> const & x
 )
 {
  return detail::tvec4<T>(
   x.x < edge ? T(0) : T(1),
   x.y < edge ? T(0) : T(1),
   x.z < edge ? T(0) : T(1),
   x.w < edge ? T(0) : T(1));
 }

 template <typename T> inline
                    detail::tvec2<T> step
 (
  detail::tvec2<T> const & edge,
  detail::tvec2<T> const & x
 )
 {
  return detail::tvec2<T>(
   x.x < edge.x ? T(0) : T(1),
   x.y < edge.y ? T(0) : T(1));
 }

 template <typename T> inline
                    detail::tvec3<T> step
 (
  detail::tvec3<T> const & edge,
  detail::tvec3<T> const & x
 )
 {
  return detail::tvec3<T>(
   x.x < edge.x ? T(0) : T(1),
   x.y < edge.y ? T(0) : T(1),
   x.z < edge.z ? T(0) : T(1));
 }

 template <typename T> inline
                    detail::tvec4<T> step
 (
  detail::tvec4<T> const & edge,
  detail::tvec4<T> const & x
 )
 {
  return detail::tvec4<T>(
   x.x < edge.x ? T(0) : T(1),
   x.y < edge.y ? T(0) : T(1),
   x.z < edge.z ? T(0) : T(1),
   x.w < edge.w ? T(0) : T(1));
 }


 template <typename genType> inline
                    genType smoothstep
 (
  genType const & edge0,
  genType const & edge1,
  genType const & x
 )
 {
                                                                                               ;

  genType tmp = clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template <typename T> inline
                    detail::tvec2<T> smoothstep
 (
  typename detail::tvec2<T>::value_type const & edge0,
  typename detail::tvec2<T>::value_type const & edge1,
  detail::tvec2<T> const & x
 )
 {
  return detail::tvec2<T>(
   smoothstep(edge0, edge1, x.x),
   smoothstep(edge0, edge1, x.y));
 }

 template <typename T> inline
                    detail::tvec3<T> smoothstep
 (
  typename detail::tvec3<T>::value_type const & edge0,
  typename detail::tvec3<T>::value_type const & edge1,
  detail::tvec3<T> const & x
 )
 {
  return detail::tvec3<T>(
   smoothstep(edge0, edge1, x.x),
   smoothstep(edge0, edge1, x.y),
   smoothstep(edge0, edge1, x.z));
 }

 template <typename T> inline
                    detail::tvec4<T> smoothstep
 (
  typename detail::tvec4<T>::value_type const & edge0,
  typename detail::tvec4<T>::value_type const & edge1,
  detail::tvec4<T> const & x
 )
 {
  return detail::tvec4<T>(
   smoothstep(edge0, edge1, x.x),
   smoothstep(edge0, edge1, x.y),
   smoothstep(edge0, edge1, x.z),
   smoothstep(edge0, edge1, x.w));
 }

 template <typename T> inline
                    detail::tvec2<T> smoothstep
 (
  detail::tvec2<T> const & edge0,
  detail::tvec2<T> const & edge1,
  detail::tvec2<T> const & x
 )
 {
  return detail::tvec2<T>(
   smoothstep(edge0.x, edge1.x, x.x),
   smoothstep(edge0.y, edge1.y, x.y));
 }

 template <typename T> inline
                    detail::tvec3<T> smoothstep
 (
  detail::tvec3<T> const & edge0,
  detail::tvec3<T> const & edge1,
  detail::tvec3<T> const & x
 )
 {
  return detail::tvec3<T>(
   smoothstep(edge0.x, edge1.x, x.x),
   smoothstep(edge0.y, edge1.y, x.y),
   smoothstep(edge0.z, edge1.z, x.z));
 }

 template <typename T> inline
                    detail::tvec4<T> smoothstep
 (
  detail::tvec4<T> const & edge0,
  detail::tvec4<T> const & edge1,
  detail::tvec4<T> const & x
 )
 {
  return detail::tvec4<T>(
   smoothstep(edge0.x, edge1.x, x.x),
   smoothstep(edge0.y, edge1.y, x.y),
   smoothstep(edge0.z, edge1.z, x.z),
   smoothstep(edge0.w, edge1.w, x.w));
 }


 template <typename genType> inline
                    bool isnan(genType const & x)
 {
                                                                                                 ;
# 819 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl"
   return std::isnan(x);

 }

 template <typename T> inline
                    typename detail::tvec2<T>::bool_type isnan
 (
  detail::tvec2<T> const & x
 )
 {
  return typename detail::tvec2<T>::bool_type(
   isnan(x.x),
   isnan(x.y));
 }

 template <typename T> inline
                    typename detail::tvec3<T>::bool_type isnan
 (
  detail::tvec3<T> const & x
 )
 {
  return typename detail::tvec3<T>::bool_type(
   isnan(x.x),
   isnan(x.y),
   isnan(x.z));
 }

 template <typename T> inline
                    typename detail::tvec4<T>::bool_type isnan
 (
  detail::tvec4<T> const & x
 )
 {
  return typename detail::tvec4<T>::bool_type(
   isnan(x.x),
   isnan(x.y),
   isnan(x.z),
   isnan(x.w));
 }

 template <typename genType> inline
                    bool isinf(
  genType const & x)
 {
                                                                                                 ;
# 874 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl"
   return std::isinf(x);
# 891 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_common.inl"
 }

 template <typename T> inline
                    typename detail::tvec2<T>::bool_type isinf
 (
  detail::tvec2<T> const & x
 )
 {
  return typename detail::tvec2<T>::bool_type(
   isinf(x.x),
   isinf(x.y));
 }

 template <typename T> inline
                    typename detail::tvec3<T>::bool_type isinf
 (
  detail::tvec3<T> const & x
 )
 {
  return typename detail::tvec3<T>::bool_type(
   isinf(x.x),
   isinf(x.y),
   isinf(x.z));
 }

 template <typename T> inline
                    typename detail::tvec4<T>::bool_type isinf
 (
  detail::tvec4<T> const & x
 )
 {
  return typename detail::tvec4<T>::bool_type(
   isinf(x.x),
   isinf(x.y),
   isinf(x.z),
   isinf(x.w));
 } inline

                    int floatBitsToInt(float const & value)
 {
  union
  {
   float f;
   int i;
  } fi;

  fi.f = value;
  return fi.i;
 } inline

                    detail::tvec2<int> floatBitsToInt
 (
  detail::tvec2<float> const & value
 )
 {
  return detail::tvec2<int>(
   floatBitsToInt(value.x),
   floatBitsToInt(value.y));
 } inline

                    detail::tvec3<int> floatBitsToInt
 (
  detail::tvec3<float> const & value
 )
 {
  return detail::tvec3<int>(
   floatBitsToInt(value.x),
   floatBitsToInt(value.y),
   floatBitsToInt(value.z));
 } inline

                    detail::tvec4<int> floatBitsToInt
 (
  detail::tvec4<float> const & value
 )
 {
  return detail::tvec4<int>(
   floatBitsToInt(value.x),
   floatBitsToInt(value.y),
   floatBitsToInt(value.z),
   floatBitsToInt(value.w));
 } inline

                    uint floatBitsToUint(float const & value)
 {
  union
  {
   float f;
   uint u;
  } fu;

  fu.f = value;
  return fu.u;
 } inline

                    detail::tvec2<uint> floatBitsToUint
 (
  detail::tvec2<float> const & value
 )
 {
  return detail::tvec2<uint>(
   floatBitsToUint(value.x),
   floatBitsToUint(value.y));
 } inline

                    detail::tvec3<uint> floatBitsToUint
 (
  detail::tvec3<float> const & value
 )
 {
  return detail::tvec3<uint>(
   floatBitsToUint(value.x),
   floatBitsToUint(value.y),
   floatBitsToUint(value.z));
 } inline

                    detail::tvec4<uint> floatBitsToUint
 (
  detail::tvec4<float> const & value
 )
 {
  return detail::tvec4<uint>(
   floatBitsToUint(value.x),
   floatBitsToUint(value.y),
   floatBitsToUint(value.z),
   floatBitsToUint(value.w));
 } inline

                    float intBitsToFloat(int const & value)
 {
  union
  {
   float f;
   int i;
  } fi;

  fi.i = value;
  return fi.f;
 } inline

                    detail::tvec2<float> intBitsToFloat

 (
  detail::tvec2<int> const & value
 )
 {
  return detail::tvec2<float>(
   intBitsToFloat(value.x),
   intBitsToFloat(value.y));
 } inline

                    detail::tvec3<float> intBitsToFloat
 (
  detail::tvec3<int> const & value
 )
 {
  return detail::tvec3<float>(
   intBitsToFloat(value.x),
   intBitsToFloat(value.y),
   intBitsToFloat(value.z));
 } inline

                    detail::tvec4<float> intBitsToFloat
 (
  detail::tvec4<int> const & value
 )
 {
  return detail::tvec4<float>(
   intBitsToFloat(value.x),
   intBitsToFloat(value.y),
   intBitsToFloat(value.z),
   intBitsToFloat(value.w));
 } inline

                    float uintBitsToFloat(uint const & value)
 {
  union
  {
   float f;
   uint u;
  } fu;

  fu.u = value;
  return fu.f;
 } inline

                    detail::tvec2<float> uintBitsToFloat
 (
  detail::tvec2<uint> const & value
 )
 {
  return detail::tvec2<float>(
   uintBitsToFloat(value.x),
   uintBitsToFloat(value.y));
 } inline

                    detail::tvec3<float> uintBitsToFloat
 (
  detail::tvec3<uint> const & value
 )
 {
  return detail::tvec3<float>(
   uintBitsToFloat(value.x),
   uintBitsToFloat(value.y),
   uintBitsToFloat(value.z));
 } inline

                    detail::tvec4<float> uintBitsToFloat
 (
  detail::tvec4<uint> const & value
 )
 {
  return detail::tvec4<float>(
   uintBitsToFloat(value.x),
   uintBitsToFloat(value.y),
   uintBitsToFloat(value.z),
   uintBitsToFloat(value.w));
 }

 template <typename genType> inline
                    genType fma
 (
  genType const & a,
  genType const & b,
  genType const & c
 )
 {
  return a * b + c;
 }

 template <typename genType> inline
                    genType frexp
 (
  genType const & x,
  int & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T> inline
                    detail::tvec2<T> frexp
 (
  detail::tvec2<T> const & x,
  detail::tvec2<int> & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T> inline
                    detail::tvec3<T> frexp
 (
  detail::tvec3<T> const & x,
  detail::tvec3<int> & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T> inline
                    detail::tvec4<T> frexp
 (
  detail::tvec4<T> const & x,
  detail::tvec4<int> & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename genType> inline
                    genType ldexp
 (
  genType const & x,
  int const & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T> inline
                    detail::tvec2<T> ldexp
 (
  detail::tvec2<T> const & x,
  detail::tvec2<int> const & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T> inline
                    detail::tvec3<T> ldexp
 (
  detail::tvec3<T> const & x,
  detail::tvec3<int> const & exp
 )
 {
  return std::frexp(x, exp);
 }

 template <typename T> inline
                    detail::tvec4<T> ldexp
 (
  detail::tvec4<T> const & x,
  detail::tvec4<int> const & exp
 )
 {
  return std::frexp(x, exp);
 }

}
# 428 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_common.hpp" 2
# 102 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp" 1
# 39 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
namespace glm
{
# 55 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::uint32 packUnorm2x16(detail::tvec2<detail::float32> const & v);
# 68 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::uint32 packSnorm2x16(detail::tvec2<detail::float32> const & v);
# 81 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::uint32 packUnorm4x8(detail::tvec4<detail::float32> const & v);
# 94 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::uint32 packSnorm4x8(detail::tvec4<detail::float32> const & v);
# 107 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::tvec2<detail::float32> unpackUnorm2x16(detail::uint32 const & p);
# 120 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::tvec2<detail::float32> unpackSnorm2x16(detail::uint32 const & p);
# 133 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::tvec4<detail::float32> unpackUnorm4x8(detail::uint32 const & p);
# 146 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::tvec4<detail::float32> unpackSnorm4x8(detail::uint32 const & p);
# 156 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 double packDouble2x32(detail::tvec2<detail::uint32> const & v);
# 165 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 detail::tvec2<detail::uint32> unpackDouble2x32(double const & v);
# 175 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 uint packHalf2x16(vec2 const & v);
# 185 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp"
 vec2 unpackHalf2x16(uint const & v);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_packing.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_packing.inl"
namespace glm
{ inline
                    detail::uint32 packUnorm2x16(detail::tvec2<detail::float32> const & v)
 {
  detail::uint16 A(detail::uint16(round(clamp(v.x, 0.0f, 1.0f) * 65535.0f)));
  detail::uint16 B(detail::uint16(round(clamp(v.y, 0.0f, 1.0f) * 65535.0f)));
  return detail::uint32((B << 16) | A);
 } inline

                    detail::tvec2<detail::float32> unpackUnorm2x16(detail::uint32 const & p)
 {
  detail::uint32 Mask16((1 << 16) - 1);
  detail::uint32 A((p >> 0) & Mask16);
  detail::uint32 B((p >> 16) & Mask16);
  return detail::tvec2<detail::float32>(
   A * 1.0f / 65535.0f,
   B * 1.0f / 65535.0f);
 } inline

                    detail::uint32 packSnorm2x16(detail::tvec2<detail::float32> const & v)
 {
  union iu
  {
   detail::int16 i;
   detail::uint16 u;
  } A, B;

  detail::tvec2<detail::float32> Unpack = clamp(v ,-1.0f, 1.0f) * 32767.0f;
  A.i = detail::int16(round(Unpack.x));
  B.i = detail::int16(round(Unpack.y));
  detail::uint32 Pack = (detail::uint32(B.u) << 16) | (detail::uint32(A.u) << 0);
  return Pack;
 } inline

                    detail::tvec2<detail::float32> unpackSnorm2x16(detail::uint32 const & p)
 {
  union iu
  {
   detail::int16 i;
   detail::uint16 u;
  } A, B;

  detail::uint32 Mask16((1 << 16) - 1);
  A.u = detail::uint16((p >> 0) & Mask16);
  B.u = detail::uint16((p >> 16) & Mask16);
  detail::tvec2<detail::float32> Pack(A.i, B.i);

  return clamp(Pack * 1.0f / 32767.0f, -1.0f, 1.0f);
 } inline

                    detail::uint32 packUnorm4x8(detail::tvec4<detail::float32> const & v)
 {
  detail::uint8 A((detail::uint8)round(clamp(v.x, 0.0f, 1.0f) * 255.0f));
  detail::uint8 B((detail::uint8)round(clamp(v.y, 0.0f, 1.0f) * 255.0f));
  detail::uint8 C((detail::uint8)round(clamp(v.z, 0.0f, 1.0f) * 255.0f));
  detail::uint8 D((detail::uint8)round(clamp(v.w, 0.0f, 1.0f) * 255.0f));
  return detail::uint32((D << 24) | (C << 16) | (B << 8) | A);
 } inline

                    detail::tvec4<detail::float32> unpackUnorm4x8(detail::uint32 const & p)
 {
  detail::uint32 Mask8((1 << 8) - 1);
  detail::uint32 A((p >> 0) & Mask8);
  detail::uint32 B((p >> 8) & Mask8);
  detail::uint32 C((p >> 16) & Mask8);
  detail::uint32 D((p >> 24) & Mask8);
  return detail::tvec4<detail::float32>(
   A * 1.0f / 255.0f,
   B * 1.0f / 255.0f,
   C * 1.0f / 255.0f,
   D * 1.0f / 255.0f);
 } inline

                    detail::uint32 packSnorm4x8(detail::tvec4<detail::float32> const & v)
 {
  union iu
  {
   detail::int8 i;
   detail::uint8 u;
  } A, B, C, D;

  detail::tvec4<detail::float32> Unpack = clamp(v ,-1.0f, 1.0f) * 127.0f;
  A.i = detail::int8(round(Unpack.x));
  B.i = detail::int8(round(Unpack.y));
  C.i = detail::int8(round(Unpack.z));
  D.i = detail::int8(round(Unpack.w));
  detail::uint32 Pack = (detail::uint32(D.u) << 24) | (detail::uint32(C.u) << 16) | (detail::uint32(B.u) << 8) | (detail::uint32(A.u) << 0);
  return Pack;
 } inline

                    detail::tvec4<detail::float32> unpackSnorm4x8(detail::uint32 const & p)
 {
  union iu
  {
   detail::int8 i;
   detail::uint8 u;
  } A, B, C, D;

  detail::uint32 Mask8((1 << 8) - 1);
  A.u = detail::uint8((p >> 0) & Mask8);
  B.u = detail::uint8((p >> 8) & Mask8);
  C.u = detail::uint8((p >> 16) & Mask8);
  D.u = detail::uint8((p >> 24) & Mask8);
  detail::tvec4<detail::float32> Pack(A.i, B.i, C.i, D.i);

  return clamp(Pack * 1.0f / 127.0f, -1.0f, 1.0f);
 } inline

                    double packDouble2x32(detail::tvec2<detail::uint32> const & v)
 {
  return *(double*)&v;
 } inline

                    detail::tvec2<uint> unpackDouble2x32(double const & v)
 {
  return *(detail::tvec2<uint>*)&v;
 } inline

                    uint packHalf2x16(detail::tvec2<float> const & v)
 {
  union helper
  {
   uint other;
   struct
   {
    detail::hdata a, b;
   } orig;
  } Pack;

  Pack.orig.a = detail::toFloat16(v.x);
  Pack.orig.b = detail::toFloat16(v.y);
  return *(uint*)&Pack;
 } inline

                    vec2 unpackHalf2x16(uint const & v)
 {
  union helper
  {
   uint other;
   struct
   {
    detail::hdata a, b;
   } orig;
  } Unpack;
  Unpack.other = v;

  return vec2(detail::toFloat32(Unpack.orig.a), detail::toFloat32(Unpack.orig.b));
 }
}
# 190 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_packing.hpp" 2
# 103 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_geometric.hpp" 1
# 39 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_geometric.hpp"
namespace glm
{
# 50 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_geometric.hpp"
 template <typename genType>
  typename genType::value_type length(
  genType const & x);







 template <typename genType>
 typename genType::value_type distance(
  genType const & p0,
  genType const & p1);







 template <typename genType>
 typename genType::value_type dot(
  genType const & x,
  genType const & y);







 template <typename valType>
 detail::tvec3<valType> cross(
  detail::tvec3<valType> const & x,
  detail::tvec3<valType> const & y);





 template <typename genType>
 genType normalize(
  genType const & x);







 template <typename genType>
 genType faceforward(
  genType const & N,
  genType const & I,
  genType const & Nref);
# 114 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_geometric.hpp"
 template <typename genType>
 genType reflect(
  genType const & I,
  genType const & N);
# 127 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_geometric.hpp"
 template <typename genType>
 genType refract(
  genType const & I,
  genType const & N,
  typename genType::value_type const & eta);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_geometric.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_geometric.inl"
namespace glm
{

 template <typename genType> inline
                    genType length
 (
  genType const & x
 )
 {
                                                                                                  ;

  genType sqr = x * x;
  return sqrt(sqr);
 }

 template <typename T> inline
                    typename detail::tvec2<T>::value_type length
 (
  detail::tvec2<T> const & v
 )
 {
                                                                                            ;

  typename detail::tvec2<T>::value_type sqr = v.x * v.x + v.y * v.y;
  return sqrt(sqr);
 }

 template <typename T> inline
                    typename detail::tvec3<T>::value_type length
 (
  detail::tvec3<T> const & v
 )
 {
                                                                                            ;

  typename detail::tvec3<T>::value_type sqr = v.x * v.x + v.y * v.y + v.z * v.z;
  return sqrt(sqr);
 }

 template <typename T> inline
                    typename detail::tvec4<T>::value_type length
 (
  detail::tvec4<T> const & v
 )
 {
                                                                                            ;

  typename detail::tvec4<T>::value_type sqr = v.x * v.x + v.y * v.y + v.z * v.z + v.w * v.w;
  return sqrt(sqr);
 }


 template <typename genType> inline
                    genType distance
 (
  genType const & p0,
  genType const & p1
 )
 {
                                                                                                    ;

  return length(p1 - p0);
 }

 template <typename T> inline
                    typename detail::tvec2<T>::value_type distance
 (
  detail::tvec2<T> const & p0,
  detail::tvec2<T> const & p1
 )
 {
                                                                                              ;

  return length(p1 - p0);
 }

 template <typename T> inline
                    typename detail::tvec3<T>::value_type distance
 (
  detail::tvec3<T> const & p0,
  detail::tvec3<T> const & p1
 )
 {
                                                                                              ;

  return length(p1 - p0);
 }

 template <typename T> inline
                    typename detail::tvec4<T>::value_type distance
 (
  detail::tvec4<T> const & p0,
  detail::tvec4<T> const & p1
 )
 {
                                                                                              ;

  return length(p1 - p0);
 }


 template <typename genType> inline
                    genType dot
 (
  genType const & x,
  genType const & y

 )
 {
                                                                                               ;

  return x * y;
 }

 template <typename T> inline
                    typename detail::tvec2<T>::value_type dot
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y
 )
 {
                                                                                         ;

  return x.x * y.x + x.y * y.y;
 }

 template <typename T> inline
                    T dot
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y
 )
 {
                                                                                         ;

  return x.x * y.x + x.y * y.y + x.z * y.z;
 }
# 183 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_geometric.inl"
 template <typename T> inline
                    T dot
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y
 )
 {
                                                                                         ;

  return x.x * y.x + x.y * y.y + x.z * y.z + x.w * y.w;
 }


 template <typename T> inline
                    detail::tvec3<T> cross
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y
 )
 {
                                                                                           ;

  return detail::tvec3<T>(
   x.y * y.z - y.y * x.z,
   x.z * y.x - y.z * x.x,
   x.x * y.y - y.x * x.y);
 }


 template <typename genType> inline
                    genType normalize
 (
  genType const & x
 )
 {
                                                                                                     ;

  return x < genType(0) ? genType(-1) : genType(1);
 }


 template <typename T> inline
                    detail::tvec2<T> normalize
 (
  detail::tvec2<T> const & x
 )
 {
                                                                                               ;

  typename detail::tvec2<T>::value_type sqr = x.x * x.x + x.y * x.y;
  return x * inversesqrt(sqr);
 }

 template <typename T> inline
                    detail::tvec3<T> normalize
 (
  detail::tvec3<T> const & x
 )
 {
                                                                                               ;

  typename detail::tvec3<T>::value_type sqr = x.x * x.x + x.y * x.y + x.z * x.z;
  return x * inversesqrt(sqr);
 }

 template <typename T> inline
                    detail::tvec4<T> normalize
 (
  detail::tvec4<T> const & x
 )
 {
                                                                                               ;

  typename detail::tvec4<T>::value_type sqr = x.x * x.x + x.y * x.y + x.z * x.z + x.w * x.w;
  return x * inversesqrt(sqr);
 }


 template <typename genType> inline
                    genType faceforward
 (
  genType const & N,
  genType const & I,
  genType const & Nref
 )
 {
  return dot(Nref, I) < 0 ? N : -N;
 }


 template <typename genType>
 genType reflect
 (
  genType const & I,
  genType const & N
 )
 {
  return I - N * dot(N, I) * genType(2);
 }


 template <typename genType> inline
                    genType refract
 (
  genType const & I,
  genType const & N,
  genType const & eta
 )
 {



  genType dotValue = dot(N, I);
  genType k = genType(1) - eta * eta * (genType(1) - dotValue * dotValue);
  if(k < genType(0))
   return genType(0);
  else
   return eta * I - (eta * dotValue + sqrt(k)) * N;
 }

 template <typename genType> inline
                    genType refract
 (
  genType const & I,
  genType const & N,
  typename genType::value_type const & eta
 )
 {



  typename genType::value_type dotValue = dot(N, I);
  typename genType::value_type k = typename genType::value_type(1) - eta * eta * (typename genType::value_type(1) - dotValue * dotValue);
  if(k < typename genType::value_type(0))
   return genType(0);
  else
   return eta * I - (eta * dotValue + sqrt(k)) * N;
 }

}
# 136 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_geometric.hpp" 2
# 104 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_matrix.hpp" 1
# 43 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_matrix.hpp"
namespace glm
{
# 55 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_matrix.hpp"
 template <typename matType>
 matType matrixCompMult(
  matType const & x,
  matType const & y);
# 70 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_matrix.hpp"
 template <typename vecType, typename matType>
 matType outerProduct(
  vecType const & c,
  vecType const & r);







 template <typename matType>
 typename matType::transpose_type transpose(
  matType const & x);







 template <typename valType>
 typename detail::tmat2x2<valType>::value_type determinant(
  detail::tmat2x2<valType> const & m);







 template <typename valType>
 typename detail::tmat3x3<valType>::value_type determinant(
  detail::tmat3x3<valType> const & m);







 template <typename valType>
 typename detail::tmat4x4<valType>::value_type determinant(
  detail::tmat4x4<valType> const & m);







 template <typename valType>
 detail::tmat2x2<valType> inverse(
  detail::tmat2x2<valType> const & m);







 template <typename valType>
 detail::tmat3x3<valType> inverse(
  detail::tmat3x3<valType> const & m);







 template <typename valType>
 detail::tmat4x4<valType> inverse(
  detail::tmat4x4<valType> const & m);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_matrix.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_matrix.inl"
namespace glm
{

 template <typename matType> inline
                    matType matrixCompMult
 (
  matType const & x,
  matType const & y
 )
 {
                                                                                                                               ;

  matType result(matType::null);
  for(typename matType::size_type i = 0; i < matType::row_size(); ++i)
   result[i] = x[i] * y[i];
  return result;
 }


 template <typename T> inline
                    detail::tmat2x2<T> outerProduct
 (
  detail::tvec2<T> const & c,
  detail::tvec2<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat2x2<T> m(detail::tmat2x2<T>::null);
  m[0][0] = c[0] * r[0];
  m[0][1] = c[1] * r[0];
  m[1][0] = c[0] * r[1];
  m[1][1] = c[1] * r[1];
  return m;
 }

 template <typename T> inline
                    detail::tmat3x3<T> outerProduct
 (
  detail::tvec3<T> const & c,
  detail::tvec3<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat3x3<T> m(detail::tmat3x3<T>::null);
  for(typename detail::tmat3x3<T>::size_type i(0); i < m.length(); ++i)
   m[i] = c * r[i];
  return m;
 }

 template <typename T> inline
                    detail::tmat4x4<T> outerProduct
 (
  detail::tvec4<T> const & c,
  detail::tvec4<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat4x4<T> m(detail::tmat4x4<T>::null);
  for(typename detail::tmat4x4<T>::size_type i(0); i < m.length(); ++i)
   m[i] = c * r[i];
  return m;
 }

 template <typename T> inline
                    detail::tmat2x3<T> outerProduct
 (
  detail::tvec3<T> const & c,
  detail::tvec2<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat2x3<T> m(detail::tmat2x3<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  return m;
 }

 template <typename T> inline
                    detail::tmat3x2<T> outerProduct
 (
  detail::tvec2<T> const & c,
  detail::tvec3<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat3x2<T> m(detail::tmat3x2<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  return m;
 }

 template <typename T> inline
                    detail::tmat2x4<T> outerProduct
 (
  detail::tvec4<T> const & c,
  detail::tvec2<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat2x4<T> m(detail::tmat2x4<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[0][3] = c.w * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  m[1][3] = c.w * r.y;
  return m;
 }

 template <typename T> inline
                    detail::tmat4x2<T> outerProduct
 (
  detail::tvec2<T> const & c,
  detail::tvec4<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat4x2<T> m(detail::tmat4x2<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  m[3][0] = c.x * r.w;
  m[3][1] = c.y * r.w;
  return m;
 }

 template <typename T> inline
                    detail::tmat3x4<T> outerProduct
 (
  detail::tvec4<T> const & c,
  detail::tvec3<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat3x4<T> m(detail::tmat3x4<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[0][3] = c.w * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  m[1][3] = c.w * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  m[2][2] = c.z * r.z;
  m[2][3] = c.w * r.z;
  return m;
 }

 template <typename T> inline
                    detail::tmat4x3<T> outerProduct
 (
  detail::tvec3<T> const & c,
  detail::tvec4<T> const & r
 )
 {
                                                                                                  ;

  detail::tmat4x3<T> m(detail::tmat4x3<T>::null);
  m[0][0] = c.x * r.x;
  m[0][1] = c.y * r.x;
  m[0][2] = c.z * r.x;
  m[1][0] = c.x * r.y;
  m[1][1] = c.y * r.y;
  m[1][2] = c.z * r.y;
  m[2][0] = c.x * r.z;
  m[2][1] = c.y * r.z;
  m[2][2] = c.z * r.z;
  m[3][0] = c.x * r.w;
  m[3][1] = c.y * r.w;
  m[3][2] = c.z * r.w;
  return m;
 }

 template <typename T> inline
                    detail::tmat2x2<T> transpose
 (
  detail::tmat2x2<T> const & m
 )
 {
                                                                                               ;

  detail::tmat2x2<T> result(detail::tmat2x2<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  return result;
 }

 template <typename T> inline
                    detail::tmat3x3<T> transpose
 (
  detail::tmat3x3<T> const & m
 )
 {
                                                                                               ;

  detail::tmat3x3<T> result(detail::tmat3x3<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];

  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];

  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  return result;
 }

 template <typename T> inline
                    detail::tmat4x4<T> transpose
 (
  detail::tmat4x4<T> const & m
 )
 {
                                                                                               ;

  detail::tmat4x4<T> result(detail::tmat4x4<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[0][3] = m[3][0];

  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[1][3] = m[3][1];

  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  result[2][3] = m[3][2];

  result[3][0] = m[0][3];
  result[3][1] = m[1][3];
  result[3][2] = m[2][3];
  result[3][3] = m[3][3];
  return result;
 }

 template <typename T> inline
                    detail::tmat2x3<T> transpose
 (
  detail::tmat3x2<T> const & m
 )
 {
                                                                                               ;

  detail::tmat2x3<T> result(detail::tmat2x3<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  return result;
 }

 template <typename T> inline
                    detail::tmat3x2<T> transpose
 (
  detail::tmat2x3<T> const & m
 )
 {
                                                                                               ;

  detail::tmat3x2<T> result(detail::tmat3x2<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  return result;
 }

 template <typename T> inline
                    detail::tmat2x4<T> transpose
 (
  detail::tmat4x2<T> const & m
 )
 {
                                                                                               ;

  detail::tmat2x4<T> result(detail::tmat2x4<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[0][3] = m[3][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[1][3] = m[3][1];
  return result;
 }

 template <typename T> inline
                    detail::tmat4x2<T> transpose
 (
  detail::tmat2x4<T> const & m
 )
 {
                                                                                               ;

  detail::tmat4x2<T> result(detail::tmat4x2<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[3][0] = m[0][3];
  result[3][1] = m[1][3];
  return result;
 }

 template <typename T> inline
                    detail::tmat3x4<T> transpose
 (
  detail::tmat4x3<T> const & m
 )
 {
                                                                                               ;

  detail::tmat3x4<T> result(detail::tmat3x4<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[0][3] = m[3][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[1][3] = m[3][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  result[2][3] = m[3][2];
  return result;
 }

 template <typename T> inline
                    detail::tmat4x3<T> transpose
 (
  detail::tmat3x4<T> const & m
 )
 {
                                                                                               ;

  detail::tmat4x3<T> result(detail::tmat4x3<T>::null);
  result[0][0] = m[0][0];
  result[0][1] = m[1][0];
  result[0][2] = m[2][0];
  result[1][0] = m[0][1];
  result[1][1] = m[1][1];
  result[1][2] = m[2][1];
  result[2][0] = m[0][2];
  result[2][1] = m[1][2];
  result[2][2] = m[2][2];
  result[3][0] = m[0][3];
  result[3][1] = m[1][3];
  result[3][2] = m[2][3];
  return result;
 }

 template <typename T> inline
                    typename detail::tmat2x2<T>::value_type determinant
 (
  detail::tmat2x2<T> const & m
 )
 {
                                                                                                 ;

  return m[0][0] * m[1][1] - m[1][0] * m[0][1];
 }

 template <typename T> inline
                    typename detail::tmat3x3<T>::value_type determinant
 (
  detail::tmat3x3<T> const & m
 )
 {
                                                                                                 ;

  return
   + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
   - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
   + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
 }

 template <typename T> inline
                    typename detail::tmat4x4<T>::value_type determinant
 (
  detail::tmat4x4<T> const & m
 )
 {
                                                                                                 ;

  T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

  detail::tvec4<T> DetCof(
   + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
   - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
   + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
   - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

  return m[0][0] * DetCof[0]
    + m[0][1] * DetCof[1]
    + m[0][2] * DetCof[2]
    + m[0][3] * DetCof[3];
 }

 template <typename T> inline
                    detail::tmat2x2<T> inverse
 (
  detail::tmat2x2<T> const & m
 )
 {
                                                                                             ;


  T Determinant = determinant(m);

  detail::tmat2x2<T> Inverse(
   + m[1][1] / Determinant,
   - m[0][1] / Determinant,
   - m[1][0] / Determinant,
   + m[0][0] / Determinant);

  return Inverse;
 }

 template <typename T> inline
                    detail::tmat3x3<T> inverse
 (
  detail::tmat3x3<T> const & m
 )
 {
                                                                                             ;





  T Determinant = determinant(m);

  detail::tmat3x3<T> Inverse(detail::tmat3x3<T>::null);
  Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
  Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
  Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
  Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
  Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
  Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
  Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
  Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
  Inverse /= Determinant;

  return Inverse;
 }

 template <typename T> inline
                    detail::tmat4x4<T> inverse
 (
  detail::tmat4x4<T> const & m
 )
 {
                                                                                             ;

  T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

  T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

  T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

  T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

  T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

  T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  detail::tvec4<T> const SignA(+1, -1, +1, -1);
  detail::tvec4<T> const SignB(-1, +1, -1, +1);

  detail::tvec4<T> Fac0(Coef00, Coef00, Coef02, Coef03);
  detail::tvec4<T> Fac1(Coef04, Coef04, Coef06, Coef07);
  detail::tvec4<T> Fac2(Coef08, Coef08, Coef10, Coef11);
  detail::tvec4<T> Fac3(Coef12, Coef12, Coef14, Coef15);
  detail::tvec4<T> Fac4(Coef16, Coef16, Coef18, Coef19);
  detail::tvec4<T> Fac5(Coef20, Coef20, Coef22, Coef23);

  detail::tvec4<T> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
  detail::tvec4<T> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
  detail::tvec4<T> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
  detail::tvec4<T> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

  detail::tvec4<T> Inv0 = SignA * (Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
  detail::tvec4<T> Inv1 = SignB * (Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
  detail::tvec4<T> Inv2 = SignA * (Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
  detail::tvec4<T> Inv3 = SignB * (Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

  detail::tmat4x4<T> Inverse(Inv0, Inv1, Inv2, Inv3);

  detail::tvec4<T> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

  T Determinant = glm::dot(m[0], Row0);

  Inverse /= Determinant;

  return Inverse;
 }
}
# 148 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_matrix.hpp" 2
# 105 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_vector_relational.hpp" 1
# 46 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_vector_relational.hpp"
namespace glm
{
# 57 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_vector_relational.hpp"
 template <typename vecType>
 typename vecType::bool_type lessThan(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type lessThanEqual(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type greaterThan(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type greaterThanEqual(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type equal(vecType const & x, vecType const & y);







 template <typename vecType>
 typename vecType::bool_type notEqual(vecType const & x, vecType const & y);







 template <template <typename> class vecType>
 bool any(vecType<bool> const & v);







 template <template <typename> class vecType>
 bool all(vecType<bool> const & v);
# 130 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_vector_relational.hpp"
 template <template <typename> class vecType>
 vecType<bool> not_(vecType<bool> const & v);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl"
namespace glm
{
 template <typename T, template <typename> class vecType> inline
                    typename vecType<T>::bool_type lessThan
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {

                                                                             ;

                                                                                                                           ;
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl", 42, "x.length() == y.length()") : (void)0);

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] < y[i];

  return Result;
 }

 template <typename T, template <typename> class vecType> inline
                    typename vecType<T>::bool_type lessThanEqual
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {

                                                                                  ;

                                                                                                                                ;
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl", 62, "x.length() == y.length()") : (void)0);

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType> inline
                    typename vecType<T>::bool_type greaterThan
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {

                                                                                ;

                                                                                                                              ;
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl", 81, "x.length() == y.length()") : (void)0);

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType> inline
                    typename vecType<T>::bool_type greaterThanEqual
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {

                                                                                     ;

                                                                                                                                   ;
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl", 100, "x.length() == y.length()") : (void)0);

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType> inline
                    typename vecType<T>::bool_type equal
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {

                                                                          ;
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl", 117, "x.length() == y.length()") : (void)0);

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, template <typename> class vecType> inline
                    typename vecType<T>::bool_type notEqual
 (
  vecType<T> const & x,
  vecType<T> const & y
 )
 {

                                                                             ;
  (__builtin_expect(!(x.length() == y.length()), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_vector_relational.inl", 134, "x.length() == y.length()") : (void)0);

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < x.length(); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <template <typename> class vecType> inline
                    bool any(vecType<bool> const & v)
 {

                                                                                ;

  bool Result = false;
  for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
   Result = Result || v[i];
  return Result;
 }

 template <template <typename> class vecType> inline
                    bool all(vecType<bool> const & v)
 {

                                                                                ;

  bool Result = true;
  for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
   Result = Result && v[i];
  return Result;
 }

 template <template <typename> class vecType> inline
                    vecType<bool> not_(vecType<bool> const & v)
 {

                                                                         ;

  typename vecType<bool>::bool_type Result(vecType<bool>::null);
  for(typename vecType<bool>::size_type i = 0; i < v.length(); ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 136 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_vector_relational.hpp" 2
# 106 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp" 1
# 41 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
namespace glm
{
# 54 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename genUType>
 genUType uaddCarry(
  genUType const & x,
  genUType const & y,
  genUType & carry);
# 68 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename genUType>
 genUType usubBorrow(
  genUType const & x,
  genUType const & y,
  genUType & borrow);
# 82 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename genUType>
 void umulExtended(
  genUType const & x,
  genUType const & y,
  genUType & msb,
  genUType & lsb);
# 97 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename genIType>
 void imulExtended(
  genIType const & x,
  genIType const & y,
  genIType & msb,
  genIType & lsb);
# 119 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename genIUType>
 genIUType bitfieldExtract(
  genIUType const & Value,
  int const & Offset,
  int const & Bits);
# 139 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename genIUType>
 genIUType bitfieldInsert(
  genIUType const & Base,
  genIUType const & Insert,
  int const & Offset,
  int const & Bits);
# 154 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename genIUType>
 genIUType bitfieldReverse(genIUType const & Value);
# 165 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type bitCount(genIUType<T> const & Value);
# 178 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type findLSB(genIUType<T> const & Value);
# 192 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp"
 template <typename T, template <typename> class genIUType>
 typename genIUType<T>::signed_type findMSB(genIUType<T> const & Value);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_integer.inl" 1
# 34 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_integer.inl"
namespace glm
{

 template <typename genUType> inline
                    genUType uaddCarry
 (
  genUType const & x,
  genUType const & y,
  genUType & Carry
 )
 {
  detail::highp_uint_t Value64 = detail::highp_uint_t(x) + detail::highp_uint_t(y);
  genUType Result = genUType(Value64 % (detail::highp_uint_t(1) << detail::highp_uint_t(32)));
  Carry = (Value64 % (detail::highp_uint_t(1) << detail::highp_uint_t(32))) > 1 ? 1 : 0;
  return Result;
 }

 template <typename T> inline
                    detail::tvec2<T> uaddCarry
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & Carry
 )
 {
  return detail::tvec2<T>(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]));
 }

 template <typename T> inline
                    detail::tvec3<T> uaddCarry
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & Carry
 )
 {
  return detail::tvec3<T>(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]),
   uaddCarry(x[2], y[2], Carry[2]));
 }

 template <typename T> inline
                    detail::tvec4<T> uaddCarry
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & Carry
 )
 {
  return detail::tvec4<T>(
   uaddCarry(x[0], y[0], Carry[0]),
   uaddCarry(x[1], y[1], Carry[1]),
   uaddCarry(x[2], y[2], Carry[2]),
   uaddCarry(x[3], y[3], Carry[3]));
 }


 template <typename genUType> inline
                    genUType usubBorrow
 (
  genUType const & x,
  genUType const & y,
  genUType & Borrow
 )
 {
  Borrow = x >= y ? 0 : 1;
  if(x > y)
   return genUType(detail::highp_int_t(x) - detail::highp_int_t(y));
  else
   return genUType(detail::highp_int_t(1) << detail::highp_int_t(32) + detail::highp_int_t(x) - detail::highp_int_t(y));
 }

 template <typename T> inline
                    detail::tvec2<T> usubBorrow
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & Borrow
 )
 {
  return detail::tvec2<T>(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]));
 }

 template <typename T> inline
                    detail::tvec3<T> usubBorrow
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & Borrow
 )
 {
  return detail::tvec3<T>(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]),
   usubBorrow(x[2], y[2], Borrow[2]));
 }

 template <typename T> inline
                    detail::tvec4<T> usubBorrow
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & Borrow
 )
 {
  return detail::tvec4<T>(
   usubBorrow(x[0], y[0], Borrow[0]),
   usubBorrow(x[1], y[1], Borrow[1]),
   usubBorrow(x[2], y[2], Borrow[2]),
   usubBorrow(x[3], y[3], Borrow[3]));
 }


 template <typename genUType> inline
                    void umulExtended
 (
  genUType const & x,
  genUType const & y,
  genUType & msb,
  genUType & lsb
 )
 {
  detail::highp_uint_t ValueX64 = x;
  detail::highp_uint_t ValueY64 = y;
  detail::highp_uint_t Value64 = ValueX64 * ValueY64;
  msb = *(genUType*)&genUType(Value64 & ((detail::highp_uint_t(1) << detail::highp_uint_t(32)) - detail::highp_uint_t(1)));
  lsb = *(genUType*)&genUType(Value64 >> detail::highp_uint_t(32));
 }

 template <typename T> inline
                    detail::tvec2<T> umulExtended
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & msb,
  detail::tvec2<T> & lsb
 )
 {
  return detail::tvec2<T>(
   umulExtended(x[0], y[0], msb, lsb),
   umulExtended(x[1], y[1], msb, lsb));
 }

 template <typename T> inline
                    detail::tvec3<T> umulExtended
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & msb,
  detail::tvec3<T> & lsb
 )
 {
  return detail::tvec3<T>(
   umulExtended(x[0], y[0], msb, lsb),
   umulExtended(x[1], y[1], msb, lsb),
   umulExtended(x[2], y[2], msb, lsb));
 }

 template <typename T> inline
                    detail::tvec4<T> umulExtended
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & msb,
  detail::tvec4<T> & lsb
 )
 {
  return detail::tvec4<T>(
   umulExtended(x[0], y[0], msb, lsb),
   umulExtended(x[1], y[1], msb, lsb),
   umulExtended(x[2], y[2], msb, lsb),
   umulExtended(x[3], y[3], msb, lsb));
 }


 template <typename genIType> inline
                    void imulExtended
 (
  genIType const & x,
  genIType const & y,
  genIType & msb,
  genIType & lsb
 )
 {
  detail::highp_int_t ValueX64 = x;
  detail::highp_int_t ValueY64 = y;
  detail::highp_int_t Value64 = ValueX64 * ValueY64;
  msb = *(genIType*)&genIType(Value64 & ((detail::highp_uint_t(1) << detail::highp_uint_t(32)) - detail::highp_uint_t(1)));
  lsb = *(genIType*)&genIType(Value64 >> detail::highp_uint_t(32));
 }

 template <typename T> inline
                    detail::tvec2<T> imulExtended
 (
  detail::tvec2<T> const & x,
  detail::tvec2<T> const & y,
  detail::tvec2<T> & msb,
  detail::tvec2<T> & lsb
 )
 {
  return detail::tvec2<T>(
   imulExtended(x[0], y[0], msb, lsb),
   imulExtended(x[1], y[1], msb, lsb));
 }

 template <typename T> inline
                    detail::tvec3<T> imulExtended
 (
  detail::tvec3<T> const & x,
  detail::tvec3<T> const & y,
  detail::tvec3<T> & msb,
  detail::tvec3<T> & lsb
 )
 {
  return detail::tvec3<T>(
   imulExtended(x[0], y[0], msb, lsb),
   imulExtended(x[1], y[1], msb, lsb),
   imulExtended(x[2], y[2], msb, lsb));
 }

 template <typename T> inline
                    detail::tvec4<T> imulExtended
 (
  detail::tvec4<T> const & x,
  detail::tvec4<T> const & y,
  detail::tvec4<T> & msb,
  detail::tvec4<T> & lsb
 )
 {
  return detail::tvec4<T>(
   imulExtended(x[0], y[0], msb, lsb),
   imulExtended(x[1], y[1], msb, lsb),
   imulExtended(x[2], y[2], msb, lsb),
   imulExtended(x[3], y[3], msb, lsb));
 }


 template <typename genIUType> inline
                    genIUType bitfieldExtract
 (
  genIUType const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  int GenSize = int(sizeof(genIUType)) << int(3);

  (__builtin_expect(!(Offset + Bits <= GenSize), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_integer.inl", 286, "Offset + Bits <= GenSize") : (void)0);

  genIUType ShiftLeft = Bits ? Value << (GenSize - (Bits + Offset)) : genIUType(0);
  genIUType ShiftBack = ShiftLeft >> genIUType(GenSize - Bits);

  return ShiftBack;
 }

 template <typename T> inline
                    detail::tvec2<T> bitfieldExtract
 (
  detail::tvec2<T> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec2<T>(
   bitfieldExtract(Value[0], Offset, Bits),
   bitfieldExtract(Value[1], Offset, Bits));
 }

 template <typename T> inline
                    detail::tvec3<T> bitfieldExtract
 (
  detail::tvec3<T> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec3<T>(
   bitfieldExtract(Value[0], Offset, Bits),
   bitfieldExtract(Value[1], Offset, Bits),
   bitfieldExtract(Value[2], Offset, Bits));
 }

 template <typename T> inline
                    detail::tvec4<T> bitfieldExtract
 (
  detail::tvec4<T> const & Value,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec4<T>(
   bitfieldExtract(Value[0], Offset, Bits),
   bitfieldExtract(Value[1], Offset, Bits),
   bitfieldExtract(Value[2], Offset, Bits),
   bitfieldExtract(Value[3], Offset, Bits));
 }


 template <typename genIUType> inline
                    genIUType bitfieldInsert
 (
  genIUType const & Base,
  genIUType const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
                                                                                                              ;
  (__builtin_expect(!(Offset + Bits <= sizeof(genIUType)), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_integer.inl", 347, "Offset + Bits <= sizeof(genIUType)") : (void)0);

  if(Bits == 0)
   return Base;

  genIUType Mask = 0;
  for(int Bit = Offset; Bit < Offset + Bits; ++Bit)
   Mask |= (1 << Bit);

  return (Base & ~Mask) | (Insert & Mask);
 }

 template <typename T> inline
                    detail::tvec2<T> bitfieldInsert
 (
  detail::tvec2<T> const & Base,
  detail::tvec2<T> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec2<T>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits));
 }

 template <typename T> inline
                    detail::tvec3<T> bitfieldInsert
 (
  detail::tvec3<T> const & Base,
  detail::tvec3<T> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec3<T>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits),
   bitfieldInsert(Base[2], Insert[2], Offset, Bits));
 }

 template <typename T> inline
                    detail::tvec4<T> bitfieldInsert
 (
  detail::tvec4<T> const & Base,
  detail::tvec4<T> const & Insert,
  int const & Offset,
  int const & Bits
 )
 {
  return detail::tvec4<T>(
   bitfieldInsert(Base[0], Insert[0], Offset, Bits),
   bitfieldInsert(Base[1], Insert[1], Offset, Bits),
   bitfieldInsert(Base[2], Insert[2], Offset, Bits),
   bitfieldInsert(Base[3], Insert[3], Offset, Bits));
 }


 template <typename genIUType> inline
                    genIUType bitfieldReverse(genIUType const & Value)
 {
                                                                                                               ;

  genIUType Out = 0;
  std::size_t BitSize = sizeof(genIUType) * 8;
  for(std::size_t i = 0; i < BitSize; ++i)
   if(Value & (genIUType(1) << i))
    Out |= genIUType(1) << (BitSize - 1 - i);
  return Out;
 }

 template <typename T> inline detail::tvec2<T> bitfieldReverse( detail::tvec2<T> const & v) { return detail::tvec2<T>( bitfieldReverse(v.x), bitfieldReverse(v.y)); } template <typename T> inline detail::tvec3<T> bitfieldReverse( detail::tvec3<T> const & v) { return detail::tvec3<T>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z)); } template <typename T> inline detail::tvec4<T> bitfieldReverse( detail::tvec4<T> const & v) { return detail::tvec4<T>( bitfieldReverse(v.x), bitfieldReverse(v.y), bitfieldReverse(v.z), bitfieldReverse(v.w)); }


 template <typename genIUType> inline
                    int bitCount(genIUType const & Value)
 {
                                                                                                        ;

  int Count = 0;
  for(std::size_t i = 0; i < sizeof(genIUType) * std::size_t(8); ++i)
  {
   if(Value & (1 << i))
    ++Count;
  }
  return Count;
 }

 template <typename T> inline
                    detail::tvec2<int> bitCount
 (
  detail::tvec2<T> const & value
 )
 {
  return detail::tvec2<int>(
   bitCount(value[0]),
   bitCount(value[1]));
 }

 template <typename T> inline
                    detail::tvec3<int> bitCount
 (
  detail::tvec3<T> const & value
 )
 {
  return detail::tvec3<int>(
   bitCount(value[0]),
   bitCount(value[1]),
   bitCount(value[2]));
 }

 template <typename T> inline
                    detail::tvec4<int> bitCount
 (
  detail::tvec4<T> const & value
 )
 {
  return detail::tvec4<int>(
   bitCount(value[0]),
   bitCount(value[1]),
   bitCount(value[2]),
   bitCount(value[3]));
 }


 template <typename genIUType> inline
                    int findLSB
 (
  genIUType const & Value
 )
 {
                                                                                                       ;
  if(Value == 0)
   return -1;

  genIUType Bit;
  for(Bit = genIUType(0); !(Value & (1 << Bit)); ++Bit){}
  return Bit;
 }

 template <typename T> inline
                    detail::tvec2<int> findLSB
 (
  detail::tvec2<T> const & value
 )
 {
  return detail::tvec2<int>(
   findLSB(value[0]),
   findLSB(value[1]));
 }

 template <typename T> inline
                    detail::tvec3<int> findLSB
 (
  detail::tvec3<T> const & value
 )
 {
  return detail::tvec3<int>(
   findLSB(value[0]),
   findLSB(value[1]),
   findLSB(value[2]));
 }

 template <typename T> inline
                    detail::tvec4<int> findLSB
 (
  detail::tvec4<T> const & value
 )
 {
  return detail::tvec4<int>(
   findLSB(value[0]),
   findLSB(value[1]),
   findLSB(value[2]),
   findLSB(value[3]));
 }
# 583 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_integer.inl"
 template <typename genIUType> inline
                    int findMSB
 (
  genIUType const & Value
 )
 {
                                                                                                       ;

  if(Value == genIUType(0) || Value == genIUType(-1))
   return -1;
  else if(Value > 0)
  {
   genIUType Bit = genIUType(-1);
   for(genIUType tmp = Value; tmp > 0; tmp >>= 1, ++Bit){}
   return Bit;
  }
  else
  {
   int const BitCount(sizeof(genIUType) * 8);
   int MostSignificantBit(-1);
   for(int BitIndex(0); BitIndex < BitCount; ++BitIndex)
    MostSignificantBit = (Value & (1 << BitIndex)) ? MostSignificantBit : BitIndex;
   (__builtin_expect(!(MostSignificantBit >= 0), 0) ? __assert_rtn(__func__, "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_integer.inl", 605, "MostSignificantBit >= 0") : (void)0);
   return MostSignificantBit;
  }
 }


 template <typename T> inline
                    detail::tvec2<int> findMSB
 (
  detail::tvec2<T> const & value
 )
 {
  return detail::tvec2<int>(
   findMSB(value[0]),
   findMSB(value[1]));
 }

 template <typename T> inline
                    detail::tvec3<int> findMSB
 (
  detail::tvec3<T> const & value
 )
 {
  return detail::tvec3<int>(
   findMSB(value[0]),
   findMSB(value[1]),
   findMSB(value[2]));
 }

 template <typename T> inline
                    detail::tvec4<int> findMSB
 (
  detail::tvec4<T> const & value
 )
 {
  return detail::tvec4<int>(
   findMSB(value[0]),
   findMSB(value[1]),
   findMSB(value[2]),
   findMSB(value[3]));
 }
}
# 198 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_integer.hpp" 2
# 107 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2

# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_noise.hpp" 1
# 41 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_noise.hpp"
namespace glm
{
# 52 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_noise.hpp"
 template <typename genType>
 typename genType::value_type noise1(genType const & x);







 template <typename genType>
 detail::tvec2<typename genType::value_type> noise2(genType const & x);







 template <typename genType>
 detail::tvec3<typename genType::value_type> noise3(genType const & x);







 template <typename genType>
 detail::tvec4<typename genType::value_type> noise4(genType const & x);


}


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_noise.inl" 1
# 29 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/core/func_noise.inl"
namespace glm
{
 template <typename T> inline
                    T noise1(T const & x)
 {
  return noise1(glm::detail::tvec2<T>(x, T(0)));
 }

 template <typename T> inline
                    glm::detail::tvec2<T> noise2(T const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + T(0.0)),
   noise1(x + T(1.0)));
 }

 template <typename T> inline
                    glm::detail::tvec3<T> noise3(T const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - T(1.0)),
   noise1(x + T(0.0)),
   noise1(x + T(1.0)));
 }

 template <typename T> inline
                    glm::detail::tvec4<T> noise4(T const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - T(1.0)),
   noise1(x + T(0.0)),
   noise1(x + T(1.0)),
   noise1(x + T(2.0)));
 }

 template <typename T> inline
                    T noise1(glm::detail::tvec2<T> const & v)
 {
  detail::tvec4<T> const C = detail::tvec4<T>(
             T( 0.211324865405187),
             T( 0.366025403784439),
             T(-0.577350269189626),
             T( 0.024390243902439));


  detail::tvec2<T> i = floor(v + dot(v, detail::tvec2<T>(C[1])));
  detail::tvec2<T> x0 = v - i + dot(i, detail::tvec2<T>(C[0]));




  detail::tvec2<T> i1 = (x0.x > x0.y) ? detail::tvec2<T>(1, 0) : detail::tvec2<T>(0, 1);



  detail::tvec4<T> x12 = detail::tvec4<T>(x0.x, x0.y, x0.x, x0.y) + detail::tvec4<T>(C.x, C.x, C.z, C.z);
  x12 = detail::tvec4<T>(detail::tvec2<T>(x12) - i1, x12.z, x12.w);


  i = mod(i, T(289));
  detail::tvec3<T> p = permute(
          permute(i.y + detail::tvec3<T>(T(0), i1.y, T(1)))
          + i.x + detail::tvec3<T>(T(0), i1.x, T(1)));

  detail::tvec3<T> m = max(T(0.5) - detail::tvec3<T>(
                 dot(x0, x0),
                 dot(detail::tvec2<T>(x12.x, x12.y), detail::tvec2<T>(x12.x, x12.y)),
                 dot(detail::tvec2<T>(x12.z, x12.w), detail::tvec2<T>(x12.z, x12.w))), T(0));
  m = m * m ;
  m = m * m ;




  detail::tvec3<T> x = T(2) * fract(p * C.w) - T(1);
  detail::tvec3<T> h = abs(x) - T(0.5);
  detail::tvec3<T> ox = floor(x + T(0.5));
  detail::tvec3<T> a0 = x - ox;



  m *= T(1.79284291400159) - T(0.85373472095314) * (a0 * a0 + h * h);


  detail::tvec3<T> g;
  g.x = a0.x * x0.x + h.x * x0.y;

  g.y = a0.y * x12.x + h.y * x12.y;
  g.z = a0.z * x12.z + h.z * x12.w;
  return T(130) * dot(m, g);
 }

 template <typename T> inline
                    T noise1(detail::tvec3<T> const & v)
 {
  detail::tvec2<T> const C(1.0 / 6.0, 1.0 / 3.0);
  detail::tvec4<T> const D(0.0, 0.5, 1.0, 2.0);


  detail::tvec3<T> i(floor(v + dot(v, detail::tvec3<T>(C.y))));
  detail::tvec3<T> x0(v - i + dot(i, detail::tvec3<T>(C.x)));


  detail::tvec3<T> g(step(detail::tvec3<T>(x0.y, x0.z, x0.x), x0));
  detail::tvec3<T> l(T(1) - g);
  detail::tvec3<T> i1(min(g, detail::tvec3<T>(l.z, l.x, l.y)));
  detail::tvec3<T> i2(max(g, detail::tvec3<T>(l.z, l.x, l.y)));





  detail::tvec3<T> x1(x0 - i1 + C.x);
  detail::tvec3<T> x2(x0 - i2 + C.y);
  detail::tvec3<T> x3(x0 - D.y);


  i = mod289(i);
  detail::tvec4<T> p(permute(permute(permute(
               i.z + detail::tvec4<T>(T(0), i1.z, i2.z, T(1))) +
             i.y + detail::tvec4<T>(T(0), i1.y, i2.y, T(1))) +
           i.x + detail::tvec4<T>(T(0), i1.x, i2.x, T(1))));



  T n_ = T(0.142857142857);
  detail::tvec3<T> ns(n_ * detail::tvec3<T>(D.w, D.y, D.z) - detail::tvec3<T>(D.x, D.z, D.x));

  detail::tvec4<T> j(p - T(49) * floor(p * ns.z * ns.z));

  detail::tvec4<T> x_(floor(j * ns.z));
  detail::tvec4<T> y_(floor(j - T(7) * x_));

  detail::tvec4<T> x(x_ * ns.x + ns.y);
  detail::tvec4<T> y(y_ * ns.x + ns.y);
  detail::tvec4<T> h(T(1) - abs(x) - abs(y));

  detail::tvec4<T> b0(x.x, x.y, y.x, y.y);
  detail::tvec4<T> b1(x.z, x.w, y.z, y.w);



  detail::tvec4<T> s0(floor(b0) * T(2) + T(1));
  detail::tvec4<T> s1(floor(b1) * T(2) + T(1));
  detail::tvec4<T> sh(-step(h, detail::tvec4<T>(0.0)));

  detail::tvec4<T> a0 = detail::tvec4<T>(b0.x, b0.z, b0.y, b0.w) + detail::tvec4<T>(s0.x, s0.z, s0.y, s0.w) * detail::tvec4<T>(sh.x, sh.x, sh.y, sh.y);
  detail::tvec4<T> a1 = detail::tvec4<T>(b1.x, b1.z, b1.y, b1.w) + detail::tvec4<T>(s1.x, s1.z, s1.y, s1.w) * detail::tvec4<T>(sh.z, sh.z, sh.w, sh.w);

  detail::tvec3<T> p0(a0.x, a0.y, h.x);
  detail::tvec3<T> p1(a0.z, a0.w, h.y);
  detail::tvec3<T> p2(a1.x, a1.y, h.z);
  detail::tvec3<T> p3(a1.z, a1.w, h.w);


  detail::tvec4<T> norm = taylorInvSqrt(detail::tvec4<T>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;


  detail::tvec4<T> m = max(T(0.6) - detail::tvec4<T>(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), T(0));
  m = m * m;
  return T(42) * dot(m * m, detail::tvec4<T>(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));
 }

 template <typename T> inline
                    T noise1(detail::tvec4<T> const & v)
 {
  detail::tvec4<T> const C(
         0.138196601125011,
         0.276393202250021,
         0.414589803375032,
         -0.447213595499958);


  T const F4 = T(0.309016994374947451);


  detail::tvec4<T> i = floor(v + dot(v, vec4(F4)));
  detail::tvec4<T> x0 = v - i + dot(i, vec4(C.x));




  detail::tvec4<T> i0;
  detail::tvec3<T> isX = step(detail::tvec3<T>(x0.y, x0.z, x0.w), detail::tvec3<T>(x0.x));
  detail::tvec3<T> isYZ = step(detail::tvec3<T>(x0.z, x0.w, x0.w), detail::tvec3<T>(x0.y, x0.y, x0.z));



  i0 = detail::tvec4<T>(isX.x + isX.y + isX.z, T(1) - isX);

  i0.y += isYZ.x + isYZ.y;

  i0.z += T(1) - isYZ.x;
  i0.w += T(1) - isYZ.y;
  i0.z += isYZ.z;
  i0.w += T(1) - isYZ.z;


  detail::tvec4<T> i3 = clamp(i0, 0.0, 1.0);
  detail::tvec4<T> i2 = clamp(i0 - 1.0, 0.0, 1.0);
  detail::tvec4<T> i1 = clamp(i0 - 2.0, 0.0, 1.0);






  detail::tvec4<T> x1 = x0 - i1 + C.x;
  detail::tvec4<T> x2 = x0 - i2 + C.y;
  detail::tvec4<T> x3 = x0 - i3 + C.z;
  detail::tvec4<T> x4 = x0 + C.w;


  i = mod(i, T(289));
  T j0 = permute(permute(permute(permute(i.w) + i.z) + i.y) + i.x);
  detail::tvec4<T> j1 = permute(permute(permute(permute(
                 i.w + detail::tvec4<T>(i1.w, i2.w, i3.w, T(1)))
               + i.z + detail::tvec4<T>(i1.z, i2.z, i3.z, T(1)))
             + i.y + detail::tvec4<T>(i1.y, i2.y, i3.y, T(1)))
           + i.x + detail::tvec4<T>(i1.x, i2.x, i3.x, T(1)));



  detail::tvec4<T> ip = detail::tvec4<T>(T(1) / T(294), T(1) / T(49), T(1) / T(7), T(0));

  detail::tvec4<T> p0 = grad4(j0, ip);
  detail::tvec4<T> p1 = grad4(j1.x, ip);
  detail::tvec4<T> p2 = grad4(j1.y, ip);
  detail::tvec4<T> p3 = grad4(j1.z, ip);
  detail::tvec4<T> p4 = grad4(j1.w, ip);


  detail::tvec4<T> norm = taylorInvSqrt(detail::tvec4<T>(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;
  p4 *= taylorInvSqrt(dot(p4, p4));


  detail::tvec3<T> m0 = max(T(0.6) - detail::tvec3<T>(dot(x0, x0), dot(x1, x1), dot(x2, x2)), T(0));
  detail::tvec2<T> m1 = max(T(0.6) - detail::tvec2<T>(dot(x3, x3), dot(x4, x4) ), T(0));
  m0 = m0 * m0;
  m1 = m1 * m1;
  return T(49) *
  (dot(m0 * m0, detail::tvec3<T>(dot(p0, x0), dot(p1, x1), dot(p2, x2))) +
   dot(m1 * m1, detail::tvec2<T>(dot(p3, x3), dot(p4, x4))));
 }

 template <typename T> inline
                    glm::detail::tvec2<T> noise2(glm::detail::tvec2<T> const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + glm::detail::tvec2<T>(0.0)),
   noise1(glm::detail::tvec2<T>(0.0) - x));
 }

 template <typename T> inline
                    glm::detail::tvec2<T> noise2(glm::detail::tvec3<T> const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + glm::detail::tvec3<T>(0.0)),
   noise1(glm::detail::tvec3<T>(0.0) - x));
 }

 template <typename T> inline
                    glm::detail::tvec2<T> noise2(glm::detail::tvec4<T> const & x)
 {
  return glm::detail::tvec2<T>(
   noise1(x + glm::detail::tvec4<T>(0.0)),
   noise1(glm::detail::tvec4<T>(0.0) - x));
 }

 template <typename T> inline
                    glm::detail::tvec3<T> noise3(glm::detail::tvec2<T> const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - glm::detail::tvec2<T>(1.0)),
   noise1(x + glm::detail::tvec2<T>(0.0)),
   noise1(x + glm::detail::tvec2<T>(1.0)));
 }

 template <typename T> inline
                    glm::detail::tvec3<T> noise3(glm::detail::tvec3<T> const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - glm::detail::tvec3<T>(1.0)),
   noise1(x + glm::detail::tvec3<T>(0.0)),
   noise1(x + glm::detail::tvec3<T>(1.0)));
 }

 template <typename T> inline
                    glm::detail::tvec3<T> noise3(glm::detail::tvec4<T> const & x)
 {
  return glm::detail::tvec3<T>(
   noise1(x - glm::detail::tvec4<T>(1.0)),
   noise1(x + glm::detail::tvec4<T>(0.0)),
   noise1(x + glm::detail::tvec4<T>(1.0)));
 }

 template <typename T> inline
                    glm::detail::tvec4<T> noise4(glm::detail::tvec2<T> const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - glm::detail::tvec2<T>(1.0)),
   noise1(x + glm::detail::tvec2<T>(0.0)),
   noise1(x + glm::detail::tvec2<T>(1.0)),
   noise1(x + glm::detail::tvec2<T>(2.0)));
 }


 template <typename T> inline
                    glm::detail::tvec4<T> noise4(glm::detail::tvec3<T> const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - glm::detail::tvec3<T>(1.0)),
   noise1(x + glm::detail::tvec3<T>(0.0)),
   noise1(x + glm::detail::tvec3<T>(1.0)),
   noise1(x + glm::detail::tvec3<T>(2.0)));
 }

 template <typename T> inline
                    glm::detail::tvec4<T> noise4(glm::detail::tvec4<T> const & x)
 {
  return glm::detail::tvec4<T>(
   noise1(x - glm::detail::tvec4<T>(1.0)),
   noise1(x + glm::detail::tvec4<T>(0.0)),
   noise1(x + glm::detail::tvec4<T>(1.0)),
   noise1(x + glm::detail::tvec4<T>(2.0)));
 }

}
# 85 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/./core/func_noise.hpp" 2
# 108 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/external/glm-0.9.4.0/glm/glm.hpp" 2
# 14 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2

using namespace glm;


# 1 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/common/shader.hpp" 1



GLuint LoadShaders(const char * vertex_file_path,const char * fragment_file_path);
# 17 "/Users/elliotfiske/471/OpenGL-tutorial_v0014_21/lab4/prog2A.cpp" 2


int width, height;


void window_resized(GLFWwindow* window, int width_, int height_) {
    printf("Width: %d, Height: %d\n", width, height);
    width = width_;
    height = height_;
    glViewport(0, 0, width, height);
}

int main( void )
{

 if( !glfwInit() )
 {
  fprintf( __stderrp, "Failed to initialize GLFW\n" );
  return -1;
 }

 glfwWindowHint(0x0002100D, 4);
 glfwWindowHint(0x00022002, 2);
 glfwWindowHint(0x00022003, 1);



 window = glfwCreateWindow( 1024, 768, "Program 2A - fun with points", __null, __null);
 if( window == __null ){
  fprintf( __stderrp, "Failed to open GLFW window. If you have an Intel GPU, they are not 3.3 compatible. Try the 2.1 version of the tutorials.\n" );
  glfwTerminate();
  return -1;
 }
 glfwMakeContextCurrent(window);


 if (glewInit() != 0) {
  fprintf(__stderrp, "Failed to initialize GLEW\n");
  return -1;
 }


 glfwSetInputMode(window, 0x00033002, 1);

    glfwSetWindowSizeCallback(window, window_resized);


 glClearColor(0.0f, 0.0f, 0.4f, 0.0f);
    glEnable(0x8642);


 GLuint programID = LoadShaders( "SimpleVertexShader.vertexshader", "SimpleFragmentShader.fragmentshader" );


 GLuint vertexPosition_modelspaceID = __glewGetAttribLocation(programID, "vertexPosition_modelspace");
    GLuint vertexColorID = __glewGetAttribLocation(programID, "vertexColor");
    GLuint winScaleID = __glewGetUniformLocation(programID, "uWinScale");
    GLuint winCenterID = __glewGetUniformLocation(programID, "uWinCenter");
    GLuint timeID = __glewGetUniformLocation(programID, "uTime");
    GLuint targetDistID = __glewGetUniformLocation(programID, "uTargetDist");

    static GLfloat g_point_buffer_data[40 * 2];
    srand((unsigned int)time(__null));
    for (int i = 0; i < 40 * 2; i++) {
        float newPointCoord = (float)rand()/(float)(0x7fffffff/2.0) - 1;
        g_point_buffer_data[i] = newPointCoord;
    }



    static const GLfloat g_color_buffer_data[] = {
        1.0f, 1.0f, 1.0f,
        1.0f, 1.0f, 1.0f,
    };

 GLuint vertexbuffer;
 __glewGenBuffers(1, &vertexbuffer);
 __glewBindBuffer(0x8892, vertexbuffer);
 __glewBufferData(0x8892, sizeof(g_point_buffer_data), g_point_buffer_data, 0x88E4);

    GLuint colorbuffer;
    __glewGenBuffers(1, &colorbuffer);
    __glewBindBuffer(0x8892, colorbuffer);
    __glewBufferData(0x8892, sizeof(g_color_buffer_data), g_color_buffer_data, 0x88E4);


    float l_time = 0;

 do{


  glClear( 0x00004000 );


  __glewUseProgram(programID);


        if (width > height) {
            __glewUniform2f(winScaleID, height / (float) width, 1);
        }
        else {
            __glewUniform2f(winScaleID, 1, width / (float) height);
        }
        __glewUniform2f(winCenterID, (float) width/2, (float) height/2);


        __glewUniform1f(timeID, l_time);
        if (l_time < 100000) {
            l_time += 0.1;
        }



  __glewEnableVertexAttribArray(vertexPosition_modelspaceID);
  __glewBindBuffer(0x8892, vertexbuffer);
  __glewVertexAttribPointer(
   vertexPosition_modelspaceID,
   3,
   0x1406,
   0,
   0,
   (void*)0
  );


        __glewEnableVertexAttribArray(vertexColorID);
        __glewBindBuffer(0x8892, colorbuffer);
        __glewVertexAttribPointer(
                              vertexColorID,
                              3,
                              0x1406,
                              0,
                              0,
                              (void*)0
                              );


        glDrawArrays(0x0000, 0, 40);

  __glewDisableVertexAttribArray(vertexPosition_modelspaceID);


  glfwSwapBuffers(window);
  glfwPollEvents();

 }
 while( glfwGetKey(window, 256 ) != 1 &&
     glfwWindowShouldClose(window) == 0 );



 __glewDeleteBuffers(1, &vertexbuffer);
 __glewDeleteProgram(programID);


 glfwTerminate();

 return 0;
}
